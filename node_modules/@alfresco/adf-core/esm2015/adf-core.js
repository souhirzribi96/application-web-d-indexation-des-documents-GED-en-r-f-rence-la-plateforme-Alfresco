/**
 * @license
 * Copyright 2018 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { HttpClient, HttpClientModule } from '@angular/common/http';
import { Injectable, ChangeDetectionStrategy, Component, ViewEncapsulation, ContentChild, EventEmitter, HostListener, ElementRef, Input, Output, TemplateRef, Inject, Directive, NgModule, InjectionToken, Optional, Pipe, ChangeDetectorRef, HostBinding, ContentChildren, ViewChild, IterableDiffers, Renderer2, Renderer, Host, NgZone, ViewContainerRef, ComponentFactoryResolver, forwardRef, Compiler, APP_INITIALIZER } from '@angular/core';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { __awaiter } from 'tslib';
import * as alfrescoApi from 'alfresco-js-api';
import { Subject } from 'rxjs/Subject';
import { Location, CommonModule, DatePipe } from '@angular/common';
import { TranslateService, TranslateModule, TranslateLoader } from '@ngx-translate/core';
import 'rxjs/add/operator/distinctUntilChanged';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw';
import { DomSanitizer, Title } from '@angular/platform-browser';
import 'rxjs/add/operator/do';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialog, MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule, MatMenuModule, MatProgressBarModule, MatSidenavModule, MatSnackBarModule, MatToolbarModule, MatTooltipModule, MatIconRegistry, DateAdapter, MatMenuTrigger, MatSnackBar, MAT_DATE_FORMATS, MatSidenav } from '@angular/material';
import { FormControl, Validators, FormsModule, ReactiveFormsModule, FormBuilder, NG_VALUE_ACCESSOR } from '@angular/forms';
import 'rxjs/add/operator/toPromise';
import { MatDatetimepickerModule, MatNativeDatetimeModule, DatetimeAdapter, MAT_DATETIME_FORMATS } from '@mat-datetimepicker/core';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/concat';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/merge';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/toArray';
import 'rxjs/add/operator/take';
import moment from 'moment-es6';
import { FlexLayoutModule } from '@angular/flex-layout';
import { Router, RouterModule } from '@angular/router';
import { isMoment } from 'moment';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/buffer';
import 'rxjs/add/operator/filter';
import { OverlayContainer } from '@angular/cdk/overlay';
import { ViewportRuler } from '@angular/cdk/scrolling';
import 'rxjs/observable/forkJoin';
import 'rxjs/add/observable/from';
import 'rxjs/add/observable/zip';
import 'rxjs/add/operator/mergeMap';
import { MomentDatetimeAdapter, MAT_MOMENT_DATETIME_FORMATS } from '@mat-datetimepicker/moment';
import 'rxjs/add/operator/defaultIfEmpty';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { HttpModule } from '@angular/http';
import { MediaMatcher } from '@angular/cdk/layout';
import 'rxjs/add/operator/concatMap';
import 'rxjs/add/operator/combineAll';
import 'rxjs/add/observable/interval';
import 'rxjs/add/operator/takeWhile';
import { map } from 'rxjs/operators';
import 'rxjs/add/observable/forkJoin';
import * as minimatch_ from 'minimatch';
import minimatch___default, {  } from 'minimatch';

class BaseEvent {
    constructor() {
        this.isDefaultPrevented = false;
    }
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    preventDefault() {
        this.isDefaultPrevented = true;
    }
}

class BaseUIEvent extends BaseEvent {
}

const FileUploadStatus = {
    Pending: 0,
    Complete: 1,
    Starting: 2,
    Progress: 3,
    Cancelled: 4,
    Aborted: 5,
    Error: 6,
    Deleted: 7,
};
FileUploadStatus[FileUploadStatus.Pending] = "Pending";
FileUploadStatus[FileUploadStatus.Complete] = "Complete";
FileUploadStatus[FileUploadStatus.Starting] = "Starting";
FileUploadStatus[FileUploadStatus.Progress] = "Progress";
FileUploadStatus[FileUploadStatus.Cancelled] = "Cancelled";
FileUploadStatus[FileUploadStatus.Aborted] = "Aborted";
FileUploadStatus[FileUploadStatus.Error] = "Error";
FileUploadStatus[FileUploadStatus.Deleted] = "Deleted";
class FileModel {
    constructor(file, options) {
        this.status = FileUploadStatus.Pending;
        this.file = file;
        this.id = this.generateId();
        this.name = file.name;
        this.size = file.size;
        this.data = null;
        this.progress = {
            loaded: 0,
            total: 0,
            percent: 0
        };
        this.options = Object.assign({}, {
            newVersion: false
        }, options);
    }
    generateId() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            let                  r = Math.random() * 16 | 0,                  v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    get extension() {
        return this.name.slice((Math.max(0, this.name.lastIndexOf('.')) || Infinity) + 1);
    }
}

class FileUploadEvent {
    constructor(file, status = FileUploadStatus.Pending, error = null) {
        this.file = file;
        this.status = status;
        this.error = error;
    }
}
class FileUploadCompleteEvent extends FileUploadEvent {
    constructor(file, totalComplete = 0, data, totalAborted = 0) {
        super(file, FileUploadStatus.Complete);
        this.totalComplete = totalComplete;
        this.data = data;
        this.totalAborted = totalAborted;
    }
}
class FileUploadDeleteEvent extends FileUploadEvent {
    constructor(file, totalComplete = 0) {
        super(file, FileUploadStatus.Deleted);
        this.totalComplete = totalComplete;
    }
}
class FileUploadErrorEvent extends FileUploadEvent {
    constructor(file, error, totalError = 0) {
        super(file, FileUploadStatus.Error);
        this.error = error;
        this.totalError = totalError;
    }
}

class ObjectUtils {
    static getValue(target, key) {
        if (!target) {
            return undefined;
        }
        let                  keys = key.split('.');
        key = '';
        do {
            key += keys.shift();
            let                  value = target[key];
            if (value !== undefined && (typeof value === 'object' || !keys.length)) {
                target = value;
                key = '';
            }
            else if (!keys.length) {
                target = undefined;
            }
            else {
                key += '.';
            }
        } while (keys.length);
        return target;
    }
    static merge(...objects) {
        let                  result = {};
        objects.forEach(source => {
            Object.keys(source).forEach(prop => {
                if (prop in result && Array.isArray(result[prop])) {
                    result[prop] = result[prop].concat(source[prop]);
                }
                else if (prop in result && typeof result[prop] === 'object') {
                    result[prop] = ObjectUtils.merge(result[prop], source[prop]);
                }
                else {
                    result[prop] = source[prop];
                }
            });
        });
        return result;
    }
}

class AppConfigService {
    constructor(http) {
        this.http = http;
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent',
            alfrescoRepositoryName: 'alfresco-1'
        };
        this.onLoadSubject = new BehaviorSubject(this.config);
        this.onLoad = this.onLoadSubject.asObservable();
    }
    select(property) {
        return this.onLoadSubject.map((config) => config[property]).distinctUntilChanged();
    }
    get(key, defaultValue) {
        let                  result = ObjectUtils.getValue(this.config, key);
        if (typeof result === 'string') {
            const                  map$$1 = new Map();
            map$$1.set('hostname', this.getLocationHostname());
            map$$1.set(':port', this.getLocationPort(':'));
            map$$1.set('port', this.getLocationPort());
            result = this.formatString(result, map$$1);
        }
        if (result === undefined) {
            return defaultValue;
        }
        return                  (result);
    }
    getLocationHostname() {
        return location.hostname;
    }
    getLocationPort(prefix = '') {
        return location.port ? prefix + location.port : '';
    }
    load() {
        return new Promise(resolve => {
            this.http.get('app.config.json').subscribe((data) => {
                this.config = Object.assign({}, this.config, data || {});
                this.onLoadSubject.next(this.config);
                resolve(this.config);
            }, () => {
                resolve(this.config);
            });
        });
    }
    formatString(str, map$$1) {
        let                  result = str;
        map$$1.forEach((value, key) => {
            const                  expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        });
        return result;
    }
}
AppConfigService.APP_CONFIG_LANGUAGES_KEY = 'languages';
AppConfigService.decorators = [
    { type: Injectable },
];
AppConfigService.ctorParameters = () => [
    { type: HttpClient, },
];

class StorageService {
    constructor() {
        this.memoryStore = {};
        this.useLocalStorage = false;
        this.useLocalStorage = this.storageAvailable('localStorage');
    }
    getItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(key);
        }
        else {
            return this.memoryStore.hasOwnProperty(key) ? this.memoryStore[key] : null;
        }
    }
    setItem(key, data) {
        if (this.useLocalStorage) {
            localStorage.setItem(key, data);
        }
        else {
            this.memoryStore[key] = data.toString();
        }
    }
    clear() {
        if (this.useLocalStorage) {
            localStorage.clear();
        }
        else {
            this.memoryStore = {};
        }
    }
    removeItem(key) {
        if (this.useLocalStorage) {
            localStorage.removeItem(key);
        }
        else {
            delete this.memoryStore[key];
        }
    }
    hasItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(key) ? true : false;
        }
        else {
            return this.memoryStore.hasOwnProperty(key);
        }
    }
    storageAvailable(type) {
        try {
            let                  storage = window[type];
            const                  key = '__storage_test__';
            storage.setItem(key, key);
            storage.removeItem(key, key);
            return true;
        }
        catch (                 e) {
            return false;
        }
    }
}
StorageService.decorators = [
    { type: Injectable },
];
StorageService.ctorParameters = () => [];

class AlfrescoApiService {
    constructor(appConfig, storage) {
        this.appConfig = appConfig;
        this.storage = storage;
        this.nodeUpdated = new Subject();
    }
    getInstance() {
        return this.alfrescoApi;
    }
    get contentApi() {
        return this.getInstance().content;
    }
    get nodesApi() {
        return this.getInstance().nodes;
    }
    get renditionsApi() {
        return this.getInstance().core.renditionsApi;
    }
    get sharedLinksApi() {
        return this.getInstance().core.sharedlinksApi;
    }
    get sitesApi() {
        return this.getInstance().core.sitesApi;
    }
    get favoritesApi() {
        return this.getInstance().core.favoritesApi;
    }
    get peopleApi() {
        return this.getInstance().core.peopleApi;
    }
    get searchApi() {
        return this.getInstance().search.searchApi;
    }
    get versionsApi() {
        return this.getInstance().core.versionsApi;
    }
    get classesApi() {
        return this.getInstance().core.classesApi;
    }
    get groupsApi() {
        return this.getInstance().core.groupsApi;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.appConfig.load().then(() => {
                this.initAlfrescoApi();
            });
        });
    }
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initAlfrescoApi();
        });
    }
    initAlfrescoApi() {
        this.alfrescoApi =                  (new alfrescoApi({
            provider: this.storage.getItem('AUTH_TYPE'),
            ticketEcm: this.storage.getItem('ticket-ECM'),
            ticketBpm: this.storage.getItem('ticket-BPM'),
            hostEcm: this.appConfig.get('ecmHost'),
            hostBpm: this.appConfig.get('bpmHost'),
            contextRootBpm: this.appConfig.get('contextRootBpm'),
            contextRoot: this.appConfig.get('contextRootEcm'),
            disableCsrf: this.storage.getItem('DISABLE_CSRF') === 'true',
            oauth2: this.appConfig.get('oauth2')
        }));
    }
}
AlfrescoApiService.decorators = [
    { type: Injectable },
];
AlfrescoApiService.ctorParameters = () => [
    { type: AppConfigService, },
    { type: StorageService, },
];

class LogLevelsEnum extends Number {
}
LogLevelsEnum.TRACE = 5;
LogLevelsEnum.DEBUG = 4;
LogLevelsEnum.INFO = 3;
LogLevelsEnum.WARN = 2;
LogLevelsEnum.ERROR = 1;
LogLevelsEnum.SILENT = 0;
let logLevels = [
    { level: LogLevelsEnum.TRACE, name: 'TRACE' },
    { level: LogLevelsEnum.DEBUG, name: 'DEBUG' },
    { level: LogLevelsEnum.INFO, name: 'INFO' },
    { level: LogLevelsEnum.WARN, name: 'WARN' },
    { level: LogLevelsEnum.ERROR, name: 'ERROR' },
    { level: LogLevelsEnum.SILENT, name: 'SILENT' }
];

class LogService {
    constructor(appConfig) {
        this.appConfig = appConfig;
        this.onMessage = new Subject();
    }
    get currentLogLevel() {
        let                  configLevel = this.appConfig.get('logLevel');
        if (configLevel) {
            return this.getLogLevel(configLevel);
        }
        return LogLevelsEnum.TRACE;
    }
    error(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.ERROR) {
            this.messageBus(message, 'ERROR');
            console.error(message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.DEBUG) {
            this.messageBus(message, 'DEBUG');
            console.debug(message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.INFO) {
            this.messageBus(message, 'INFO');
            console.info(message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            this.messageBus(message, 'LOG');
            console.log(message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            this.messageBus(message, 'TRACE');
            console.trace(message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.WARN) {
            this.messageBus(message, 'WARN');
            console.warn(message, ...optionalParams);
        }
    }
    assert(test, message, ...optionalParams) {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            this.messageBus(message, 'ASSERT');
            console.assert(test, message, ...optionalParams);
        }
    }
    group(groupTitle, ...optionalParams) {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            console.group(groupTitle, ...optionalParams);
        }
    }
    groupEnd() {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            console.groupEnd();
        }
    }
    getLogLevel(level) {
        let                  referencedLevel = logLevels.find((currentLevel) => {
            return currentLevel.name.toLocaleLowerCase() === level.toLocaleLowerCase();
        });
        return referencedLevel ? referencedLevel.level : 5;
    }
    messageBus(text, logLevel) {
        this.onMessage.next({ text: text, type: logLevel });
    }
}
LogService.decorators = [
    { type: Injectable },
];
LogService.ctorParameters = () => [
    { type: AppConfigService, },
];

class ViewerMoreActionsComponent {
}
ViewerMoreActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-more-actions',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-more-actions' },
                template: `<ng-content></ng-content>`
            },] },
];
ViewerMoreActionsComponent.ctorParameters = () => [];

class ViewerOpenWithComponent {
}
ViewerOpenWithComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-open-with',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-open-with' },
                template: `<ng-content></ng-content>`
            },] },
];
ViewerOpenWithComponent.ctorParameters = () => [];

class ViewerSidebarComponent {
}
ViewerSidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-sidebar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-sidebar' },
                template: `<ng-content></ng-content>`
            },] },
];
ViewerSidebarComponent.ctorParameters = () => [];

class ViewerToolbarComponent {
}
ViewerToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-toolbar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-toolbar' },
                template: `<ng-content></ng-content>`
            },] },
];
ViewerToolbarComponent.ctorParameters = () => [];

class ViewerComponent {
    constructor(apiService, logService, location, el) {
        this.apiService = apiService;
        this.logService = logService;
        this.location = location;
        this.el = el;
        this.urlFile = '';
        this.urlFileViewer = null;
        this.fileNodeId = null;
        this.sharedLinkId = null;
        this.overlayMode = false;
        this.showViewer = true;
        this.showToolbar = true;
        this.allowGoBack = true;
        this.allowDownload = true;
        this.allowPrint = false;
        this.allowShare = false;
        this.allowFullScreen = true;
        this.allowNavigate = false;
        this.canNavigateBefore = true;
        this.canNavigateNext = true;
        this.allowSidebar = false;
        this.allowThumbnails = true;
        this.showSidebar = false;
        this.sidebarPosition = 'right';
        this.sidebarTemplate = null;
        this.thumbnailsTemplate = null;
        this.downloadUrl = null;
        this.maxRetries = 5;
        this.goBack = new EventEmitter();
        this.download = new EventEmitter();
        this.print = new EventEmitter();
        this.share = new EventEmitter();
        this.showViewerChange = new EventEmitter();
        this.extensionChange = new EventEmitter();
        this.navigateBefore = new EventEmitter();
        this.navigateNext = new EventEmitter();
        this.showPdfThumbnails = false;
        this.viewerType = 'unknown';
        this.isLoading = false;
        this.extensionTemplates = [];
        this.externalExtensions = [];
        this.sidebarTemplateContext = { node: null };
        this.subscriptions = [];
        this.extensions = {
            image: ['png', 'jpg', 'jpeg', 'gif', 'bpm', 'svg'],
            media: ['wav', 'mp4', 'mp3', 'webm', 'ogg'],
            text: ['txt', 'xml', 'js', 'html', 'json', 'ts'],
            pdf: ['pdf']
        };
        this.mimeTypes = {
            text: ['text/plain', 'text/csv', 'text/xml', 'text/html', 'application/x-javascript'],
            pdf: ['application/pdf'],
            image: ['image/png', 'image/jpeg', 'image/gif', 'image/bmp', 'image/svg+xml'],
            media: ['video/mp4', 'video/webm', 'video/ogg', 'audio/mpeg', 'audio/ogg', 'audio/wav']
        };
    }
    isSourceDefined() {
        return (this.urlFile || this.blobFile || this.fileNodeId || this.sharedLinkId) ? true : false;
    }
    ngOnInit() {
        this.subscriptions = this.subscriptions.concat([
            this.apiService.nodeUpdated.subscribe(node => this.onNodeUpdated(node))
        ]);
    }
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
        this.subscriptions = [];
    }
    onNodeUpdated(node) {
        if (node && node.id === this.fileNodeId) {
            this.setUpNodeFile(node);
        }
    }
    ngOnChanges(changes) {
        if (this.showViewer) {
            if (!this.isSourceDefined()) {
                throw new Error('A content source attribute value is missing.');
            }
            if (this.blobFile) {
                this.setUpBlobData();
            }
            else if (this.urlFile) {
                this.setUpUrlFile();
            }
            else if (this.fileNodeId) {
                this.isLoading = true;
                this.apiService.nodesApi.getNodeInfo(this.fileNodeId).then((data) => {
                    this.setUpNodeFile(data);
                }, (error) => {
                    this.isLoading = false;
                    this.logService.error('This node does not exist');
                });
            }
            else if (this.sharedLinkId) {
                this.isLoading = true;
                this.apiService.sharedLinksApi.getSharedLink(this.sharedLinkId).then(details => {
                    this.setUpSharedLinkFile(details);
                });
            }
        }
    }
    setUpBlobData() {
        this.displayName = this.getDisplayName('Unknown');
        this.isLoading = true;
        this.mimeType = this.blobFile.type;
        this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        this.allowDownload = false;
        this.extensionChange.emit(this.mimeType);
        this.isLoading = false;
        this.scrollTop();
    }
    setUpUrlFile() {
        this.isLoading = true;
        let                  filenameFromUrl = this.getFilenameFromUrl(this.urlFile);
        this.displayName = this.getDisplayName(filenameFromUrl);
        this.extension = this.getFileExtension(filenameFromUrl);
        this.urlFileContent = this.urlFile;
        this.downloadUrl = this.urlFile;
        this.fileName = this.displayName;
        this.viewerType = this.urlFileViewer || this.getViewerTypeByExtension(this.extension);
        if (this.viewerType === 'unknown') {
            this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        }
        this.extensionChange.emit(this.extension);
        this.isLoading = false;
        this.scrollTop();
    }
    setUpNodeFile(data) {
        this.mimeType = data.content.mimeType;
        this.displayName = data.name;
        this.urlFileContent = this.apiService.contentApi.getContentUrl(data.id);
        this.extension = this.getFileExtension(data.name);
        this.fileName = data.name;
        this.downloadUrl = this.apiService.contentApi.getContentUrl(data.id, true);
        this.viewerType = this.getViewerTypeByExtension(this.extension);
        if (this.viewerType === 'unknown') {
            this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        }
        if (this.viewerType === 'unknown') {
            this.displayNodeRendition(data.id);
        }
        else {
            this.isLoading = false;
        }
        this.extensionChange.emit(this.extension);
        this.sidebarTemplateContext.node = data;
        this.scrollTop();
    }
    setUpSharedLinkFile(details) {
        this.mimeType = details.entry.content.mimeType;
        this.displayName = this.getDisplayName(details.entry.name);
        this.extension = this.getFileExtension(details.entry.name);
        this.fileName = details.entry.name;
        this.urlFileContent = this.apiService.contentApi.getSharedLinkContentUrl(this.sharedLinkId, false);
        this.downloadUrl = this.apiService.contentApi.getSharedLinkContentUrl(this.sharedLinkId, true);
        this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        if (this.viewerType === 'unknown') {
            this.viewerType = this.getViewerTypeByExtension(this.extension);
        }
        if (this.viewerType === 'unknown') {
            this.displaySharedLinkRendition(this.sharedLinkId);
        }
        else {
            this.isLoading = false;
        }
        this.extensionChange.emit(this.extension);
        this.isLoading = false;
    }
    toggleSidebar() {
        this.showSidebar = !this.showSidebar;
        if (this.showSidebar && this.fileNodeId) {
            this.apiService.getInstance().nodes.getNodeInfo(this.fileNodeId)
                .then((data) => {
                this.sidebarTemplateContext.node = data;
            });
        }
    }
    getDisplayName(name) {
        return this.displayName || name;
    }
    scrollTop() {
        window.scrollTo(0, 1);
    }
    getViewerTypeByMimeType(mimeType) {
        if (mimeType) {
            mimeType = mimeType.toLowerCase();
            const                  editorTypes = Object.keys(this.mimeTypes);
            for (let                  type of editorTypes) {
                if (this.mimeTypes[type].indexOf(mimeType) >= 0) {
                    return type;
                }
            }
        }
        return 'unknown';
    }
    getViewerTypeByExtension(extension) {
        if (extension) {
            extension = extension.toLowerCase();
        }
        if (this.isCustomViewerExtension(extension)) {
            return 'custom';
        }
        if (this.extensions.image.indexOf(extension) >= 0) {
            return 'image';
        }
        if (this.extensions.media.indexOf(extension) >= 0) {
            return 'media';
        }
        if (this.extensions.text.indexOf(extension) >= 0) {
            return 'text';
        }
        if (this.extensions.pdf.indexOf(extension) >= 0) {
            return 'pdf';
        }
        return 'unknown';
    }
    onBackButtonClick() {
        if (this.overlayMode) {
            this.close();
        }
        else {
            const                  event = new BaseEvent();
            this.goBack.next(event);
            if (!event.defaultPrevented) {
                this.location.back();
            }
        }
    }
    onNavigateBeforeClick() {
        this.navigateBefore.next();
    }
    onNavigateNextClick() {
        this.navigateNext.next();
    }
    close() {
        if (this.otherMenu) {
            this.otherMenu.hidden = false;
        }
        this.showViewer = false;
        this.showViewerChange.emit(this.showViewer);
    }
    getFilenameFromUrl(url) {
        let                  anchor = url.indexOf('#');
        let                  query = url.indexOf('?');
        let                  end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
        return url.substring(url.lastIndexOf('/', end) + 1, end);
    }
    getFileExtension(fileName) {
        if (fileName) {
            const                  match = fileName.match(/\.([^\./\?\#]+)($|\?|\#)/);
            return match ? match[1] : null;
        }
        return null;
    }
    isCustomViewerExtension(extension) {
        const                  extensions = this.externalExtensions || [];
        if (extension && extensions.length > 0) {
            extension = extension.toLowerCase();
            return extensions.indexOf(extension) >= 0;
        }
        return false;
    }
    handleKeyboardEvent(event) {
        const                  key = event.keyCode;
        if (key === 27 && this.overlayMode) {
            this.close();
        }
        if (key === 37 && this.canNavigateBefore) {
            event.preventDefault();
            this.onNavigateBeforeClick();
        }
        if (key === 39 && this.canNavigateNext) {
            event.preventDefault();
            this.onNavigateNextClick();
        }
        if (key === 70 && event.ctrlKey) {
            event.preventDefault();
            this.enterFullScreen();
        }
    }
    downloadContent() {
        if (this.allowDownload && this.downloadUrl && this.fileName) {
            const                  args = new BaseEvent();
            this.download.next(args);
            if (!args.defaultPrevented) {
                const                  link = document.createElement('a');
                link.style.display = 'none';
                link.download = this.fileName;
                link.href = this.downloadUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }
    printContent() {
        if (this.allowPrint) {
            const                  args = new BaseEvent();
            this.print.next(args);
        }
    }
    shareContent() {
        if (this.allowShare) {
            const                  args = new BaseEvent();
            this.share.next(args);
        }
    }
    enterFullScreen() {
        if (this.allowFullScreen) {
            const                  container = this.el.nativeElement.querySelector('.adf-viewer__fullscreen-container');
            if (container) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                }
                else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
                else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                }
                else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            }
        }
    }
    displayNodeRendition(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isLoading = true;
            try {
                const                  rendition = yield this.resolveRendition(nodeId, 'pdf');
                if (rendition) {
                    const                  renditionId = rendition.entry.id;
                    if (renditionId === 'pdf') {
                        this.viewerType = 'pdf';
                    }
                    else if (renditionId === 'imgpreview') {
                        this.viewerType = 'image';
                    }
                    this.urlFileContent = this.apiService.contentApi.getRenditionUrl(nodeId, renditionId);
                }
            }
            catch (                 err) {
                this.logService.error(err);
            }
            this.isLoading = false;
        });
    }
    displaySharedLinkRendition(sharedId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isLoading = true;
            try {
                const                  rendition = yield this.apiService.renditionsApi.getSharedLinkRendition(sharedId, 'pdf');
                if (rendition.entry.status.toString() === 'CREATED') {
                    this.viewerType = 'pdf';
                    this.urlFileContent = this.apiService.contentApi.getSharedLinkRenditionUrl(sharedId, 'pdf');
                }
            }
            catch (                 error) {
                this.logService.error(error);
                try {
                    const                  rendition = yield this.apiService.renditionsApi.getSharedLinkRendition(sharedId, 'imgpreview');
                    if (rendition.entry.status.toString() === 'CREATED') {
                        this.viewerType = 'image';
                        this.urlFileContent = this.apiService.contentApi.getSharedLinkRenditionUrl(sharedId, 'imgpreview');
                    }
                }
                catch (                 error) {
                    this.logService.error(error);
                }
            }
            this.isLoading = false;
        });
    }
    resolveRendition(nodeId, renditionId) {
        return __awaiter(this, void 0, void 0, function* () {
            renditionId = renditionId.toLowerCase();
            const                  supported = yield this.apiService.renditionsApi.getRenditions(nodeId);
            let                  rendition = supported.list.entries.find(obj => obj.entry.id.toLowerCase() === renditionId);
            if (!rendition) {
                renditionId = 'imgpreview';
                rendition = supported.list.entries.find(obj => obj.entry.id.toLowerCase() === renditionId);
                if (!rendition) {
                    return null;
                }
            }
            const                  status = rendition.entry.status.toString();
            if (status === 'CREATED') {
                return rendition;
            }
            else if (status === 'NOT_CREATED') {
                try {
                    yield this.apiService.renditionsApi.createRendition(nodeId, { id: renditionId });
                    return yield this.waitRendition(nodeId, renditionId, 0);
                }
                catch (                 err) {
                    this.logService.error(err);
                    return null;
                }
            }
        });
    }
    waitRendition(nodeId, renditionId, retries) {
        return __awaiter(this, void 0, void 0, function* () {
            const                  rendition = yield this.apiService.renditionsApi.getRendition(nodeId, renditionId);
            if (retries > this.maxRetries) {
                return null;
            }
            const                  status = rendition.entry.status.toString();
            if (status === 'CREATED') {
                return rendition;
            }
            else {
                retries += 1;
                yield this.wait(1000);
                return yield this.waitRendition(nodeId, renditionId, retries);
            }
        });
    }
    wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
ViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer',
                template: `<div *ngIf="showViewer"
    class="adf-viewer-container"
    [class.adf-viewer-overlay-container]="overlayMode"
    [class.adf-viewer-inline-container]="!overlayMode">

    <div class="adf-viewer-content" fxLayout="column">
        <ng-content select="adf-viewer-toolbar"></ng-content>
        <ng-container *ngIf="showToolbar && !toolbar">
            <adf-toolbar color="default" class="adf-viewer-toolbar">

                <adf-toolbar-title>
                    <button *ngIf="allowGoBack"
                        class="adf-viewer-close-button"
                        data-automation-id="toolbar-back"
                        mat-icon-button
                        title="{{ 'ADF_VIEWER.ACTIONS.CLOSE' | translate }}"
                        (click)="onBackButtonClick()">
                        <mat-icon>close</mat-icon>
                    </button>
                </adf-toolbar-title>

                <div fxFlex="1 1 auto">
                    <button
                        *ngIf="allowNavigate && canNavigateBefore"
                        data-automation-id="toolbar-pref-file"
                        mat-icon-button
                        title="{{ 'ADF_VIEWER.ACTIONS.PREV_FILE' | translate }}"
                        (click)="onNavigateBeforeClick()">
                        <mat-icon>navigate_before</mat-icon>
                    </button>
                    <img class="adf-viewer__mimeicon" [src]="mimeType | adfMimeTypeIcon">
                    <span class="adf-viewer__display-name" id="adf-viewer-display-name">{{ displayName }}</span>
                    <button
                        *ngIf="allowNavigate && canNavigateNext"
                        data-automation-id="toolbar-next-file"
                        mat-icon-button
                        title="{{ 'ADF_VIEWER.ACTIONS.NEXT_FILE' | translate }}"
                        (click)="onNavigateNextClick()">
                        <mat-icon>navigate_next</mat-icon>
                    </button>
                </div>

                <ng-content select="adf-viewer-toolbar-actions"></ng-content>

                <ng-container *ngIf="mnuOpenWith">
                    <button
                        mat-button
                        [matMenuTriggerFor]="mnuOpenWith"
                        data-automation-id="toolbar-open-with">
                        <span>{{ 'ADF_VIEWER.ACTIONS.OPEN_WITH' | translate }}</span>
                        <mat-icon>arrow_drop_down</mat-icon>
                    </button>
                    <mat-menu #mnuOpenWith="matMenu" [overlapTrigger]="false">
                        <ng-content select="adf-viewer-open-with"></ng-content>
                    </mat-menu>
                </ng-container>

                <adf-toolbar-divider></adf-toolbar-divider>

                <button
                    *ngIf="allowDownload"
                    mat-icon-button
                    title="{{ 'ADF_VIEWER.ACTIONS.DOWNLOAD' | translate }}"
                    data-automation-id="toolbar-download"
                    (click)="downloadContent()">
                    <mat-icon>file_download</mat-icon>
                </button>

                <button
                    *ngIf="allowPrint"
                    mat-icon-button
                    title="{{ 'ADF_VIEWER.ACTIONS.PRINT' | translate }}"
                    data-automation-id="toolbar-print"
                    (click)="printContent()">
                    <mat-icon>print</mat-icon>
                </button>

                <button
                    *ngIf="allowShare"
                    mat-icon-button
                    title="{{ 'ADF_VIEWER.ACTIONS.SHARE' | translate }}"
                    data-automation-id="toolbar-share"
                    (click)="shareContent()">
                    <mat-icon>share</mat-icon>
                </button>

                <button
                    *ngIf="viewerType !== 'media' && allowFullScreen"
                    mat-icon-button
                    title="{{ 'ADF_VIEWER.ACTIONS.FULLSCREEN' | translate }}"
                    data-automation-id="toolbar-fullscreen"
                    (click)="enterFullScreen()">
                    <mat-icon>fullscreen</mat-icon>
                </button>

                <ng-container *ngIf="mnuMoreActions">
                    <button
                        mat-icon-button
                        [matMenuTriggerFor]="mnuMoreActions"
                        title="{{ 'ADF_VIEWER.ACTIONS.MORE_ACTIONS' | translate }}"
                        data-automation-id="toolbar-more-actions">
                        <mat-icon>more_vert</mat-icon>
                    </button>
                    <mat-menu #mnuMoreActions="matMenu" [overlapTrigger]="false">
                        <ng-content select="adf-viewer-more-actions"></ng-content>
                    </mat-menu>
                </ng-container>

                <ng-container *ngIf="allowSidebar">
                    <adf-toolbar-divider></adf-toolbar-divider>

                    <button
                        mat-icon-button
                        title="{{ 'ADF_VIEWER.ACTIONS.INFO' | translate }}"
                        data-automation-id="toolbar-sidebar"
                        [color]="showSidebar ? 'accent' : 'default'"
                        (click)="toggleSidebar($event)">
                        <mat-icon>info_outline</mat-icon>
                    </button>
                </ng-container>

            </adf-toolbar>
        </ng-container>

        <ng-container *ngIf="isLoading">
            <div class="adf-viewer__loading-screen" fxFlex="1 1 auto">
                <h2>{{ 'ADF_VIEWER.LOADING' | translate }}</h2>
                <div>
                    <mat-spinner></mat-spinner>
                </div>
            </div>
        </ng-container>

        <div *ngIf="!isLoading" fxLayout="row" fxFlex="1 1 auto">

            <ng-container *ngIf="allowSidebar && showSidebar">
                <div class="adf-viewer__sidebar adf-viewer__sidebar__{{sidebarPosition}}" fxFlexOrder="{{sidebarPosition === 'left'? 1 : 4 }}">
                    <ng-container *ngIf="sidebarTemplate">
                        <ng-container *ngTemplateOutlet="sidebarTemplate;context:sidebarTemplateContext"></ng-container>
                    </ng-container>
                    <ng-content *ngIf="!sidebarTemplate" select="adf-viewer-sidebar"></ng-content>
                </div>
            </ng-container>

            <div class="adf-viewer-main" fxFlexOrder="{{sidebarPosition !== 'left'? 1 : 4}}" fxFlex="1 1 auto">
                <div class="adf-viewer-layout-content adf-viewer__fullscreen-container">
                    <div class="adf-viewer-content-container" [ngSwitch]="viewerType">
                        <ng-container *ngSwitchCase="'pdf'">
                            <adf-pdf-viewer [thumbnailsTemplate]="thumbnailsTemplate" [allowThumbnails]="allowThumbnails" [blobFile]="blobFile" [urlFile]="urlFileContent" [nameFile]="displayName"></adf-pdf-viewer>
                        </ng-container>

                        <ng-container *ngSwitchCase="'image'">
                            <adf-img-viewer [urlFile]="urlFileContent" [nameFile]="displayName" [blobFile]="blobFile"></adf-img-viewer>
                        </ng-container>

                        <ng-container *ngSwitchCase="'media'">
                            <adf-media-player [urlFile]="urlFileContent" [mimeType]="mimeType" [blobFile]="blobFile" [nameFile]="displayName"></adf-media-player>
                        </ng-container>

                        <ng-container *ngSwitchCase="'text'">
                            <adf-txt-viewer [urlFile]="urlFileContent" [blobFile]="blobFile"></adf-txt-viewer>
                        </ng-container>

                        <ng-container *ngSwitchCase="'custom'">
                            <span class="adf-viewer-custom-content" *ngFor="let extensionTemplate of extensionTemplates">
                                <ng-template *ngIf="extensionTemplate.isVisible" [ngTemplateOutlet]="extensionTemplate.template" [ngTemplateOutletContext]="{ urlFileContent: urlFileContent, extension:extension }">
                                </ng-template>
                            </span>
                        </ng-container>

                        <ng-container *ngSwitchDefault>
                            <adf-viewer-unknown-format></adf-viewer-unknown-format>
                        </ng-container>
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>
`,
                styles: [``],
                host: { 'class': 'adf-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
ViewerComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
    { type: Location, },
    { type: ElementRef, },
];
ViewerComponent.propDecorators = {
    "toolbar": [{ type: ContentChild, args: [ViewerToolbarComponent,] },],
    "sidebar": [{ type: ContentChild, args: [ViewerSidebarComponent,] },],
    "mnuOpenWith": [{ type: ContentChild, args: [ViewerOpenWithComponent,] },],
    "mnuMoreActions": [{ type: ContentChild, args: [ViewerMoreActionsComponent,] },],
    "urlFile": [{ type: Input },],
    "urlFileViewer": [{ type: Input },],
    "blobFile": [{ type: Input },],
    "fileNodeId": [{ type: Input },],
    "sharedLinkId": [{ type: Input },],
    "overlayMode": [{ type: Input },],
    "showViewer": [{ type: Input },],
    "showToolbar": [{ type: Input },],
    "displayName": [{ type: Input },],
    "allowGoBack": [{ type: Input },],
    "allowDownload": [{ type: Input },],
    "allowPrint": [{ type: Input },],
    "allowShare": [{ type: Input },],
    "allowFullScreen": [{ type: Input },],
    "allowNavigate": [{ type: Input },],
    "canNavigateBefore": [{ type: Input },],
    "canNavigateNext": [{ type: Input },],
    "allowSidebar": [{ type: Input },],
    "allowThumbnails": [{ type: Input },],
    "showSidebar": [{ type: Input },],
    "sidebarPosition": [{ type: Input },],
    "sidebarTemplate": [{ type: Input },],
    "thumbnailsTemplate": [{ type: Input },],
    "mimeType": [{ type: Input },],
    "fileName": [{ type: Input },],
    "downloadUrl": [{ type: Input },],
    "maxRetries": [{ type: Input },],
    "goBack": [{ type: Output },],
    "download": [{ type: Output },],
    "print": [{ type: Output },],
    "share": [{ type: Output },],
    "showViewerChange": [{ type: Output },],
    "extensionChange": [{ type: Output },],
    "navigateBefore": [{ type: Output },],
    "navigateNext": [{ type: Output },],
    "handleKeyboardEvent": [{ type: HostListener, args: ['document:keyup', ['$event'],] },],
};

class PermissionsEnum extends String {
}
PermissionsEnum.DELETE = 'delete';
PermissionsEnum.UPDATE = 'update';
PermissionsEnum.CREATE = 'create';
PermissionsEnum.COPY = 'copy';
PermissionsEnum.LOCK = 'lock';
PermissionsEnum.UPDATEPERMISSIONS = 'updatePermissions';
PermissionsEnum.NOT_DELETE = '!delete';
PermissionsEnum.NOT_UPDATE = '!update';
PermissionsEnum.NOT_CREATE = '!create';
PermissionsEnum.NOT_UPDATEPERMISSIONS = '!updatePermissions';

class CookieService {
    isEnabled() {
        if (navigator.cookieEnabled === false) {
            return false;
        }
        document.cookie = 'test-cookie';
        return document.cookie.indexOf('test-cookie') > 0;
    }
    getItem(key) {
        const                  regexp = new RegExp('(?:' + key + '|;\s*' + key + ')=(.*?)(?:;|$)', 'g');
        const                  result = regexp.exec(document.cookie);
        return (result === null) ? null : result[1];
    }
    setItem(key, data, expiration, path) {
        document.cookie = `${key}=${data}` +
            (expiration ? ';expires=' + expiration.toUTCString() : '') +
            (path ? `;path=${path}` : ';path=/');
    }
}
CookieService.decorators = [
    { type: Injectable },
];
CookieService.ctorParameters = () => [];

const UserPreferenceValues = {
    PaginationSize: 'PAGINATION_SIZE',
    DisableCSRF: 'DISABLE_CSRF',
    Locale: 'LOCALE',
    SupportedPageSizes: 'supportedPageSizes',
};
class UserPreferencesService {
    constructor(translate, appConfig, storage, apiService) {
        this.translate = translate;
        this.appConfig = appConfig;
        this.storage = storage;
        this.apiService = apiService;
        this.defaults = {
            paginationSize: 25,
            supportedPageSizes: [5, 10, 15, 20],
            locale: 'en'
        };
        this.userPreferenceStatus = {
            paginationSize: 25,
            supportedPageSizes: [5, 10, 15, 20],
            LOCALE: 'en'
        };
        this.appConfig.onLoad.subscribe(this.initUserPreferenceStatus.bind(this));
        this.localeSubject = new BehaviorSubject(this.defaults.locale);
        this.locale$ = this.localeSubject.asObservable();
        this.onChangeSubject = new BehaviorSubject(this.userPreferenceStatus);
        this.onChange = this.onChangeSubject.asObservable();
    }
    initUserPreferenceStatus() {
        this.userPreferenceStatus[UserPreferenceValues.Locale] = this.locale || this.getDefaultLocale();
        this.userPreferenceStatus[UserPreferenceValues.PaginationSize] = this.appConfig.get('pagination.size', this.defaults.paginationSize);
        this.userPreferenceStatus[UserPreferenceValues.SupportedPageSizes] = this.appConfig.get('pagination.supportedPageSizes', this.defaults.supportedPageSizes);
        this.userPreferenceStatus[UserPreferenceValues.DisableCSRF] = this.disableCSRF;
    }
    select(property) {
        return this.onChange.map((userPreferenceStatus) => userPreferenceStatus[property]).distinctUntilChanged();
    }
    get(property, defaultValue) {
        const                  key = this.getPropertyKey(property);
        const                  value = this.storage.getItem(key);
        if (value === undefined || value === null) {
            return defaultValue;
        }
        return value;
    }
    set(property, value) {
        if (!property) {
            return;
        }
        this.storage.setItem(this.getPropertyKey(property), value);
        this.userPreferenceStatus[property] = value;
        this.onChangeSubject.next(this.userPreferenceStatus);
    }
    getStoragePrefix() {
        return this.storage.getItem('USER_PROFILE') || 'GUEST';
    }
    setStoragePrefix(value) {
        this.storage.setItem('USER_PROFILE', value || 'GUEST');
    }
    getPropertyKey(property) {
        return `${this.getStoragePrefix()}__${property}`;
    }
    getDefaultPageSizes() {
        return this.defaults.supportedPageSizes;
    }
    set authType(value) {
        this.storage.setItem('AUTH_TYPE', value);
        this.apiService.reset();
    }
    get authType() {
        return this.storage.getItem('AUTH_TYPE') || 'ALL';
    }
    set disableCSRF(value) {
        this.set('DISABLE_CSRF', value);
        this.apiService.reset();
    }
    get disableCSRF() {
        return this.get('DISABLE_CSRF') === 'true';
    }
    set paginationSize(value) {
        this.set('PAGINATION_SIZE', value);
    }
    get paginationSize() {
        return Number(this.get('PAGINATION_SIZE')) || this.defaults.paginationSize;
    }
    get locale() {
        const                  locale = this.get('LOCALE');
        return locale;
    }
    set locale(value) {
        this.localeSubject.next(value);
        this.set('LOCALE', value);
    }
    getDefaultLocale() {
        return this.appConfig.get('locale') || this.translate.getBrowserLang() || 'en';
    }
}
UserPreferencesService.decorators = [
    { type: Injectable },
];
UserPreferencesService.ctorParameters = () => [
    { type: TranslateService, },
    { type: AppConfigService, },
    { type: StorageService, },
    { type: AlfrescoApiService, },
];

const REMEMBER_ME_COOKIE_KEY = 'ALFRESCO_REMEMBER_ME';
const REMEMBER_ME_UNTIL = 1000 * 60 * 60 * 24 * 30;
class AuthenticationService {
    constructor(preferences, alfrescoApi$$1, storage, cookie, logService) {
        this.preferences = preferences;
        this.alfrescoApi = alfrescoApi$$1;
        this.storage = storage;
        this.cookie = cookie;
        this.logService = logService;
        this.redirectUrl = null;
        this.onLogin = new Subject();
        this.onLogout = new Subject();
    }
    isLoggedIn() {
        return !!this.alfrescoApi.getInstance().isLoggedIn();
    }
    login(username, password, rememberMe = false) {
        this.removeTicket();
        return Observable.fromPromise(this.callApiLogin(username, password))
            .map((response) => {
            this.saveRememberMeCookie(rememberMe);
            this.saveTickets();
            this.onLogin.next(response);
            return {
                type: this.preferences.authType,
                ticket: response
            };
        })
            .catch(err => this.handleError(err));
    }
    saveRememberMeCookie(rememberMe) {
        let                  expiration = null;
        if (rememberMe) {
            expiration = new Date();
            const                  time = expiration.getTime();
            const                  expireTime = time + REMEMBER_ME_UNTIL;
            expiration.setTime(expireTime);
        }
        this.cookie.setItem(REMEMBER_ME_COOKIE_KEY, '1', expiration, null);
    }
    isRememberMeSet() {
        return (this.cookie.getItem(REMEMBER_ME_COOKIE_KEY) === null) ? false : true;
    }
    callApiLogin(username, password) {
        return this.alfrescoApi.getInstance().login(username, password);
    }
    logout() {
        return Observable.fromPromise(this.callApiLogout())
            .do(response => {
            this.removeTicket();
            this.onLogout.next(response);
            return response;
        })
            .catch(err => this.handleError(err));
    }
    callApiLogout() {
        if (this.alfrescoApi.getInstance()) {
            return this.alfrescoApi.getInstance().logout();
        }
    }
    removeTicket() {
        this.storage.removeItem('ticket-ECM');
        this.storage.removeItem('ticket-BPM');
        this.alfrescoApi.getInstance().setTicket(undefined, undefined);
    }
    getTicketEcm() {
        return this.storage.getItem('ticket-ECM');
    }
    getTicketBpm() {
        return this.storage.getItem('ticket-BPM');
    }
    getTicketEcmBase64() {
        let                  ticket = this.storage.getItem('ticket-ECM');
        if (ticket) {
            return 'Basic ' + btoa(ticket);
        }
        return null;
    }
    saveTickets() {
        this.saveTicketEcm();
        this.saveTicketBpm();
        this.saveTicketAuth();
    }
    saveTicketEcm() {
        if (this.alfrescoApi.getInstance() && this.alfrescoApi.getInstance().getTicketEcm()) {
            this.storage.setItem('ticket-ECM', this.alfrescoApi.getInstance().getTicketEcm());
        }
    }
    saveTicketBpm() {
        if (this.alfrescoApi.getInstance() && this.alfrescoApi.getInstance().getTicketBpm()) {
            this.storage.setItem('ticket-BPM', this.alfrescoApi.getInstance().getTicketBpm());
        }
    }
    saveTicketAuth() {
        if (this.alfrescoApi.getInstance() && (                 (this.alfrescoApi.getInstance())).getTicketAuth()) {
            this.storage.setItem('ticket-AUTH', (                 (this.alfrescoApi.getInstance())).getTicketAuth());
        }
    }
    isEcmLoggedIn() {
        if (this.cookie.isEnabled() && !this.isRememberMeSet()) {
            return false;
        }
        return this.alfrescoApi.getInstance().ecmAuth && !!this.alfrescoApi.getInstance().ecmAuth.isLoggedIn();
    }
    isBpmLoggedIn() {
        if (this.cookie.isEnabled() && !this.isRememberMeSet()) {
            return false;
        }
        return this.alfrescoApi.getInstance().bpmAuth && !!this.alfrescoApi.getInstance().bpmAuth.isLoggedIn();
    }
    getEcmUsername() {
        return this.alfrescoApi.getInstance().ecmAuth.username;
    }
    getBpmUsername() {
        return this.alfrescoApi.getInstance().bpmAuth.username;
    }
    setRedirectUrl(url) {
        this.redirectUrl = url;
    }
    getRedirectUrl(provider) {
        return this.hasValidRedirection(provider) ? this.redirectUrl.url : null;
    }
    hasValidRedirection(provider) {
        return this.redirectUrl && (this.redirectUrl.provider === provider || this.hasSelectedProviderAll(provider));
    }
    hasSelectedProviderAll(provider) {
        return this.redirectUrl && (this.redirectUrl.provider === 'ALL' || provider === 'ALL');
    }
    handleError(error) {
        this.logService.error('Error when logging in', error);
        return Observable.throw(error || 'Server error');
    }
}
AuthenticationService.decorators = [
    { type: Injectable },
];
AuthenticationService.ctorParameters = () => [
    { type: UserPreferencesService, },
    { type: AlfrescoApiService, },
    { type: StorageService, },
    { type: CookieService, },
    { type: LogService, },
];

class ContentService {
    constructor(authService, apiService, logService, sanitizer) {
        this.authService = authService;
        this.apiService = apiService;
        this.logService = logService;
        this.sanitizer = sanitizer;
        this.folderCreated = new Subject();
        this.folderCreate = new Subject();
        this.folderEdit = new Subject();
        this.saveData = (function () {
            let                  a = document.createElement('a');
            document.body.appendChild(a);
            a.style.display = 'none';
            return function (data, format, fileName) {
                let                  blob = null;
                if (format === 'blob' || format === 'data') {
                    blob = new Blob([data], { type: 'octet/stream' });
                }
                if (format === 'object' || format === 'json') {
                    let                  json = JSON.stringify(data);
                    blob = new Blob([json], { type: 'octet/stream' });
                }
                if (blob) {
                    if (typeof window.navigator !== 'undefined' && window.navigator.msSaveOrOpenBlob) {
                        navigator.msSaveOrOpenBlob(blob, fileName);
                    }
                    else {
                        let                  url = window.URL.createObjectURL(blob);
                        a.href = url;
                        a.download = fileName;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                }
            };
        }());
    }
    downloadBlob(blob, fileName) {
        this.saveData(blob, 'blob', fileName);
    }
    downloadData(data, fileName) {
        this.saveData(data, 'data', fileName);
    }
    downloadJSON(json, fileName) {
        this.saveData(json, 'json', fileName);
    }
    createTrustedUrl(blob) {
        let                  url = window.URL.createObjectURL(blob);
        return                  (this.sanitizer.bypassSecurityTrustUrl(url));
    }
    get contentApi() {
        return this.apiService.getInstance().content;
    }
    getDocumentThumbnailUrl(node, attachment, ticket) {
        if (node && node.entry) {
            node = node.entry.id;
        }
        return this.contentApi.getDocumentThumbnailUrl(node, attachment, ticket);
    }
    getContentUrl(node, attachment, ticket) {
        if (node && node.entry) {
            node = node.entry.id;
        }
        return this.contentApi.getContentUrl(node, attachment, ticket);
    }
    getNodeContent(nodeId) {
        return Observable.fromPromise(this.apiService.getInstance().core.nodesApi.getFileContent(nodeId).then((dataContent) => {
            return dataContent;
        })).catch(this.handleError);
    }
    createFolder(relativePath, name, parentId) {
        return Observable.fromPromise(this.apiService.getInstance().nodes.createFolder(name, relativePath, parentId))
            .do(data => {
            this.folderCreated.next(                 ({
                relativePath: relativePath,
                name: name,
                parentId: parentId,
                node: data
            }));
        })
            .catch(err => this.handleError(err));
    }
    getNode(nodeId, opts) {
        return Observable.fromPromise(this.apiService.getInstance().nodes.getNode(nodeId, opts));
    }
    hasPermission(node, permission) {
        let                  hasPermission = false;
        if (this.hasAllowableOperations(node)) {
            if (permission && permission.startsWith('!')) {
                hasPermission = node.allowableOperations.find(currentPermission => currentPermission === permission.replace('!', '')) ? false : true;
            }
            else {
                hasPermission = node.allowableOperations.find(currentPermission => currentPermission === permission) ? true : false;
            }
        }
        else {
            if (permission && permission.startsWith('!')) {
                hasPermission = true;
            }
        }
        if (permission === PermissionsEnum.COPY) {
            hasPermission = true;
        }
        if (permission === PermissionsEnum.LOCK) {
            hasPermission = node.isFile;
            if (node.isLocked && this.hasAllowableOperations(node)) {
                hasPermission = !!~node.allowableOperations.indexOf('updatePermissions');
            }
        }
        return hasPermission;
    }
    hasAllowableOperations(node) {
        return node && node.allowableOperations ? true : false;
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
ContentService.decorators = [
    { type: Injectable },
];
ContentService.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: AlfrescoApiService, },
    { type: LogService, },
    { type: DomSanitizer, },
];

class ImgViewerComponent {
    constructor(contentService, el) {
        this.contentService = contentService;
        this.el = el;
        this.showToolbar = true;
        this.rotate = 0;
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.isDragged = false;
        this.drag = { x: 0, y: 0 };
        this.delta = { x: 0, y: 0 };
    }
    get transform() {
        return `scale(${this.scaleX}, ${this.scaleY}) rotate(${this.rotate}deg) translate(${this.offsetX}px, ${this.offsetY}px)`;
    }
    get currentScaleText() {
        return Math.round(this.scaleX * 100) + '%';
    }
    ngOnInit() {
        this.element =                  (this.el.nativeElement.querySelector('#viewer-image'));
        if (this.element) {
            this.element.addEventListener('mousedown', this.onMouseDown.bind(this));
            this.element.addEventListener('mouseup', this.onMouseUp.bind(this));
            this.element.addEventListener('mouseleave', this.onMouseLeave.bind(this));
            this.element.addEventListener('mouseout', this.onMouseOut.bind(this));
            this.element.addEventListener('mousemove', this.onMouseMove.bind(this));
        }
    }
    ngOnDestroy() {
        if (this.element) {
            this.element.removeEventListener('mousedown', this.onMouseDown);
            this.element.removeEventListener('mouseup', this.onMouseUp);
            this.element.removeEventListener('mouseleave', this.onMouseLeave);
            this.element.removeEventListener('mouseout', this.onMouseOut);
            this.element.removeEventListener('mousemove', this.onMouseMove);
        }
    }
    onMouseDown(event) {
        event.preventDefault();
        this.isDragged = true;
        this.drag = { x: event.pageX, y: event.pageY };
    }
    onMouseMove(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.delta.x = event.pageX - this.drag.x;
            this.delta.y = event.pageY - this.drag.y;
            this.drag.x = event.pageX;
            this.drag.y = event.pageY;
            const                  scaleX = (this.scaleX !== 0 ? this.scaleX : 1.0);
            const                  scaleY = (this.scaleY !== 0 ? this.scaleY : 1.0);
            this.offsetX += (this.delta.x / scaleX);
            this.offsetY += (this.delta.y / scaleY);
        }
    }
    onMouseUp(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.isDragged = false;
        }
    }
    onMouseLeave(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.isDragged = false;
        }
    }
    onMouseOut(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.isDragged = false;
        }
    }
    ngOnChanges(changes) {
        let                  blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    zoomIn() {
        const                  ratio = +((this.scaleX + 0.2).toFixed(1));
        this.scaleX = this.scaleY = ratio;
    }
    zoomOut() {
        let                  ratio = +((this.scaleX - 0.2).toFixed(1));
        if (ratio < 0.2) {
            ratio = 0.2;
        }
        this.scaleX = this.scaleY = ratio;
    }
    rotateLeft() {
        const                  angle = this.rotate - 90;
        this.rotate = Math.abs(angle) < 360 ? angle : 0;
    }
    rotateRight() {
        const                  angle = this.rotate + 90;
        this.rotate = Math.abs(angle) < 360 ? angle : 0;
    }
    reset() {
        this.rotate = 0;
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.offsetX = 0;
        this.offsetY = 0;
    }
}
ImgViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-img-viewer',
                template: `<div class="image-container" [ngStyle]="{ transform: transform }">
    <img id="viewer-image" [src]="urlFile" [alt]="nameFile" [ngStyle]="{ 'cursor' : isDragged ? 'move': 'default' } " />
</div>

<div class="adf-image-viewer__toolbar" *ngIf="showToolbar">
    <adf-toolbar>
        <button
            id="viewer-zoom-in-button"
            mat-icon-button
            title="{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}"
            (click)="zoomIn()">
            <mat-icon>zoom_in</mat-icon>
        </button>

        <button
            id="viewer-zoom-out-button"
            title="{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}"
            mat-icon-button
            (click)="zoomOut()">
            <mat-icon>zoom_out</mat-icon>
        </button>

        <div class="adf-viewer__toolbar-page-scale">
            {{ currentScaleText }}
        </div>

        <button
            id="viewer-rotate-left-button"
            title="{{ 'ADF_VIEWER.ARIA.ROTATE_LEFT' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.ROTATE_LEFT' | translate }}"
            mat-icon-button
            (click)="rotateLeft()">
            <mat-icon>rotate_left</mat-icon>
        </button>

        <button
            id="viewer-rotate-right-button"
            title="{{ 'ADF_VIEWER.ARIA.ROTATE_RIGHT' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.ROTATE_RIGHT' | translate }}"
            mat-icon-button
            (click)="rotateRight()">
            <mat-icon>rotate_right</mat-icon>
        </button>

        <button
            id="viewer-reset-button"
            title="{{ 'ADF_VIEWER.ARIA.RESET' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.RESET' | translate }}"
            mat-icon-button
            (click)="reset()">
            <mat-icon>zoom_out_map</mat-icon>
        </button>
    </adf-toolbar>
</div>
`,
                styles: [``],
                host: { 'class': 'adf-image-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
ImgViewerComponent.ctorParameters = () => [
    { type: ContentService, },
    { type: ElementRef, },
];
ImgViewerComponent.propDecorators = {
    "showToolbar": [{ type: Input },],
    "urlFile": [{ type: Input },],
    "blobFile": [{ type: Input },],
    "nameFile": [{ type: Input },],
};

class MediaPlayerComponent {
    constructor(contentService) {
        this.contentService = contentService;
    }
    ngOnChanges(changes) {
        let                  blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
}
MediaPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-media-player',
                template: `<video controls>
    <source [src]="urlFile" [type]="mimeType" />
</video>
`,
                styles: [`.adf-media-player{display:-webkit-box;display:-ms-flexbox;display:flex}.adf-media-player video{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex:1;flex:1;max-height:90vh;max-width:100%}`],
                host: { 'class': 'adf-media-player' },
                encapsulation: ViewEncapsulation.None
            },] },
];
MediaPlayerComponent.ctorParameters = () => [
    { type: ContentService, },
];
MediaPlayerComponent.propDecorators = {
    "urlFile": [{ type: Input },],
    "blobFile": [{ type: Input },],
    "mimeType": [{ type: Input },],
    "nameFile": [{ type: Input },],
};

class RenderingQueueServices {
    constructor() {
        this.renderingStates = {
            INITIAL: 0,
            RUNNING: 1,
            PAUSED: 2,
            FINISHED: 3
        };
        this.CLEANUP_TIMEOUT = 30000;
        this.pdfViewer = null;
        this.pdfThumbnailViewer = null;
        this.onIdle = null;
        this.highestPriorityPage = null;
        this.idleTimeout = null;
        this.printing = false;
        this.isThumbnailViewEnabled = false;
    }
    setViewer(pdfViewer) {
        this.pdfViewer = pdfViewer;
    }
    setThumbnailViewer(pdfThumbnailViewer) {
        this.pdfThumbnailViewer = pdfThumbnailViewer;
    }
    isHighestPriority(view) {
        return this.highestPriorityPage === view.renderingId;
    }
    renderHighestPriority(currentlyVisiblePages) {
        if (this.idleTimeout) {
            clearTimeout(this.idleTimeout);
            this.idleTimeout = null;
        }
        if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
            return;
        }
        if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
            if (this.pdfThumbnailViewer.forceRendering()) {
                return;
            }
        }
        if (this.printing) {
            return;
        }
        if (this.onIdle) {
            this.idleTimeout = setTimeout(this.onIdle.bind(this), this.CLEANUP_TIMEOUT);
        }
    }
    getHighestPriority(visible, views, scrolledDown) {
        let                  visibleViews = visible.views;
        let                  numVisible = visibleViews.length;
        if (numVisible === 0) {
            return false;
        }
        for (let                  i = 0; i < numVisible; ++i) {
            let                  view = visibleViews[i].view;
            if (!this.isViewFinished(view)) {
                return view;
            }
        }
        if (scrolledDown) {
            let                  nextPageIndex = visible.last.id;
            if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
                return views[nextPageIndex];
            }
        }
        else {
            let                  previousPageIndex = visible.first.id - 2;
            if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
                return views[previousPageIndex];
            }
        }
        return null;
    }
    isViewFinished(view) {
        return view.renderingState === this.renderingStates.FINISHED;
    }
    renderView(view) {
        let                  state$$1 = view.renderingState;
        switch (state$$1) {
            case this.renderingStates.FINISHED:
                return false;
            case this.renderingStates.PAUSED:
                this.highestPriorityPage = view.renderingId;
                view.resume();
                break;
            case this.renderingStates.RUNNING:
                this.highestPriorityPage = view.renderingId;
                break;
            case this.renderingStates.INITIAL:
                this.highestPriorityPage = view.renderingId;
                let                  continueRendering = function () {
                    this.renderHighestPriority();
                }.bind(this);
                view.draw().then(continueRendering, continueRendering);
                break;
            default:
                break;
        }
        return true;
    }
}
RenderingQueueServices.decorators = [
    { type: Injectable },
];
RenderingQueueServices.ctorParameters = () => [];

class PdfPasswordDialogComponent {
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
    }
    ngOnInit() {
        this.passwordFormControl = new FormControl('', [Validators.required]);
    }
    isError() {
        return this.data.reason === PDFJS.PasswordResponses.INCORRECT_PASSWORD;
    }
    isValid() {
        return !this.passwordFormControl.hasError('required');
    }
    submit() {
        this.dialogRef.close(this.passwordFormControl.value);
    }
}
PdfPasswordDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-viewer-password-dialog',
                template: `<div mat-dialog-title>
    <mat-icon>lock</mat-icon>
</div>

<mat-dialog-content>
    <form (submit)="submit()">
        <mat-input-container class="adf-full-width">
                <input matInput
                type="password"
                placeholder="{{ 'ADF_VIEWER.PDF_DIALOG.PLACEHOLDER' | translate }}"
                [formControl]="passwordFormControl" />
        </mat-input-container>

        <mat-error *ngIf="isError()">{{ 'ADF_VIEWER.PDF_DIALOG.ERROR' | translate }}</mat-error>
    </form>
</mat-dialog-content>

<mat-dialog-actions class="adf-dialog-buttons">
    <span class="adf-fill-remaining-space"></span>

    <button mat-button mat-dialog-close>{{ 'ADF_VIEWER.PDF_DIALOG.CLOSE' | translate }}</button>

    <button mat-button
        class="adf-dialog-action-button"
        [disabled]="!isValid()"
        (click)="submit()">
        {{ 'ADF_VIEWER.PDF_DIALOG.SUBMIT' | translate }}
    </button>
</mat-dialog-actions>`,
                styles: [`.adf-fill-remaining-space{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-full-width{width:100%}`]
            },] },
];
PdfPasswordDialogComponent.ctorParameters = () => [
    { type: MatDialogRef, },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] },] },
];

class PdfViewerComponent {
    constructor(dialog, renderingQueueServices, logService) {
        this.dialog = dialog;
        this.renderingQueueServices = renderingQueueServices;
        this.logService = logService;
        this.showToolbar = true;
        this.allowThumbnails = false;
        this.thumbnailsTemplate = null;
        this.rendered = new EventEmitter();
        this.error = new EventEmitter();
        this.currentScaleMode = 'auto';
        this.currentScale = 1;
        this.MAX_AUTO_SCALE = 1.25;
        this.DEFAULT_SCALE_DELTA = 1.1;
        this.MIN_SCALE = 0.25;
        this.MAX_SCALE = 10.0;
        this.isPanelDisabled = true;
        this.showThumbnails = false;
        this.pdfThumbnailsContext = { viewer: null };
        this.onPageChange = this.onPageChange.bind(this);
        this.onPagesLoaded = this.onPagesLoaded.bind(this);
        this.onPagerendered = this.onPagerendered.bind(this);
    }
    get currentScaleText() {
        return Math.round(this.currentScale * 100) + '%';
    }
    ngOnChanges(changes) {
        let                  blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            let                  reader = new FileReader();
            reader.onload = () => {
                this.executePdf(reader.result);
            };
            reader.readAsArrayBuffer(blobFile.currentValue);
        }
        let                  urlFile = changes['urlFile'];
        if (urlFile && urlFile.currentValue) {
            this.executePdf(urlFile.currentValue);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    executePdf(src) {
        this.loadingTask = this.getPDFJS().getDocument(src);
        this.loadingTask.onPassword = (callback, reason) => {
            this.onPdfPassword(callback, reason);
        };
        this.loadingTask.onProgress = (progressData) => {
            let                  level = progressData.loaded / progressData.total;
            this.loadingPercent = Math.round(level * 100);
        };
        this.loadingTask.then((pdfDocument) => {
            this.currentPdfDocument = pdfDocument;
            this.totalPages = pdfDocument.numPages;
            this.page = 1;
            this.displayPage = 1;
            this.initPDFViewer(this.currentPdfDocument);
            this.currentPdfDocument.getPage(1).then(() => {
                this.scalePage('auto');
            }, (error) => {
                this.error.emit();
            });
        }, (error) => {
            this.error.emit();
        });
    }
    getPDFJS() {
        return PDFJS;
    }
    initPDFViewer(pdfDocument) {
        PDFJS.verbosity = 1;
        PDFJS.disableWorker = false;
        const                  viewer = document.getElementById('viewer-viewerPdf');
        this.documentContainer = document.getElementById('viewer-pdf-viewer');
        this.documentContainer.addEventListener('pagechange', this.onPageChange, true);
        this.documentContainer.addEventListener('pagesloaded', this.onPagesLoaded, true);
        this.documentContainer.addEventListener('textlayerrendered', this.onPagerendered, true);
        this.pdfViewer = new PDFJS.PDFViewer({
            container: this.documentContainer,
            viewer: viewer,
            renderingQueue: this.renderingQueueServices
        });
        this.renderingQueueServices.setViewer(this.pdfViewer);
        this.pdfViewer.setDocument(pdfDocument);
        this.pdfThumbnailsContext.viewer = this.pdfViewer;
    }
    ngOnDestroy() {
        if (this.documentContainer) {
            this.documentContainer.removeEventListener('pagechange', this.onPageChange, true);
            this.documentContainer.removeEventListener('pagesloaded', this.onPagesLoaded, true);
            this.documentContainer.removeEventListener('textlayerrendered', this.onPagerendered, true);
        }
        if (this.loadingTask) {
            this.loadingTask.destroy();
        }
    }
    toggleThumbnails() {
        this.showThumbnails = !this.showThumbnails;
    }
    scalePage(scaleMode) {
        this.currentScaleMode = scaleMode;
        if (this.pdfViewer) {
            let                  viewerContainer = document.getElementById('viewer-main-container');
            let                  documentContainer = document.getElementById('viewer-pdf-viewer');
            let                  widthContainer;
            let                  heightContainer;
            if (viewerContainer && viewerContainer.clientWidth <= documentContainer.clientWidth) {
                widthContainer = viewerContainer.clientWidth;
                heightContainer = viewerContainer.clientHeight;
            }
            else {
                widthContainer = documentContainer.clientWidth;
                heightContainer = documentContainer.clientHeight;
            }
            let                  currentPage = this.pdfViewer._pages[this.pdfViewer._currentPageNumber - 1];
            let                  padding = 20;
            let                  pageWidthScale = (widthContainer - padding) / currentPage.width * currentPage.scale;
            let                  pageHeightScale = (heightContainer - padding) / currentPage.width * currentPage.scale;
            let                  scale;
            switch (this.currentScaleMode) {
                case 'page-actual':
                    scale = 1;
                    break;
                case 'page-width':
                    scale = pageWidthScale;
                    break;
                case 'page-height':
                    scale = pageHeightScale;
                    break;
                case 'page-fit':
                    scale = Math.min(pageWidthScale, pageHeightScale);
                    break;
                case 'auto':
                    let                  horizontalScale;
                    if (this.isLandscape) {
                        horizontalScale = Math.min(pageHeightScale, pageWidthScale);
                    }
                    else {
                        horizontalScale = pageWidthScale;
                    }
                    scale = Math.min(this.MAX_AUTO_SCALE, horizontalScale);
                    break;
                default:
                    this.logService.error('pdfViewSetScale: \'' + scaleMode + '\' is an unknown zoom value.');
                    return;
            }
            this.setScaleUpdatePages(scale);
        }
    }
    setScaleUpdatePages(newScale) {
        if (!this.isSameScale(this.currentScale, newScale)) {
            this.currentScale = newScale;
            this.pdfViewer._pages.forEach(function (currentPage) {
                currentPage.update(newScale);
            });
            this.pdfViewer.update();
        }
    }
    isSameScale(oldScale, newScale) {
        return (newScale === oldScale);
    }
    isLandscape(width, height) {
        return (width > height);
    }
    onResize() {
        this.scalePage(this.currentScaleMode);
    }
    pageFit() {
        if (this.currentScaleMode !== 'page-fit') {
            this.scalePage('page-fit');
        }
        else {
            this.scalePage('auto');
        }
    }
    zoomIn(ticks) {
        let                  newScale = this.currentScale;
        do {
            newScale = (newScale * this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.ceil(newScale * 10) / 10;
            newScale = Math.min(this.MAX_SCALE, newScale);
        } while (--ticks > 0 && newScale < this.MAX_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    zoomOut(ticks) {
        let                  newScale = this.currentScale;
        do {
            newScale = (newScale / this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.floor(newScale * 10) / 10;
            newScale = Math.max(this.MIN_SCALE, newScale);
        } while (--ticks > 0 && newScale > this.MIN_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    previousPage() {
        if (this.pdfViewer && this.page > 1) {
            this.page--;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    nextPage() {
        if (this.pdfViewer && this.page < this.totalPages) {
            this.page++;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    inputPage(page) {
        let                  pageInput = parseInt(page, 10);
        if (!isNaN(pageInput) && pageInput > 0 && pageInput <= this.totalPages) {
            this.page = pageInput;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
        else {
            this.displayPage = this.page;
        }
    }
    onPageChange(event) {
        this.page = event.pageNumber;
        this.displayPage = event.pageNumber;
    }
    onPdfPassword(callback, reason) {
        this.dialog
            .open(PdfPasswordDialogComponent, {
            width: '400px',
            disableClose: true,
            data: { reason }
        })
            .afterClosed().subscribe(password => {
            if (password) {
                callback(password);
            }
        });
    }
    onPagerendered() {
        this.rendered.emit();
    }
    onPagesLoaded(event) {
        this.isPanelDisabled = false;
    }
    handleKeyboardEvent(event) {
        let                  key = event.keyCode;
        if (key === 39) {
            this.nextPage();
        }
        else if (key === 37) {
            this.previousPage();
        }
    }
}
PdfViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-viewer',
                template: `<div class="adf-pdf-viewer__container">
    <ng-container *ngIf="showThumbnails">
        <div class="adf-pdf-viewer__thumbnails">
            <div class="thumbnails-template__container">
                <div class="thumbnails-template__buttons">
                    <button mat-icon-button (click)="toggleThumbnails()">
                            <mat-icon>close</mat-icon>
                    </button>
                </div>

                <ng-container *ngIf="thumbnailsTemplate">
                    <ng-container *ngTemplateOutlet="thumbnailsTemplate;context:pdfThumbnailsContext"></ng-container>
                </ng-container>

                <ng-container *ngIf="!thumbnailsTemplate">
                    <adf-pdf-thumbnails [pdfViewer]="pdfViewer"></adf-pdf-thumbnails>
                </ng-container>
            </div>
        </div>
    </ng-container>

    <div class="adf-pdf-viewer__content">
        <div id="viewer-pdf-viewer" class="viewer-pdf-viewer" (window:resize)="onResize()">
            <div id="viewer-viewerPdf" class="pdfViewer">
                <div id="loader-container" class="loader-container">
                    <div class="loader-item">
                        <mat-progress-bar mode="indeterminate"></mat-progress-bar>
                    </div >
                </div>
            </div>
        </div>
    </div>
</div>

<div class="adf-pdf-viewer__toolbar" *ngIf="showToolbar">
    <adf-toolbar>

        <ng-container *ngIf="allowThumbnails">
            <button mat-icon-button
                [disabled]="isPanelDisabled"
                (click)="toggleThumbnails()">
                <mat-icon>dashboard</mat-icon>
            </button>
            <adf-toolbar-divider></adf-toolbar-divider>
        </ng-container>

        <button
            id="viewer-previous-page-button"
            title="{{ 'ADF_VIEWER.ARIA.PREVIOUS_PAGE' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.PREVIOUS_PAGE' | translate }}"
            mat-icon-button
            (click)="previousPage()">
            <mat-icon>keyboard_arrow_up</mat-icon>
        </button>

        <button
            id="viewer-next-page-button"
            title="{{ 'ADF_VIEWER.ARIA.NEXT_PAGE' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.NEXT_PAGE' | translate }}"
            mat-icon-button
            (click)="nextPage()">
            <mat-icon>keyboard_arrow_down</mat-icon>
        </button>

        <div class="adf-pdf-viewer__toolbar-page-selector">
            <span>{{ 'ADF_VIEWER.PAGE_LABEL.SHOWING' | translate }}</span>
            <input #page
                type="text"
                pattern="-?[0-9]*(\.[0-9]+)?"
                value="{{ displayPage }}"
                (keyup.enter)="inputPage(page.value)">
            <span>{{ 'ADF_VIEWER.PAGE_LABEL.OF' | translate }} {{ totalPages }}</span>
        </div>

        <div class="adf-viewer__toolbar-page-scale">
            {{ currentScaleText }}
        </div>

        <button
            id="viewer-zoom-in-button"
            title="{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}"
            mat-icon-button
            (click)="zoomIn()">
            <mat-icon>zoom_in</mat-icon>
        </button>

        <button
            id="viewer-zoom-out-button"
            title="{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}"
            mat-icon-button
            (click)="zoomOut()">
            <mat-icon>zoom_out</mat-icon>
        </button>

        <button
            id="viewer-scale-page-button"
            title="{{ 'ADF_VIEWER.ARIA.FIT_PAGE' | translate }}"
            attr.aria-label="{{ 'ADF_VIEWER.ARIA.FIT_PAGE' | translate }}"
            mat-icon-button
            (click)="pageFit()">
            <mat-icon>zoom_out_map</mat-icon>
        </button>

    </adf-toolbar>
</div>
`,
                styles: [``, `.adf-pdf-viewer .textLayer{position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:.2;line-height:1;border:1px solid gray}.adf-pdf-viewer .textLayer>div{color:transparent;position:absolute;white-space:pre;cursor:text;-webkit-transform-origin:0 0;transform-origin:0 0}.adf-pdf-viewer .textLayer .highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}.adf-pdf-viewer .textLayer .highlight.begin{border-radius:4px 0 0 4px}.adf-pdf-viewer .textLayer .highlight.end{border-radius:0 4px 4px 0}.adf-pdf-viewer .textLayer .highlight.middle{border-radius:0}.adf-pdf-viewer .textLayer .highlight.selected{background-color:#006400}.adf-pdf-viewer .textLayer::selection{background:#00f}.adf-pdf-viewer .textLayer::-moz-selection{background:#00f}.adf-pdf-viewer .textLayer .endOfContent{display:block;position:absolute;left:0;top:100%;right:0;bottom:0;z-index:-1;cursor:default;user-select:none;-webkit-user-select:none;-ms-user-select:none;-moz-user-select:none}.adf-pdf-viewer .textLayer .endOfContent.active{top:0}.adf-pdf-viewer .annotationLayer section{position:absolute}.adf-pdf-viewer .annotationLayer .linkAnnotation>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)}.adf-pdf-viewer .annotationLayer .linkAnnotation>a:hover{opacity:.2;background:#ff0;-webkit-box-shadow:0 2px 10px #ff0;box-shadow:0 2px 10px #ff0}.adf-pdf-viewer .annotationLayer .textAnnotation img{position:absolute;cursor:pointer}.adf-pdf-viewer .annotationLayer .popupWrapper{position:absolute;width:20em}.adf-pdf-viewer .annotationLayer .popup{position:absolute;z-index:200;max-width:20em;background-color:#ff9;-webkit-box-shadow:0 2px 5px #333;box-shadow:0 2px 5px #333;border-radius:2px;padding:.6em;margin-left:5px;cursor:pointer;word-wrap:break-word}.adf-pdf-viewer .annotationLayer .popup h1{font-size:1em;border-bottom:1px solid #000;padding-bottom:.2em}.adf-pdf-viewer .annotationLayer .popup p{padding-top:.2em}.adf-pdf-viewer .annotationLayer .fileAttachmentAnnotation,.adf-pdf-viewer .annotationLayer .highlightAnnotation,.adf-pdf-viewer .annotationLayer .squigglyAnnotation,.adf-pdf-viewer .annotationLayer .strikeoutAnnotation,.adf-pdf-viewer .annotationLayer .underlineAnnotation{cursor:pointer}.adf-pdf-viewer .pdfViewer canvasWrapper{overflow:hidden}.adf-pdf-viewer .pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:1px auto -8px;position:relative;overflow:visible;border:9px solid transparent;background-clip:content-box;background-color:#fff}.adf-pdf-viewer .pdfViewer .page canvas{margin:0;display:block}.adf-pdf-viewer .pdfViewer .page .loadingIcon{position:absolute;display:block;left:0;top:0;right:0;bottom:0}.adf-pdf-viewer .pdfViewer .page *{padding:0;margin:0}.adf-pdf-viewer .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.adf-pdf-viewer .pdfViewer .loadingIcon{width:100px;height:100px;left:50%!important;top:50%!important;margin-top:-50px;margin-left:-50px;font-size:5px;text-indent:-9999em;border-top:1.1em solid rgba(3,0,2,.2);border-right:1.1em solid rgba(3,0,2,.2);border-bottom:1.1em solid rgba(3,0,2,.2);border-left:1.1em solid #030002;-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-animation:1.1s linear infinite load8;animation:1.1s linear infinite load8;border-radius:50%}.adf-pdf-viewer .pdfViewer .loadingIcon:after{border-radius:50%}.adf-pdf-viewer .hidden,.adf-pdf-viewer [hidden]{display:none!important}@-webkit-keyframes load8{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes load8{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.viewer-pdf-viewer{overflow:auto;-webkit-overflow-scrolling:touch;position:absolute;top:0;right:0;bottom:0;left:0;outline:0}html[dir=ltr] .viewer-pdf-viewer{-webkit-box-shadow:inset 1px 0 0 rgba(255,255,255,.05);box-shadow:inset 1px 0 0 rgba(255,255,255,.05)}html[dir=rtl] .viewer-pdf-viewer{-webkit-box-shadow:inset -1px 0 0 rgba(255,255,255,.05);box-shadow:inset -1px 0 0 rgba(255,255,255,.05)}`],
                providers: [RenderingQueueServices],
                host: { 'class': 'adf-pdf-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
PdfViewerComponent.ctorParameters = () => [
    { type: MatDialog, },
    { type: RenderingQueueServices, },
    { type: LogService, },
];
PdfViewerComponent.propDecorators = {
    "urlFile": [{ type: Input },],
    "blobFile": [{ type: Input },],
    "nameFile": [{ type: Input },],
    "showToolbar": [{ type: Input },],
    "allowThumbnails": [{ type: Input },],
    "thumbnailsTemplate": [{ type: Input },],
    "rendered": [{ type: Output },],
    "error": [{ type: Output },],
    "handleKeyboardEvent": [{ type: HostListener, args: ['document:keydown', ['$event'],] },],
};

class PdfThumbListComponent {
    constructor(element) {
        this.element = element;
        this.virtualHeight = 0;
        this.translateY = 0;
        this.renderItems = [];
        this.items = [];
        this.margin = 15;
        this.itemHeight = 114 + this.margin;
        this.calculateItems = this.calculateItems.bind(this);
        this.onPageChange = this.onPageChange.bind(this);
    }
    onResize(event) {
        this.calculateItems();
    }
    ngOnInit() {
        this.element.nativeElement.addEventListener('scroll', this.calculateItems, true);
        this.pdfViewer.eventBus.on('pagechange', this.onPageChange);
        this.items = this.getPages();
        this.calculateItems();
    }
    ngAfterViewInit() {
        setTimeout(() => this.scrollInto(this.pdfViewer.currentPageNumber), 0);
    }
    ngOnDestroy() {
        this.element.nativeElement.removeEventListener('scroll', this.calculateItems, true);
        this.pdfViewer.eventBus.off('pagechange', this.onPageChange);
    }
    trackByFn(index, item) {
        return item.id;
    }
    isSelected(pageNum) {
        return this.pdfViewer.currentPageNumber === pageNum;
    }
    goTo(pageNum) {
        this.pdfViewer.currentPageNumber = pageNum;
    }
    scrollInto(item) {
        if (this.items.length) {
            const                  index = this.items.findIndex((element) => element.id === item);
            if (index < 0 || index >= this.items.length) {
                return;
            }
            this.element.nativeElement.scrollTop = index * this.itemHeight;
            this.calculateItems();
        }
    }
    getPages() {
        return this.pdfViewer._pages.map((page) => ({
            id: page.id,
            getPage: () => this.pdfViewer.pdfDocument.getPage(page.id)
        }));
    }
    calculateItems() {
        const { element, viewPort, itemsInView } = this.getContainerSetup();
        const                  indexByScrollTop = element.scrollTop / viewPort * this.items.length / itemsInView;
        const                  start = Math.floor(indexByScrollTop);
        const                  end = Math.ceil(indexByScrollTop) + (itemsInView);
        this.translateY = this.itemHeight * Math.ceil(start);
        this.virtualHeight = this.itemHeight * this.items.length - this.translateY;
        this.renderItems = this.items.slice(start, end);
    }
    getContainerSetup() {
        const                  element = this.element.nativeElement;
        const                  elementRec = element.getBoundingClientRect();
        const                  itemsInView = Math.ceil(elementRec.height / this.itemHeight);
        const                  viewPort = (this.itemHeight * this.items.length) / itemsInView;
        return {
            element,
            viewPort,
            itemsInView
        };
    }
    onPageChange(event) {
        const                  index = this.renderItems.findIndex((element) => element.id === event.pageNumber);
        if (index < 0) {
            this.scrollInto(event.pageNumber);
        }
        if (index >= this.renderItems.length - 1) {
            this.element.nativeElement.scrollTop += this.itemHeight;
        }
    }
}
PdfThumbListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-thumbnails',
                template: `<div class="pdf-thumbnails__content"
    [style.height.px]="virtualHeight"
    [style.transform]="'translate(-50%, ' + translateY + 'px)'">
    <adf-pdf-thumb *ngFor="let page of renderItems; trackBy: trackByFn"
        class="pdf-thumbnails__thumb"
        [ngClass]="{'pdf-thumbnails__thumb--selected' : isSelected(page.id)}"
        [page]="page"
        (click)="goTo(page.id)">
    </adf-pdf-thumb>
</div>
`,
                styles: [``],
                host: { 'class': 'pdf-thumbnails' },
                encapsulation: ViewEncapsulation.None
            },] },
];
PdfThumbListComponent.ctorParameters = () => [
    { type: ElementRef, },
];
PdfThumbListComponent.propDecorators = {
    "pdfViewer": [{ type: Input },],
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
    "onResize": [{ type: HostListener, args: ['window:resize', ['$event'],] },],
};

class PdfThumbComponent {
    constructor(element, sanitizer) {
        this.element = element;
        this.sanitizer = sanitizer;
        this.page = null;
    }
    ngOnInit() {
        this.image$ = this.page.getPage().then((page) => this.getThumb(page));
    }
    getThumb(page) {
        const                  canvas = this.getCanvas();
        const                  viewport = page.getViewport(1);
        const                  scale = Math.min((canvas.height / viewport.height), (canvas.width / viewport.width));
        return page.render({
            canvasContext: canvas.getContext('2d'),
            viewport: page.getViewport(scale)
        })
            .then(() => {
            const                  imageSource = canvas.toDataURL();
            return this.sanitizer.bypassSecurityTrustUrl(imageSource);
        });
    }
    getCanvas() {
        const                  elementRect = this.element.nativeElement.getBoundingClientRect();
        const                  canvas = document.createElement('canvas');
        canvas.width = elementRect.width;
        canvas.height = elementRect.height;
        return canvas;
    }
}
PdfThumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-thumb',
                template: `<ng-container *ngIf="image$ | async as image">
    <img [src]="image"
        title="{{ 'ADF_VIEWER.SIDEBAR.THUMBNAILS.PAGE' | translate: { pageNum: page.id } }}">
</ng-container>`,
                encapsulation: ViewEncapsulation.None
            },] },
];
PdfThumbComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DomSanitizer, },
];
PdfThumbComponent.propDecorators = {
    "page": [{ type: Input, args: ['page',] },],
};

class TxtViewerComponent {
    constructor(http) {
        this.http = http;
    }
    ngOnChanges(changes) {
        let                  blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            return this.readBlob(blobFile.currentValue);
        }
        let                  urlFile = changes['urlFile'];
        if (urlFile && urlFile.currentValue) {
            return this.getUrlContent(urlFile.currentValue);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    getUrlContent(url) {
        return new Promise((resolve, reject) => {
            this.http.get(url, { responseType: 'text' }).subscribe(res => {
                this.content = res;
                resolve();
            }, (event) => {
                reject(event);
            });
        });
    }
    readBlob(blob) {
        return new Promise((resolve, reject) => {
            let                  reader = new FileReader();
            reader.onload = () => {
                this.content = reader.result;
                resolve();
            };
            reader.onerror = (error) => {
                reject(error);
            };
            reader.readAsText(blob);
        });
    }
}
TxtViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-txt-viewer',
                template: `<pre class="adf-txt-viewer-content">
    {{content}}
</pre>
`,
                styles: [``],
                host: { 'class': 'adf-txt-viewer' },
                encapsulation: ViewEncapsulation.None
            },] },
];
TxtViewerComponent.ctorParameters = () => [
    { type: HttpClient, },
];
TxtViewerComponent.propDecorators = {
    "urlFile": [{ type: Input },],
    "blobFile": [{ type: Input },],
};

class UnknownFormatComponent {
}
UnknownFormatComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-unknown-format',
                template: `<div class="adf-viewer__unknown-format-view">
    <div>
        <mat-icon class="icon">wifi_tethering</mat-icon>
        <div class="label">{{ 'ADF_VIEWER.UNKNOWN_FORMAT' | translate }}</div>
    </div>
</div>
`,
                styles: [`.adf-viewer__unknown-format-view{height:90vh;text-align:center;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex:1;flex:1;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}`]
            },] },
];
UnknownFormatComponent.ctorParameters = () => [];

class ViewerToolbarActionsComponent {
}
ViewerToolbarActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-toolbar-actions',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-toolbar-actions' },
                template: `<ng-content></ng-content>`
            },] },
];
ViewerToolbarActionsComponent.ctorParameters = () => [];

class ViewerExtensionDirective {
    constructor(viewerComponent) {
        this.viewerComponent = viewerComponent;
    }
    ngAfterContentInit() {
        this.templateModel = { template: this.template, isVisible: false };
        this.viewerComponent.extensionTemplates.push(this.templateModel);
        this.viewerComponent.extensionChange.subscribe((fileExtension) => {
            this.templateModel.isVisible = this.isVisible(fileExtension);
        });
        if (this.supportedExtensions instanceof Array) {
            this.supportedExtensions.forEach((extension) => {
                this.viewerComponent.externalExtensions.push(extension);
            });
        }
    }
    isVisible(fileExtension) {
        let                  supportedExtension;
        if (this.supportedExtensions && (this.supportedExtensions instanceof Array)) {
            supportedExtension = this.supportedExtensions.find((extension) => {
                return extension.toLowerCase() === fileExtension;
            });
        }
        return !!supportedExtension;
    }
}
ViewerExtensionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-viewer-extension'
            },] },
];
ViewerExtensionDirective.ctorParameters = () => [
    { type: ViewerComponent, },
];
ViewerExtensionDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
    "urlFileContent": [{ type: Input },],
    "extension": [{ type: Input },],
    "supportedExtensions": [{ type: Input },],
};

function modules() {
    return [
        MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule,
        MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule,
        MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule,
        MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule,
        MatMenuModule, MatProgressBarModule, MatSidenavModule, MatSnackBarModule, MatToolbarModule,
        MatTooltipModule, MatDatetimepickerModule, MatNativeDatetimeModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] },
];
MaterialModule.ctorParameters = () => [];

class ToolbarDividerComponent {
}
ToolbarDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-divider',
                template: '<div></div>',
                host: { 'class': 'adf-toolbar-divider' },
                styles: [`
        .adf-toolbar-divider > div {
            height: 24px;
            width: 1px;
            background: rgba(0, 0, 0, 0.26);
            margin-left: 5px;
            margin-right: 5px;
        }
    `],
                encapsulation: ViewEncapsulation.None
            },] },
];
ToolbarDividerComponent.ctorParameters = () => [];

class ToolbarTitleComponent {
}
ToolbarTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-title',
                template: '<ng-content></ng-content>',
                host: { 'class': 'adf-toolbar-title' }
            },] },
];
ToolbarTitleComponent.ctorParameters = () => [];

class ToolbarComponent {
    constructor() {
        this.title = '';
    }
}
ToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar',
                template: `<mat-toolbar [color]="color">
    <span *ngIf="title">{{ title }}</span>
    <ng-content select="adf-toolbar-title"></ng-content>
    <span class="adf-toolbar--spacer"></span>
    <ng-content></ng-content>
</mat-toolbar>
`,
                styles: [``],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-toolbar' }
            },] },
];
ToolbarComponent.ctorParameters = () => [];
ToolbarComponent.propDecorators = {
    "title": [{ type: Input },],
    "color": [{ type: Input },],
};

class ToolbarModule {
}
ToolbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ],
                exports: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ]
            },] },
];
ToolbarModule.ctorParameters = () => [];

const TRANSLATION_PROVIDER = new InjectionToken('Injection token for translation providers.');

class TranslationService {
    constructor(translate, userPreference, providers) {
        this.translate = translate;
        this.customLoader =                  (this.translate.currentLoader);
        this.defaultLang = 'en';
        translate.setDefaultLang(this.defaultLang);
        if (providers && providers.length > 0) {
            for (let                  provider of providers) {
                this.addTranslationFolder(provider.name, provider.source);
            }
        }
        userPreference.locale$.subscribe((locale) => {
            this.userLang = locale;
            this.use(this.userLang);
        });
    }
    addTranslationFolder(name = '', path = '') {
        if (!this.customLoader.providerRegistered(name)) {
            this.customLoader.registerProvider(name, path);
            if (this.userLang !== this.defaultLang) {
                this.translate.getTranslation(this.defaultLang).subscribe(() => {
                    this.translate.getTranslation(this.userLang).subscribe(() => {
                        this.translate.use(this.userLang);
                        this.onTranslationChanged(this.userLang);
                    });
                });
            }
            else {
                this.translate.getTranslation(this.userLang).subscribe(() => {
                    this.translate.use(this.userLang);
                    this.onTranslationChanged(this.userLang);
                });
            }
        }
    }
    onTranslationChanged(lang) {
        this.translate.onTranslationChange.next({
            lang: lang,
            translations: this.customLoader.getFullTranslationJSON(lang)
        });
    }
    use(lang) {
        this.customLoader.init(lang);
        return this.translate.use(lang);
    }
    get(key, interpolateParams) {
        return this.translate.get(key, interpolateParams);
    }
    instant(key, interpolateParams) {
        return this.translate.instant(key, interpolateParams);
    }
}
TranslationService.decorators = [
    { type: Injectable },
];
TranslationService.ctorParameters = () => [
    { type: TranslateService, },
    { type: UserPreferencesService, },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATION_PROVIDER,] },] },
];

class FileSizePipe {
    constructor(translation) {
        this.translation = translation;
    }
    transform(bytes, decimals = 2) {
        if (bytes == null || bytes === undefined) {
            return '';
        }
        if (bytes === 0) {
            return '0 ' + this.translation.instant('CORE.FILE_SIZE.BYTES');
        }
        const                  k = 1024,
        dm = decimals || 2,
        sizes = ['BYTES', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
        i = Math.floor(Math.log(bytes) / Math.log(k));
        const                  i18nSize = this.translation.instant(`CORE.FILE_SIZE.${sizes[i]}`);
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + i18nSize;
    }
}
FileSizePipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfFileSize',
                pure: false
            },] },
];
FileSizePipe.ctorParameters = () => [
    { type: TranslationService, },
];

class ThumbnailService {
    constructor(contentService, matIconRegistry, sanitizer) {
        this.contentService = contentService;
        this.DEFAULT_ICON = './assets/images/ft_ic_miscellaneous.svg';
        this.mimeTypeIcons = {
            'image/png': './assets/images/ft_ic_raster_image.svg',
            'image/jpeg': './assets/images/ft_ic_raster_image.svg',
            'image/gif': './assets/images/ft_ic_raster_image.svg',
            'image/bmp': './assets/images/ft_ic_raster_image.svg',
            'image/cgm': './assets/images/ft_ic_raster_image.svg',
            'image/ief': './assets/images/ft_ic_raster_image.svg',
            'image/jp2': './assets/images/ft_ic_raster_image.svg',
            'image/tiff': './assets/images/ft_ic_raster_image.svg',
            'image/vnd.adobe.photoshop': './assets/images/ft_ic_raster_image.svg',
            'image/vnd.adobe.premiere': './assets/images/ft_ic_raster_image.svg',
            'image/x-cmu-raster': './assets/images/ft_ic_raster_image.svg',
            'image/x-dwt': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-anymap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-bitmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-graymap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-pixmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-adobe': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-canon': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-fuji': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-hasselblad': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-kodak': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-leica': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-minolta': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-nikon': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-olympus': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-panasonic': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-pentax': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-red': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-sigma': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-sony': './assets/images/ft_ic_raster_image.svg',
            'image/x-xbitmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-xpixmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-xwindowdump': './assets/images/ft_ic_raster_image.svg',
            'image/svg+xml': './assets/images/ft_ic_vector_image.svg',
            'application/eps': './assets/images/ft_ic_raster_image.svg',
            'application/illustrator': './assets/images/ft_ic_raster_image.svg',
            'application/pdf': './assets/images/ft_ic_pdf.svg',
            'application/vnd.ms-excel': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.addin.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.sheet.binary.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.sheet.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.template.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.sun.xml.calc': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.sun.xml.calc.template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-outlook': './assets/images/ft_ic_document.svg',
            'application/msword': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.template': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-word.document.macroenabled.12': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-word.template.macroenabled.12': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.sun.xml.writer': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.sun.xml.writer.template': './assets/images/ft_ic_ms_word.svg',
            'application/rtf': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-powerpoint': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.slideshow': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.presentation': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.presentation-template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.slide': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.sun.xml.impress': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.sun.xml.impress.template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.spreadsheet': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.oasis.opendocument.spreadsheet-template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-powerpoint.addin.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.presentation.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.slide.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.slideshow.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.template.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'video/mp4': './assets/images/ft_ic_video.svg',
            'video/3gpp': './assets/images/ft_ic_video.svg',
            'video/3gpp2': './assets/images/ft_ic_video.svg',
            'video/mp2t': './assets/images/ft_ic_video.svg',
            'video/mpeg': './assets/images/ft_ic_video.svg',
            'video/mpeg2': './assets/images/ft_ic_video.svg',
            'video/ogg': './assets/images/ft_ic_video.svg',
            'video/quicktime': './assets/images/ft_ic_video.svg',
            'video/webm': './assets/images/ft_ic_video.svg',
            'video/x-flv': './assets/images/ft_ic_video.svg',
            'video/x-m4v': './assets/images/ft_ic_video.svg',
            'video/x-ms-asf': './assets/images/ft_ic_video.svg',
            'video/x-ms-wmv': './assets/images/ft_ic_video.svg',
            'video/x-msvideo': './assets/images/ft_ic_video.svg',
            'video/x-rad-screenplay': './assets/images/ft_ic_video.svg',
            'video/x-sgi-movie': './assets/images/ft_ic_video.svg',
            'video/x-matroska': './assets/images/ft_ic_video.svg',
            'audio/mpeg': './assets/images/ft_ic_audio.svg',
            'audio/ogg': './assets/images/ft_ic_audio.svg',
            'audio/wav': './assets/images/ft_ic_audio.svg',
            'audio/basic': './assets/images/ft_ic_audio.svg',
            'audio/mp4': './assets/images/ft_ic_audio.svg',
            'audio/vnd.adobe.soundbooth': './assets/images/ft_ic_audio.svg',
            'audio/vorbis': './assets/images/ft_ic_audio.svg',
            'audio/x-aiff': './assets/images/ft_ic_audio.svg',
            'audio/x-flac': './assets/images/ft_ic_audio.svg',
            'audio/x-ms-wma': './assets/images/ft_ic_audio.svg',
            'audio/x-wav': './assets/images/ft_ic_audio.svg',
            'x-world/x-vrml': './assets/images/ft_ic_video.svg',
            'text/plain': './assets/images/ft_ic_document.svg',
            'application/vnd.oasis.opendocument.text': './assets/images/ft_ic_document.svg',
            'application/vnd.oasis.opendocument.text-template': './assets/images/ft_ic_document.svg',
            'application/x-javascript': './assets/images/ft_ic_document.svg',
            'application/json': './assets/images/ft_ic_document.svg',
            'text/csv': './assets/images/ft_ic_document.svg',
            'text/xml': './assets/images/ft_ic_document.svg',
            'text/html': './assets/images/ft_ic_website.svg',
            'application/x-compressed': './assets/images/ft_ic_archive.svg',
            'application/x-zip-compressed': './assets/images/ft_ic_archive.svg',
            'application/zip': './assets/images/ft_ic_archive.svg',
            'application/x-tar': './assets/images/ft_ic_archive.svg',
            'application/vnd.apple.keynote': './assets/images/ft_ic_presentation.svg',
            'application/vnd.apple.pages': './assets/images/ft_ic_document.svg',
            'application/vnd.apple.numbers': './assets/images/ft_ic_spreadsheet.svg',
            'application/vnd.visio': './assets/images/ft_ic_document.svg',
            'application/wordperfect': './assets/images/ft_ic_document.svg',
            'application/x-cpio': './assets/images/ft_ic_document.svg',
            'folder': './assets/images/ft_ic_folder.svg',
            'disable/folder': './assets/images/ft_ic_folder_disable.svg',
            'selected': './assets/images/ft_ic_selected.svg'
        };
        Object.keys(this.mimeTypeIcons).forEach(key => {
            matIconRegistry.addSvgIcon(key, sanitizer.bypassSecurityTrustResourceUrl(this.mimeTypeIcons[key]));
        });
    }
    getDocumentThumbnailUrl(node) {
        let                  thumbnail = this.contentService.getDocumentThumbnailUrl(node);
        return thumbnail || this.DEFAULT_ICON;
    }
    getMimeTypeIcon(mimeType) {
        let                  icon = this.mimeTypeIcons[mimeType];
        return (icon || this.DEFAULT_ICON);
    }
    getDefaultMimeTypeIcon() {
        return this.DEFAULT_ICON;
    }
}
ThumbnailService.decorators = [
    { type: Injectable },
];
ThumbnailService.ctorParameters = () => [
    { type: ContentService, },
    { type: MatIconRegistry, },
    { type: DomSanitizer, },
];

class MimeTypeIconPipe {
    constructor(thumbnailService) {
        this.thumbnailService = thumbnailService;
    }
    transform(text) {
        return this.thumbnailService.getMimeTypeIcon(text);
    }
}
MimeTypeIconPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfMimeTypeIcon'
            },] },
];
MimeTypeIconPipe.ctorParameters = () => [
    { type: ThumbnailService, },
];

class NodeNameTooltipPipe {
    transform(node) {
        if (node) {
            return this.getNodeTooltip(node);
        }
        return null;
    }
    containsLine(lines, line) {
        return lines.some((item) => {
            return item.toLowerCase() === line.toLowerCase();
        });
    }
    removeDuplicateLines(lines) {
        const                  reducer = (acc, line) => {
            if (!this.containsLine(acc, line)) {
                acc.push(line);
            }
            return acc;
        };
        return lines.reduce(reducer, []);
    }
    getNodeTooltip(node) {
        if (!node || !node.entry) {
            return null;
        }
        const { entry: { properties, name } } = node;
        const                  lines = [name];
        if (properties) {
            const { 'cm:title': title, 'cm:description': description } = properties;
            if (title && description) {
                lines[0] = title;
                lines[1] = description;
            }
            if (title) {
                lines[1] = title;
            }
            if (description) {
                lines[1] = description;
            }
        }
        return this.removeDuplicateLines(lines).join(`\n`);
    }
}
NodeNameTooltipPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfNodeNameTooltip'
            },] },
];
NodeNameTooltipPipe.ctorParameters = () => [];

class HighlightTransformService {
    highlight(text, search, wrapperClass = 'highlight') {
        let                  isMatching = false,
        result = text;
        if (search && text) {
            let                  pattern = search.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            pattern = pattern.split(' ').filter((t) => {
                return t.length > 0;
            }).join('|');
            const                  regex = new RegExp(pattern, 'gi');
            result = text.replace(regex, (match) => {
                isMatching = true;
                return `<span class="${wrapperClass}">${match}</span>`;
            });
            return { text: result, changed: isMatching };
        }
        else {
            return { text: result, changed: isMatching };
        }
    }
}

class HighlightPipe {
    constructor(highlightTransformService) {
        this.highlightTransformService = highlightTransformService;
    }
    transform(text, search) {
        const                  result = this.highlightTransformService.highlight(text, search);
        return result.text;
    }
}
HighlightPipe.decorators = [
    { type: Pipe, args: [{
                name: 'highlight'
            },] },
];
HighlightPipe.ctorParameters = () => [
    { type: HighlightTransformService, },
];

class TimeAgoPipe {
    transform(value) {
        if (value !== null && value !== undefined) {
            const                  then = moment(value);
            const                  diff = moment().diff(then, 'days');
            return diff > 7 ? then.format('DD/MM/YYYY HH:mm') : then.fromNow();
        }
        return '';
    }
}
TimeAgoPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfTimeAgo'
            },] },
];
TimeAgoPipe.ctorParameters = () => [];

class InitialUsernamePipe {
    constructor(sanitized) {
        this.sanitized = sanitized;
    }
    transform(user, className = '', delimiter = '') {
        let                  result = '';
        if (user) {
            let                  initialResult = this.getInitialUserName(user.firstName, user.lastName, delimiter);
            result = this.sanitized.bypassSecurityTrustHtml(`<div id="user-initials-image" class="${className}">${initialResult}</div>`);
        }
        return result;
    }
    getInitialUserName(firstName, lastName, delimiter) {
        firstName = (firstName ? firstName[0] : '');
        lastName = (lastName ? lastName[0] : '');
        return firstName + delimiter + lastName;
    }
}
InitialUsernamePipe.decorators = [
    { type: Pipe, args: [{
                name: 'usernameInitials'
            },] },
];
InitialUsernamePipe.ctorParameters = () => [
    { type: DomSanitizer, },
];

class PipeModule {
}
PipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe
                ],
                providers: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe
                ],
                exports: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe
                ]
            },] },
];
PipeModule.ctorParameters = () => [];

class ViewerModule {
}
ViewerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule,
                    ToolbarModule,
                    PipeModule,
                    FlexLayoutModule
                ],
                declarations: [
                    PdfPasswordDialogComponent,
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    PdfThumbComponent,
                    PdfThumbListComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent,
                    ViewerToolbarActionsComponent
                ],
                entryComponents: [
                    PdfPasswordDialogComponent
                ],
                exports: [
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    PdfPasswordDialogComponent,
                    PdfThumbComponent,
                    PdfThumbListComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent,
                    ViewerToolbarActionsComponent
                ]
            },] },
];
ViewerModule.ctorParameters = () => [];

class BpmUserModel {
    constructor(obj) {
        if (obj) {
            this.apps = obj.apps;
            this.capabilities = obj.capabilities;
            this.company = obj.company;
            this.created = obj.created;
            this.email = obj.email;
            this.externalId = obj.externalId;
            this.firstName = obj.firstName;
            this.lastName = obj.lastName;
            this.fullname = obj.fullname;
            this.fullNameDisplay = obj ? this.formatValue(obj.firstName).trim() + ' ' + this.formatValue(obj.lastName).trim() : null;
            this.groups = obj.groups;
            this.id = obj.id;
            this.lastUpdate = obj.lastUpdate;
            this.latestSyncTimeStamp = obj.latestSyncTimeStamp;
            this.password = obj.password;
            this.pictureId = obj.pictureId;
            this.status = obj.status;
            this.tenantId = obj.tenantId;
            this.tenantName = obj.tenantName;
            this.tenantPictureId = obj.tenantPictureId;
            this.type = obj.type;
        }
    }
    formatValue(value) {
        return value && value !== 'null' ? value : '';
    }
}

class EcmUserModel {
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.firstName = obj && obj.firstName;
        this.lastName = obj && obj.lastName;
        this.fullNameDisplay = obj ? this.formatValue(obj.firstName).trim() + ' ' + this.formatValue(obj.lastName).trim() : null;
        this.description = obj && obj.description || null;
        this.avatarId = obj && obj.avatarId || null;
        this.email = obj && obj.email || null;
        this.skypeId = obj && obj.skypeId;
        this.googleId = obj && obj.googleId;
        this.instantMessageId = obj && obj.instantMessageId;
        this.jobTitle = obj && obj.jobTitle || null;
        this.location = obj && obj.location || null;
        this.company = obj && obj.company;
        this.mobile = obj && obj.mobile;
        this.telephone = obj && obj.telephone;
        this.statusUpdatedAt = obj && obj.statusUpdatedAt;
        this.userStatus = obj && obj.userStatus;
        this.enabled = obj && obj.enabled;
        this.emailNotificationsEnabled = obj && obj.emailNotificationsEnabled;
    }
    formatValue(value) {
        return value && value !== 'null' ? value : '';
    }
}

class BpmUserService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    getCurrentUserInfo() {
        return Observable.fromPromise(this.apiService.getInstance().activiti.profileApi.getProfile())
            .map((data) =>                  (data))
            .catch(err => this.handleError(err));
    }
    getCurrentUserProfileImage() {
        return this.apiService.getInstance().activiti.profileApi.getProfilePictureUrl();
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
BpmUserService.decorators = [
    { type: Injectable },
];
BpmUserService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class EcmUserService {
    constructor(apiService, contentService, logService) {
        this.apiService = apiService;
        this.contentService = contentService;
        this.logService = logService;
    }
    getUserInfo(userName) {
        return Observable.fromPromise(this.apiService.getInstance().core.peopleApi.getPerson(userName))
            .map(data =>                  (data['entry']))
            .catch(err => this.handleError(err));
    }
    getCurrentUserInfo() {
        return this.getUserInfo('-me-');
    }
    getUserProfileImage(avatarId) {
        if (avatarId) {
            let                  nodeObj = { entry: { id: avatarId } };
            return this.contentService.getContentUrl(nodeObj);
        }
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
EcmUserService.decorators = [
    { type: Injectable },
];
EcmUserService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: ContentService, },
    { type: LogService, },
];

class UserInfoComponent {
    constructor(ecmUserService, bpmUserService, authService) {
        this.ecmUserService = ecmUserService;
        this.bpmUserService = bpmUserService;
        this.authService = authService;
        this.ecmBackgroundImage = './assets/images/ecm-background.png';
        this.bpmBackgroundImage = './assets/images/bpm-background.png';
        this.menuPositionX = 'after';
        this.menuPositionY = 'below';
        this.showName = true;
        this.namePosition = 'right';
    }
    ngOnInit() {
        this.getUserInfo();
    }
    getUserInfo() {
        this.loadEcmUserInfo();
        this.loadBpmUserInfo();
    }
    isLoggedIn() {
        return this.authService.isLoggedIn();
    }
    loadEcmUserInfo() {
        if (this.authService.isEcmLoggedIn()) {
            this.ecmUserService.getCurrentUserInfo()
                .subscribe((res) => {
                this.ecmUser = new EcmUserModel(res);
                this.getEcmAvatar();
            });
        }
        else {
            this.ecmUser = null;
            this.ecmUserImage = null;
        }
    }
    loadBpmUserInfo() {
        if (this.authService.isBpmLoggedIn()) {
            this.bpmUserService.getCurrentUserInfo()
                .subscribe((res) => {
                this.bpmUser = new BpmUserModel(res);
            });
            this.bpmUserImage = this.bpmUserService.getCurrentUserProfileImage();
        }
        else {
            this.bpmUser = null;
            this.bpmUserImage = null;
        }
    }
    stopClosing(event) {
        event.stopPropagation();
    }
    getEcmAvatar() {
        this.ecmUserImage = this.ecmUserService.getUserProfileImage(this.ecmUser.avatarId);
    }
    showOnRight() {
        return this.namePosition === 'right';
    }
    hasBpmUserPictureId() {
        return !!this.bpmUser.pictureId;
    }
    hasEcmUserAvatarId() {
        return !!this.ecmUser.avatarId;
    }
}
UserInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-userinfo',
                styles: [``],
                template: `<div id="userinfo_container"
    [class.adf-userinfo-name-right]="showOnRight()"
    class="adf-userinfo-container" *ngIf="isLoggedIn()">
    <span *ngIf="ecmUser && showName" id="adf-userinfo-ecm-name-display"
          class="adf-userinfo-name">{{ecmUser.fullNameDisplay}}</span>
    <span *ngIf="bpmUser && !ecmUser && showName" id="adf-userinfo-bpm-name-display"
          class="adf-userinfo-name">{{bpmUser.fullNameDisplay}}</span>
    <button mat-button [matMenuTriggerFor]="menu" class="adf-userinfo-menu_button">
        <div class="adf-userinfo-button-profile" id="user-profile" data-automation-id="user-profile">
            <div *ngIf="bpmUser && !ecmUser" id="bpm-user-image">
                <div *ngIf="!hasBpmUserPictureId()" [outerHTML]="bpmUser | usernameInitials:'adf-userinfo-pic'"></div>
                <div *ngIf="hasBpmUserPictureId()" class="adf-userinfo-profile-container">
                    <img id="logged-user-img" [src]="bpmUserImage" alt="user-info-profile-button"
                        class="adf-userinfo-profile-image"/>
                </div>
            </div>
            <div *ngIf="ecmUser" id="ecm-user-image">
                    <div *ngIf="!hasEcmUserAvatarId()" [outerHTML]="ecmUser | usernameInitials:'adf-userinfo-pic'"></div>
                    <div *ngIf="hasEcmUserAvatarId()" class="adf-userinfo-profile-container">
                        <img id="logged-user-img" [src]="ecmUserImage" alt="user-info-profile-button"
                            class="adf-userinfo-profile-image"/>
                    </div>
            </div>
    </div>
</button>
    <mat-menu #menu="matMenu" id="user-profile-lists" [xPosition]="menuPositionX" [yPosition]="menuPositionY" [overlapTrigger]="false" class="adf-userinfo-menu">
        <mat-tab-group id="tab-group-env" (click)="stopClosing($event)"
            class="adf-userinfo-tab" [class.adf-hide-tab]="!bpmUser || !ecmUser">
            <mat-tab id="ecm-panel" label="{{ 'USER_PROFILE.TAB.CS' | translate }}" *ngIf="ecmUser">
                <mat-card class="adf-userinfo-card">
                    <mat-card-header class="adf-userinfo-card-header" [style.background-image]="'url(' + ecmBackgroundImage + ')'">
                        <div *ngIf="!hasEcmUserAvatarId()" [outerHTML]="ecmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'"></div>
                        <div *ngIf="hasEcmUserAvatarId()" class="adf-userinfo-profile-container adf-hide-small">
                            <img class="adf-userinfo-profile-picture" id="ecm-user-detail-image"
                                alt="ecm-profile-image" [src]="ecmUserImage" />
                        </div>
                       <div class="adf-userinfo-title" id="ecm-username">{{ecmUser.fullNameDisplay}}</div>
                    </mat-card-header>
                    <mat-card-content>
                        <div class="adf-userinfo-supporting-text">
                                <div class="adf-userinfo-detail">
                                    <span id="ecm-full-name" class="adf-userinfo__detail-title">{{ecmUser.fullNameDisplay}}</span>
                                    <span class="adf-userinfo__detail-profile" id="ecm-email"> {{ecmUser.email}} </span>
                                </div>
                                <div class="adf-userinfo-detail">
                                    <span class="adf-userinfo__secondary-info" id="ecm-job-title-label">
                                        {{ 'USER_PROFILE.LABELS.ECM.JOB_TITLE' | translate }}
                                        <span id="ecm-job-title" class="adf-userinfo__detail-profile"> {{ ecmUser.jobTitle ? ecmUser.jobTitle : 'N/A' }} </span>
                                    </span>
                                </div>
                        </div>
                    </mat-card-content>
                </mat-card>
            </mat-tab>
            <mat-tab id="bpm-panel" label="{{ 'USER_PROFILE.TAB.PS' | translate }}" *ngIf="bpmUser">
            <mat-card class="adf-userinfo-card">
                <mat-card-header class="adf-userinfo-card-header" [style.background-image]="'url(' + bpmBackgroundImage + ')'">
                    <div *ngIf="!hasBpmUserPictureId()" [outerHTML]="bpmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'"></div>
                    <img *ngIf="hasBpmUserPictureId()" class="adf-userinfo-profile-picture adf-hide-small" id="bpm-user-detail-image"
                            alt="bpm-profile-image" [src]="bpmUserImage"/>
                   <div class="adf-userinfo-title" id="bpm-username">{{bpmUser.fullNameDisplay}}</div>
                </mat-card-header>
                <mat-card-content>
                    <div class="adf-userinfo-supporting-text">
                            <div class="adf-userinfo-detail">
                                <span id="bpm-full-name" class="adf-userinfo__detail-title">{{ bpmUser.fullNameDisplay }}</span>
                                <span class="adf-userinfo__detail-profile" id="bpm-email"> {{bpmUser.email}} </span>
                            </div>
                            <div class="adf-userinfo-detail">
                                <span id="bpm-tenant" class="adf-userinfo__secondary-info">
                                    {{ 'USER_PROFILE.LABELS.BPM.TENANT' | translate }}
                                    <span class="adf-userinfo__detail-profile">{{ bpmUser.tenantName ? bpmUser.tenantName : '' }}</span>
                                </span>
                            </div>
                    </div>
                </mat-card-content>
            </mat-card>
            </mat-tab>
        </mat-tab-group>
    </mat-menu>
</div>
`,
                encapsulation: ViewEncapsulation.None
            },] },
];
UserInfoComponent.ctorParameters = () => [
    { type: EcmUserService, },
    { type: BpmUserService, },
    { type: AuthenticationService, },
];
UserInfoComponent.propDecorators = {
    "ecmBackgroundImage": [{ type: Input },],
    "bpmBackgroundImage": [{ type: Input },],
    "menuPositionX": [{ type: Input },],
    "menuPositionY": [{ type: Input },],
    "showName": [{ type: Input },],
    "namePosition": [{ type: Input },],
};

class UserInfoModule {
}
UserInfoModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    PipeModule
                ],
                declarations: [
                    UserInfoComponent
                ],
                providers: [
                    EcmUserService,
                    BpmUserService
                ],
                exports: [
                    UserInfoComponent
                ]
            },] },
];
UserInfoModule.ctorParameters = () => [];

class SettingsService {
    constructor(appConfig, logService, preferences) {
        this.appConfig = appConfig;
        this.logService = logService;
        this.preferences = preferences;
    }
    get ecmHost() {
        this.logService.log('SettingsService.ecmHost is deprecated. Use AppConfigService instead.');
        return this.appConfig.get('ecmHost');
    }
    set csrfDisabled(csrfDisabled) {
        this.logService.log(`SettingsService.csrfDisabled is deprecated. Use UserPreferencesService.disableCSRF instead.`);
        this.preferences.disableCSRF = csrfDisabled;
    }
    set ecmHost(ecmHostUrl) {
        this.logService.log('SettingsService.ecmHost is deprecated. Use AppConfigService instead.');
    }
    get bpmHost() {
        this.logService.log('SettingsService.bpmHost is deprecated. Use AppConfigService instead.');
        return this.appConfig.get('bpmHost');
    }
    set bpmHost(bpmHostUrl) {
        this.logService.log('SettingsService.bpmHost is deprecated. Use AppConfigService instead.');
    }
    getBPMApiBaseUrl() {
        this.logService.log('SettingsService.getBPMApiBaseUrl is deprecated.');
        return this.bpmHost + '/activiti-app';
    }
    getProviders() {
        this.logService.log(`SettingsService.getProviders is deprecated. Use UserPreferencesService.authType instead.`);
        return this.preferences.authType;
    }
    setProviders(providers) {
        this.logService.log(`SettingsService.getProviders is deprecated. Use UserPreferencesService.authType instead.`);
        this.preferences.authType = providers;
    }
}
SettingsService.decorators = [
    { type: Injectable },
];
SettingsService.ctorParameters = () => [
    { type: AppConfigService, },
    { type: LogService, },
    { type: UserPreferencesService, },
];

class HostSettingsComponent {
    constructor(settingsService, storage, logService, translationService) {
        this.settingsService = settingsService;
        this.storage = storage;
        this.logService = logService;
        this.translationService = translationService;
        this.HOST_REGEX = '^(http|https):\/\/.*[^/]$';
        this.urlFormControlEcm = new FormControl('', [Validators.required, Validators.pattern(this.HOST_REGEX)]);
        this.urlFormControlBpm = new FormControl('', [Validators.required, Validators.pattern(this.HOST_REGEX)]);
        this.providers = 'ALL';
        this.error = new EventEmitter();
        this.ecmHostChange = new EventEmitter();
        this.bpmHostChange = new EventEmitter();
        this.ecmHostTmp = this.ecmHost = storage.getItem('ecmHost') || this.settingsService.ecmHost;
        this.bpmHostTmp = this.bpmHost = storage.getItem('bpmHost') || this.settingsService.bpmHost;
    }
    onChangeECMHost(event) {
        let                  value = (                 (event.target)).value.trim();
        if (value && this.isValidUrl(value)) {
            this.logService.info(`ECM host: ${value}`);
            this.ecmHostTmp = value;
            this.ecmHostChange.emit(value);
        }
        else {
            this.translationService.get('CORE.HOST_SETTING.CS_URL_ERROR').subscribe((message) => {
                this.error.emit(message);
            });
        }
    }
    onChangeBPMHost(event) {
        let                  value = (                 (event.target)).value.trim();
        if (value && this.isValidUrl(value)) {
            this.logService.info(`BPM host: ${value}`);
            this.bpmHostTmp = value;
            this.bpmHostChange.emit(value);
        }
        else {
            this.translationService.get('CORE.HOST_SETTING.PS_URL_ERROR').subscribe((message) => {
                this.error.emit(message);
            });
        }
    }
    save(event) {
        if (this.bpmHost !== this.bpmHostTmp) {
            this.storage.setItem(`bpmHost`, this.bpmHostTmp);
        }
        if (this.ecmHost !== this.ecmHostTmp) {
            this.storage.setItem(`ecmHost`, this.ecmHostTmp);
        }
        window.location.href = '/';
    }
    isValidUrl(url) {
        return /^(http|https):\/\/.*/.test(url);
    }
}
HostSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-host-settings',
                template: `<div class="adf-setting-container">
    <div class="adf-setting-card-padding"></div>
    <mat-toolbar color="primary" class="adf-setting-toolbar">
        <h3>{{'CORE.HOST_SETTINGS.TITLE' | translate}}</h3>
    </mat-toolbar>

    <mat-card class="adf-setting-card">
        <div *ngIf="providers==='ALL' || providers==='ECM'">
            <mat-card-header>
                <mat-card-subtitle>{{'CORE.HOST_SETTINGS.CS-HOST' | translate }}</mat-card-subtitle>
            </mat-card-header>
            <mat-card-content>
                <mat-form-field class="full-width">
                    <mat-icon class="adf-CORE.HOST_SETTINGS-link-icon" matPrefix>link</mat-icon>
                    <input matInput
                           [formControl]="urlFormControlEcm"
                           data-automation-id="ecmHost"
                           type="text"
                           (change)="onChangeECMHost($event)"
                           tabindex="2"
                           id="ecmHost"
                           value="{{ecmHost}}"
                           placeholder="http(s)://host|ip:port(/path)">
                    <mat-error *ngIf="urlFormControlEcm.hasError('pattern')">
                        {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}
                    </mat-error>
                </mat-form-field>
                <p>
            </mat-card-content>
        </div>
        <p>
        <div *ngIf="providers==='ALL' || providers==='BPM'">
            <mat-card-header>
                <mat-card-subtitle>{{'CORE.HOST_SETTINGS.BP-HOST' | translate }}</mat-card-subtitle>
            </mat-card-header>
            <mat-card-content>

                <mat-form-field class="full-width">
                    <mat-icon class="adf-CORE.HOST_SETTINGS-link-icon" matPrefix>link</mat-icon>
                    <input matInput
                           [formControl]="urlFormControlBpm"
                           data-automation-id="bpmHost"
                           type="text"
                           (change)="onChangeBPMHost($event)"
                           tabindex="2"
                           id="bpmHost"
                           value="{{bpmHost}}"
                           placeholder="http(s)://host|ip:port(/path)">
                    <mat-error *ngIf="urlFormControlBpm.hasError('pattern')">
                        {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}
                    </mat-error>
                </mat-form-field>
            </mat-card-content>
        </div>
        <mat-card-actions class="adf-CORE.HOST_SETTINGS-actions">

            <button mat-button onclick="window.history.back()" color="primary">
                {{'CORE.HOST_SETTINGS.BACK' | translate }}
            </button>

            <button mat-raised-button (click)="save($event)"
                    [disabled]="urlFormControlBpm.hasError('pattern') || urlFormControlEcm.hasError('pattern')"
                    color="primary">
                {{'CORE.HOST_SETTINGS.APPLY' | translate }}
            </button>

        </mat-card-actions>
    </mat-card>
    <div class="adf-setting-card-padding"></div>
</div>
`,
                host: {
                    'class': 'adf-host-settings'
                },
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
HostSettingsComponent.ctorParameters = () => [
    { type: SettingsService, },
    { type: StorageService, },
    { type: LogService, },
    { type: TranslationService, },
];
HostSettingsComponent.propDecorators = {
    "providers": [{ type: Input },],
    "error": [{ type: Output },],
    "ecmHostChange": [{ type: Output },],
    "bpmHostChange": [{ type: Output },],
};

class HostSettingsModule {
}
HostSettingsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    HostSettingsComponent
                ],
                exports: [
                    HostSettingsComponent
                ]
            },] },
];
HostSettingsModule.ctorParameters = () => [];

class PaginationModel {
    constructor(obj) {
        if (obj) {
            this.count = obj.count;
            this.hasMoreItems = obj.hasMoreItems ? obj.hasMoreItems : false;
            this.merge = obj.merge ? obj.merge : false;
            this.totalItems = obj.totalItems;
            this.skipCount = obj.skipCount;
            this.maxItems = obj.maxItems;
        }
    }
}

class PaginationComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.supportedPageSizes = [5, 25, 50, 100];
        this.pagination = PaginationComponent.DEFAULT_PAGINATION;
        this.change = new EventEmitter();
        this.changePageNumber = new EventEmitter();
        this.changePageSize = new EventEmitter();
        this.nextPage = new EventEmitter();
        this.prevPage = new EventEmitter();
    }
    ngOnInit() {
        if (this.target) {
            this.paginationSubscription = this.target.pagination.subscribe((pagination) => {
                this.pagination = pagination;
                this.cdr.detectChanges();
            });
        }
        if (!this.pagination) {
            this.pagination = PaginationComponent.DEFAULT_PAGINATION;
        }
    }
    get lastPage() {
        const { maxItems, totalItems } = this.pagination;
        return (totalItems && maxItems)
            ? Math.ceil(totalItems / maxItems)
            : 1;
    }
    get current() {
        const { maxItems, skipCount } = this.pagination;
        return (skipCount && maxItems)
            ? Math.floor(skipCount / maxItems) + 1
            : 1;
    }
    get isLastPage() {
        return this.current === this.lastPage;
    }
    get isFirstPage() {
        return this.current === 1;
    }
    get next() {
        return this.isLastPage ? this.current : this.current + 1;
    }
    get previous() {
        return this.isFirstPage ? 1 : this.current - 1;
    }
    get hasItems() {
        return this.pagination && this.pagination.count > 0;
    }
    get isEmpty() {
        return !this.hasItems;
    }
    get range() {
        const { skipCount, maxItems, totalItems } = this.pagination;
        const { isLastPage } = this;
        const                  start = totalItems ? skipCount + 1 : 0;
        const                  end = isLastPage ? totalItems : skipCount + maxItems;
        return [start, end];
    }
    get pages() {
        return Array(this.lastPage)
            .fill('n')
            .map((item, index) => (index + 1));
    }
    goNext() {
        if (this.hasItems) {
            const                  maxItems = this.pagination.maxItems;
            const                  skipCount = (this.next - 1) * maxItems;
            this.pagination.skipCount = skipCount;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.NEXT_PAGE, {
                skipCount,
                maxItems
            });
        }
    }
    goPrevious() {
        if (this.hasItems) {
            const                  maxItems = this.pagination.maxItems;
            const                  skipCount = (this.previous - 1) * maxItems;
            this.pagination.skipCount = skipCount;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.PREV_PAGE, {
                skipCount,
                maxItems
            });
        }
    }
    onChangePageNumber(pageNumber) {
        if (this.hasItems) {
            const                  maxItems = this.pagination.maxItems;
            const                  skipCount = (pageNumber - 1) * maxItems;
            this.pagination.skipCount = skipCount;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.CHANGE_PAGE_NUMBER, {
                skipCount,
                maxItems
            });
        }
    }
    onChangePageSize(maxItems) {
        this.pagination.skipCount = 0;
        this.pagination.maxItems = maxItems;
        this.handlePaginationEvent(PaginationComponent.ACTIONS.CHANGE_PAGE_SIZE, {
            skipCount: 0,
            maxItems
        });
    }
    handlePaginationEvent(action, params) {
        const { NEXT_PAGE, PREV_PAGE, CHANGE_PAGE_NUMBER, CHANGE_PAGE_SIZE } = PaginationComponent.ACTIONS;
        const { change, changePageNumber, changePageSize, nextPage, prevPage, pagination } = this;
        const                  data = Object.assign({}, pagination, params);
        if (action === NEXT_PAGE) {
            nextPage.emit(data);
        }
        if (action === PREV_PAGE) {
            prevPage.emit(data);
        }
        if (action === CHANGE_PAGE_NUMBER) {
            changePageNumber.emit(data);
        }
        if (action === CHANGE_PAGE_SIZE) {
            changePageSize.emit(data);
        }
        change.emit(params);
        if (this.target) {
            this.target.updatePagination(params);
        }
    }
    ngOnDestroy() {
        if (this.paginationSubscription) {
            this.paginationSubscription.unsubscribe();
        }
    }
}
PaginationComponent.DEFAULT_PAGINATION = {
    skipCount: 0,
    maxItems: 25,
    totalItems: 0
};
PaginationComponent.ACTIONS = {
    NEXT_PAGE: 'NEXT_PAGE',
    PREV_PAGE: 'PREV_PAGE',
    CHANGE_PAGE_SIZE: 'CHANGE_PAGE_SIZE',
    CHANGE_PAGE_NUMBER: 'CHANGE_PAGE_NUMBER'
};
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pagination',
                host: { 'class': 'adf-pagination' },
                template: `<ng-container *ngIf="hasItems">
    <div class="adf-pagination__block adf-pagination__range-block">
        <span class="adf-pagination__range">
            {{
                'CORE.PAGINATION.ITEMS_RANGE' | translate: {
                    range: range.join('-'),
                    total: pagination.totalItems
                }
            }}
        </span>
    </div>

    <div class="adf-pagination__block adf-pagination__perpage-block">
        <span>
            {{ 'CORE.PAGINATION.ITEMS_PER_PAGE' | translate }}
        </span>

        <span class="adf-pagination__max-items">
            {{ pagination.maxItems }}
        </span>

        <button mat-icon-button [matMenuTriggerFor]="pageSizeMenu">
            <mat-icon>arrow_drop_down</mat-icon>
        </button>

        <mat-menu #pageSizeMenu="matMenu" class="adf-pagination__page-selector">
            <button
                mat-menu-item
                *ngFor="let pageSize of supportedPageSizes"
                (click)="onChangePageSize(pageSize)">
                {{ pageSize }}
            </button>
        </mat-menu>
    </div>

    <div class="adf-pagination__block adf-pagination__actualinfo-block">
        <span class="adf-pagination__current-page">
            {{ 'CORE.PAGINATION.CURRENT_PAGE' | translate: { number: current } }}
        </span>

        <button
            mat-icon-button
            [matMenuTriggerFor]="pagesMenu"
            *ngIf="pages.length > 1">
            <mat-icon>arrow_drop_down</mat-icon>
        </button>

        <span class="adf-pagination__total-pages">
            {{ 'CORE.PAGINATION.TOTAL_PAGES' | translate: { total: pages.length } }}
        </span>

        <mat-menu #pagesMenu="matMenu" class="adf-pagination__page-selector">
            <button
                mat-menu-item
                *ngFor="let pageNumber of pages"
                (click)="onChangePageNumber(pageNumber)">
                {{ pageNumber }}
            </button>
        </mat-menu>
    </div>

    <div class="adf-pagination__block adf-pagination__controls-block">
        <button
            class="adf-pagination__previous-button"
            mat-icon-button
            [disabled]="isFirstPage"
            (click)="goPrevious()">
            <mat-icon>keyboard_arrow_left</mat-icon>
        </button>

        <button
            class="adf-pagination__next-button"
            mat-icon-button
            [disabled]="isLastPage"
            (click)="goNext()">
            <mat-icon>keyboard_arrow_right</mat-icon>
        </button>
    </div>
</ng-container>
`,
                styles: [``],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
PaginationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
PaginationComponent.propDecorators = {
    "target": [{ type: Input },],
    "supportedPageSizes": [{ type: Input },],
    "pagination": [{ type: Input },],
    "change": [{ type: Output },],
    "changePageNumber": [{ type: Output },],
    "changePageSize": [{ type: Output },],
    "nextPage": [{ type: Output },],
    "prevPage": [{ type: Output },],
    "isEmpty": [{ type: HostBinding, args: ['class.adf-pagination__empty',] },],
};

class InfinitePaginationComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.pageSize = InfinitePaginationComponent.DEFAULT_PAGE_SIZE;
        this.isLoading = false;
        this.loadMore = new EventEmitter();
    }
    ngOnInit() {
        if (this.target) {
            this.paginationSubscription = this.target.pagination.subscribe(pagination => {
                this.isLoading = false;
                this.pagination = pagination;
                this.pageSize = pagination.maxItems;
                this.cdr.detectChanges();
            });
        }
        if (!this.pagination) {
            this.pagination = InfinitePaginationComponent.DEFAULT_PAGINATION;
        }
    }
    onLoadMore() {
        this.pagination.skipCount += this.pageSize;
        this.pagination.skipCount = this.pagination.skipCount;
        this.pagination.merge = true;
        this.loadMore.next(this.pagination);
        if ((this.pagination.skipCount + this.pageSize) > this.pagination.totalItems) {
            this.pagination.hasMoreItems = false;
        }
        if (this.target) {
            this.target.pagination.value.merge = this.pagination.merge;
            this.target.pagination.value.skipCount = this.pagination.skipCount;
            this.isLoading = true;
            this.target.updatePagination(                 (this.pagination));
        }
    }
    ngOnDestroy() {
        if (this.paginationSubscription) {
            this.paginationSubscription.unsubscribe();
        }
    }
}
InfinitePaginationComponent.DEFAULT_PAGE_SIZE = 25;
InfinitePaginationComponent.DEFAULT_PAGINATION = {
    skipCount: 0,
    hasMoreItems: false,
    merge: true
};
InfinitePaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-infinite-pagination',
                host: { 'class': 'infinite-adf-pagination' },
                template: `<div *ngIf="pagination?.hasMoreItems || isLoading" class="adf-infinite-pagination">
    <button mat-button
        *ngIf="!isLoading"
        class="adf-infinite-pagination-load-more"
        (click)="onLoadMore($event)"
        data-automation-id="adf-infinite-pagination-button">
            <ng-content></ng-content>
    </button>

    <mat-progress-bar *ngIf="isLoading"
        mode="indeterminate"
        class="adf-infinite-pagination-spinner"
        data-automation-id="adf-infinite-pagination-spinner"></mat-progress-bar>
</div>
`,
                styles: [`.adf-infinite-pagination{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;min-height:56px}.adf-infinite-pagination-load-more{margin-bottom:10px;margin-top:10px}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            },] },
];
InfinitePaginationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
InfinitePaginationComponent.propDecorators = {
    "pagination": [{ type: Input },],
    "target": [{ type: Input },],
    "pageSize": [{ type: Input },],
    "isLoading": [{ type: Input, args: ['loading',] },],
    "loadMore": [{ type: Output },],
};

class PaginationModule {
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ],
                exports: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ]
            },] },
];
PaginationModule.ctorParameters = () => [];

class LoginErrorEvent {
    constructor(err) {
        this.err = err;
    }
}

class LoginSubmitEvent {
    constructor(_values) {
        this._defaultPrevented = false;
        this._values = _values;
    }
    get values() {
        return this._values;
    }
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    preventDefault() {
        this._defaultPrevented = true;
    }
}

class LoginSuccessEvent {
    constructor(token, username, password) {
        this.token = token;
        this.username = username;
        this.password = password;
    }
}

const LoginSteps = {
    Landing: 0,
    Checking: 1,
    Welcome: 2,
};
LoginSteps[LoginSteps.Landing] = "Landing";
LoginSteps[LoginSteps.Checking] = "Checking";
LoginSteps[LoginSteps.Welcome] = "Welcome";
class LoginComponent {
    constructor(_fb, authService, settingsService, translateService, logService, elementRef, router, userPreferences) {
        this._fb = _fb;
        this.authService = authService;
        this.settingsService = settingsService;
        this.translateService = translateService;
        this.logService = logService;
        this.elementRef = elementRef;
        this.router = router;
        this.userPreferences = userPreferences;
        this.isPasswordShow = false;
        this.showRememberMe = true;
        this.showLoginActions = true;
        this.needHelpLink = '';
        this.registerLink = '';
        this.logoImageUrl = './assets/images/alfresco-logo.svg';
        this.backgroundImageUrl = './assets/images/background.svg';
        this.copyrightText = '\u00A9 2016 Alfresco Software, Inc. All Rights Reserved.';
        this.successRoute = null;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.executeSubmit = new EventEmitter();
        this.isError = false;
        this.actualLoginStep = LoginSteps.Landing;
        this.LoginSteps = LoginSteps;
        this.rememberMe = true;
        this.minLength = 2;
        this.initFormError();
        this.initFormFieldsMessages();
    }
    ngOnInit() {
        if (this.hasCustomFiledsValidation()) {
            this.form = this._fb.group(this.fieldsValidation);
        }
        else {
            this.initFormFieldsDefault();
            this.initFormFieldsMessagesDefault();
        }
        this.form.valueChanges.subscribe(data => this.onValueChanged(data));
    }
    onSubmit(values) {
        if (!this.checkRequiredParams()) {
            return false;
        }
        this.settingsService.setProviders(this.providers);
        this.settingsService.csrfDisabled = this.disableCsrf;
        this.disableError();
        const                  args = new LoginSubmitEvent(this.form);
        this.executeSubmit.emit(args);
        if (args.defaultPrevented) {
            return false;
        }
        else {
            this.performLogin(values);
        }
    }
    onValueChanged(data) {
        this.disableError();
        for (let                  field in this.formError) {
            if (field) {
                this.formError[field] = '';
                let                  hasError = (this.form.controls[field].errors && data[field] !== '') ||
                    (this.form.controls[field].dirty && !this.form.controls[field].valid);
                if (hasError) {
                    for (let                  key in this.form.controls[field].errors) {
                        if (key) {
                            this.formError[field] += this._message[field][key] + '';
                        }
                    }
                }
            }
        }
    }
    performLogin(values) {
        this.actualLoginStep = LoginSteps.Checking;
        this.authService.login(values.username, values.password, this.rememberMe)
            .subscribe((token) => {
            const                  redirectUrl = this.authService.getRedirectUrl(this.providers);
            this.actualLoginStep = LoginSteps.Welcome;
            this.userPreferences.setStoragePrefix(values.username);
            values.password = null;
            this.success.emit(new LoginSuccessEvent(token, values.username, null));
            if (redirectUrl) {
                this.authService.setRedirectUrl(null);
                this.router.navigate([redirectUrl]);
            }
            else if (this.successRoute) {
                this.router.navigate([this.successRoute]);
            }
        }, (err) => {
            this.actualLoginStep = LoginSteps.Landing;
            this.displayErrorMessage(err);
            this.enableError();
            this.error.emit(new LoginErrorEvent(err));
        }, () => this.logService.info('Login done'));
    }
    displayErrorMessage(err) {
        if (err.error && err.error.crossDomain && err.error.message.indexOf('Access-Control-Allow-Origin') !== -1) {
            this.errorMsg = err.error.message;
        }
        else if (err.status === 403 && err.message.indexOf('Invalid CSRF-token') !== -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CSRF';
        }
        else if (err.status === 403 && err.message.indexOf('The system is currently in read-only mode') !== -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ECM-LICENSE';
        }
        else {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CREDENTIALS';
        }
    }
    checkRequiredParams() {
        let                  isAllParamPresent = true;
        if (this.providers === undefined || this.providers === null || this.providers === '') {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-PROVIDERS';
            this.enableError();
            let                  messageProviders;
            messageProviders = this.translateService.get(this.errorMsg);
            this.error.emit(new LoginErrorEvent(messageProviders.value));
            isAllParamPresent = false;
        }
        return isAllParamPresent;
    }
    addCustomFormError(field, msg) {
        this.formError[field] += msg;
    }
    addCustomValidationError(field, ruleId, msg, params) {
        if (params) {
            this.translateService.get(msg, params).subscribe((res) => {
                this._message[field][ruleId] = res;
            });
        }
        else {
            this._message[field][ruleId] = msg;
        }
    }
    toggleShowPassword() {
        this.isPasswordShow = !this.isPasswordShow;
        this.elementRef.nativeElement.querySelector('#password').type = this.isPasswordShow ? 'text' : 'password';
    }
    isErrorStyle(field) {
        return !field.valid && field.dirty && !field.pristine;
    }
    trimUsername(event) {
        event.target.value = event.target.value.trim();
    }
    initFormError() {
        this.formError = {
            'username': '',
            'password': ''
        };
    }
    initFormFieldsMessages() {
        this._message = {
            'username': {},
            'password': {}
        };
    }
    initFormFieldsMessagesDefault() {
        this._message = {
            'username': {
                'required': 'LOGIN.MESSAGES.USERNAME-REQUIRED'
            },
            'password': {
                'required': 'LOGIN.MESSAGES.PASSWORD-REQUIRED'
            }
        };
        this.translateService.get('LOGIN.MESSAGES.USERNAME-MIN', { minLength: this.minLength }).subscribe((res) => {
            this._message['username']['minlength'] = res;
        });
    }
    initFormFieldsDefault() {
        this.form = this._fb.group({
            username: ['', Validators.required],
            password: ['', Validators.required]
        });
    }
    disableError() {
        this.isError = false;
        this.initFormError();
    }
    enableError() {
        this.isError = true;
    }
    hasCustomFiledsValidation() {
        return this.fieldsValidation !== undefined;
    }
}
LoginComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login',
                template: `<div class="adf-login-content" [style.background-image]="'url(' + backgroundImageUrl + ')'">
     <div class="ie11FixerParent">
         <div class="ie11FixerChild">

            <mat-card class="adf-login-card-wide">
                <form id="adf-login-form" [formGroup]="form" (submit)="onSubmit(form.value)" autocomplete="off">

                    <mat-card-header>
                        <mat-card-title>
                            <div class="adf-alfresco-logo">
                                <!--HEADER TEMPLATE-->
                                <ng-template *ngIf="headerTemplate"
                                            ngFor [ngForOf]="[data]"
                                            [ngForTemplate]="headerTemplate">
                                </ng-template>
                                <img *ngIf="!headerTemplate" class="adf-img-logo" [src]="logoImageUrl"
                                    alt="{{'LOGIN.LOGO' | translate }}">
                            </div>
                        </mat-card-title>
                    </mat-card-header>

                    <mat-card-content class="adf-login-controls">

                        <!--ERRORS AREA-->
                        <div class="adf-error-container">
                            <div *ngIf="isError" id="login-error" data-automation-id="login-error"
                                class="error  adf-error-message">
                                <mat-icon class="error-icon">warning</mat-icon>
                                <span class="login-error-message">{{errorMsg | translate }}</span>
                            </div>
                        </div>

                        <!--USERNAME FIELD-->
                        <div class="adf-login__field" [ngClass]="{'is-invalid': isErrorStyle(form.controls.username)}">
                            <mat-form-field class="adf-full-width" floatPlaceholder="never" color="primary">
                                <input matInput placeholder="{{'LOGIN.LABEL.USERNAME' | translate }}"
                                    type="text"
                                    class="adf-full-width"
                                    [formControl]="form.controls['username']"
                                    autocapitalize="none"
                                    id="username"
                                    data-automation-id="username"
                                    (blur)="trimUsername($event)"
                                    tabindex="1">
                            </mat-form-field>

                            <span class="adf-login-validation" for="username" *ngIf="formError.username">
                                <span id="username-error" class="adf-login-error" data-automation-id="username-error">{{formError.username | translate }}</span>
                            </span>
                        </div>

                        <!--PASSWORD FIELD-->
                        <div class="adf-login__field">
                            <mat-form-field class="adf-full-width" floatPlaceholder="never" color="primary">
                                <input matInput placeholder="{{'LOGIN.LABEL.PASSWORD' | translate }}"
                                    type="password"
                                    [formControl]="form.controls['password']"
                                    id="password"
                                    data-automation-id="password"
                                    tabindex="2">
                                <mat-icon *ngIf="isPasswordShow" matSuffix class="adf-login-password-icon"
                                        data-automation-id="hide_password" (click)="toggleShowPassword()">visibility
                                </mat-icon>
                                <mat-icon *ngIf="!isPasswordShow" matSuffix class="adf-login-password-icon"
                                        data-automation-id="show_password" (click)="toggleShowPassword()">visibility_off
                                </mat-icon>
                            </mat-form-field>
                            <span class="adf-login-validation" for="password" *ngIf="formError.password">
                                <span id="password-required" class="adf-login-error"
                                    data-automation-id="password-required">{{formError.password | translate }}</span>
                            </span>
                        </div>

                        <!--CUSTOM CONTENT-->
                        <ng-content></ng-content>

                        <br>
                        <button type="submit" id="login-button" tabindex="3"
                                class="adf-login-button"
                                mat-raised-button color="primary"
                                [class.isChecking]="actualLoginStep === LoginSteps.Checking"
                                [class.isWelcome]="actualLoginStep === LoginSteps.Welcome"
                                data-automation-id="login-button" [disabled]="!form.valid">

                            <span *ngIf="actualLoginStep === LoginSteps.Landing" class="adf-login-button-label">{{ 'LOGIN.BUTTON.LOGIN' | translate }}</span>

                            <div *ngIf="actualLoginStep === LoginSteps.Checking" class="adf-interactive-login-label">
                                <span class="adf-login-button-label">{{ 'LOGIN.BUTTON.CHECKING' | translate }}</span>
                                <div class="adf-login-spinner-container">
                                    <mat-spinner id="checking-spinner" class="adf-login-checking-spinner" [diameter]="25"></mat-spinner>
                                </div>
                            </div>


                            <div *ngIf="actualLoginStep === LoginSteps.Welcome" class="adf-interactive-login-label">
                                <span class="adf-login-button-label">{{ 'LOGIN.BUTTON.WELCOME' | translate }}</span>
                                <mat-icon class="welcome-icon">done</mat-icon>
                            </div>

                        </button>
                        <div *ngIf="showRememberMe" class="adf-login__remember-me">
                            <mat-checkbox id="adf-login-remember" color="primary" class="adf-login-rememberme" [checked]="rememberMe"
                                        (change)="rememberMe = !rememberMe">{{ 'LOGIN.LABEL.REMEMBER' | translate }}
                            </mat-checkbox>
                        </div>
                    </mat-card-content>
                    <mat-card-actions *ngIf="footerTemplate || showLoginActions">

                        <div class="adf-login-action-container">
                            <!--FOOTER TEMPLATE-->
                            <ng-template *ngIf="footerTemplate"
                                        ngFor [ngForOf]="[data]"
                                        [ngForTemplate]="footerTemplate">
                            </ng-template>
                            <div class="adf-login-action" *ngIf="!footerTemplate && showLoginActions">
                                <div id="adf-login-action-left" class="adf-login-action-left">
                                    <a href="{{needHelpLink}}">{{'LOGIN.ACTION.HELP' | translate }}</a>
                                </div>
                                <div id="adf-login-action-right" class="adf-login-action-right">
                                    <a href="{{registerLink}}">{{'LOGIN.ACTION.REGISTER' | translate }}</a>
                                </div>
                            </div>
                        </div>
                    </mat-card-actions>

                </form>
            </mat-card>

            <div class="copyright" data-automation-id="login-copyright">
                {{ copyrightText }}
            </div>

        </div>
     </div>
</div>
`,
                styles: [``],
                host: { '(blur)': 'onBlur($event)' },
                encapsulation: ViewEncapsulation.None
            },] },
];
LoginComponent.ctorParameters = () => [
    { type: FormBuilder, },
    { type: AuthenticationService, },
    { type: SettingsService, },
    { type: TranslationService, },
    { type: LogService, },
    { type: ElementRef, },
    { type: Router, },
    { type: UserPreferencesService, },
];
LoginComponent.propDecorators = {
    "showRememberMe": [{ type: Input },],
    "showLoginActions": [{ type: Input },],
    "needHelpLink": [{ type: Input },],
    "registerLink": [{ type: Input },],
    "logoImageUrl": [{ type: Input },],
    "backgroundImageUrl": [{ type: Input },],
    "copyrightText": [{ type: Input },],
    "providers": [{ type: Input },],
    "fieldsValidation": [{ type: Input },],
    "disableCsrf": [{ type: Input },],
    "successRoute": [{ type: Input },],
    "success": [{ type: Output },],
    "error": [{ type: Output },],
    "executeSubmit": [{ type: Output },],
};

class LoginHeaderDirective {
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    ngAfterContentInit() {
        this.alfrescoLoginComponent.headerTemplate = this.template;
    }
}
LoginHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'login-header'
            },] },
];
LoginHeaderDirective.ctorParameters = () => [
    { type: LoginComponent, },
];
LoginHeaderDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class LoginFooterDirective {
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    ngAfterContentInit() {
        this.alfrescoLoginComponent.footerTemplate = this.template;
    }
}
LoginFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'login-footer'
            },] },
];
LoginFooterDirective.ctorParameters = () => [
    { type: LoginComponent, },
];
LoginFooterDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class LoginModule {
}
LoginModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    LoginComponent,
                    LoginFooterDirective,
                    LoginHeaderDirective
                ],
                exports: [
                    [
                        LoginComponent,
                        LoginFooterDirective,
                        LoginHeaderDirective
                    ]
                ]
            },] },
];
LoginModule.ctorParameters = () => [];

class LanguageMenuComponent {
    constructor(appConfig, userPreference) {
        this.appConfig = appConfig;
        this.userPreference = userPreference;
        this.languages = [
            { key: 'en', label: 'English' }
        ];
    }
    ngOnInit() {
        const                  languagesCongifApp = this.appConfig.get(AppConfigService.APP_CONFIG_LANGUAGES_KEY);
        if (languagesCongifApp) {
            this.languages = languagesCongifApp;
        }
    }
    changeLanguage(lang) {
        this.userPreference.locale = lang;
    }
}
LanguageMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-language-menu',
                template: `<button mat-menu-item *ngFor="let language of languages" (click)="changeLanguage(language.key)">{{language.label}}
</button>
`
            },] },
];
LanguageMenuComponent.ctorParameters = () => [
    { type: AppConfigService, },
    { type: UserPreferencesService, },
];

class LanguageMenuModule {
}
LanguageMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    LanguageMenuComponent
                ],
                exports: [
                    LanguageMenuComponent
                ]
            },] },
];
LanguageMenuModule.ctorParameters = () => [];

class InfoDrawerLayoutComponent {
}
InfoDrawerLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-layout',
                template: `<div class="adf-info-drawer-layout-header">
    <div class="adf-info-drawer-layout-header-title">
        <ng-content select="[info-drawer-title]"></ng-content>
    </div>
    <div class="adf-info-drawer-layout-header-buttons">
        <ng-content select="[info-drawer-buttons]"></ng-content>
    </div>
</div>
<div class="adf-info-drawer-layout-content">
    <ng-content select="[info-drawer-content]"></ng-content>
</div>`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer-layout' }
            },] },
];
InfoDrawerLayoutComponent.ctorParameters = () => [];
class InfoDrawerTitleDirective {
}
InfoDrawerTitleDirective.decorators = [
    { type: Directive, args: [{ selector: '[info-drawer-title]' },] },
];
InfoDrawerTitleDirective.ctorParameters = () => [];
class InfoDrawerButtonsDirective {
}
InfoDrawerButtonsDirective.decorators = [
    { type: Directive, args: [{ selector: '[info-drawer-buttons]' },] },
];
InfoDrawerButtonsDirective.ctorParameters = () => [];
class InfoDrawerContentDirective {
}
InfoDrawerContentDirective.decorators = [
    { type: Directive, args: [{ selector: '[info-drawer-content]' },] },
];
InfoDrawerContentDirective.ctorParameters = () => [];

class InfoDrawerTabComponent {
    constructor() {
        this.label = 'Main tab';
    }
}
InfoDrawerTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-tab',
                template: '<ng-template><ng-content></ng-content></ng-template>'
            },] },
];
InfoDrawerTabComponent.ctorParameters = () => [];
InfoDrawerTabComponent.propDecorators = {
    "label": [{ type: Input, args: ['label',] },],
    "content": [{ type: ViewChild, args: [TemplateRef,] },],
};
class InfoDrawerComponent {
    constructor() {
        this.title = null;
        this.selectedIndex = 0;
        this.currentTab = new EventEmitter();
    }
    showTabLayout() {
        return this.contentBlocks.length > 0;
    }
    onTabChange(event) {
        this.currentTab.emit(event.index);
    }
}
InfoDrawerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer',
                template: `<adf-info-drawer-layout>
    <div *ngIf="title" info-drawer-title>{{title}}</div>
    <ng-content *ngIf="!title" info-drawer-title select="[info-drawer-title]"></ng-content>

    <ng-content info-drawer-buttons select="[info-drawer-buttons]"></ng-content>

    <ng-container info-drawer-content *ngIf="showTabLayout(); then tabLayout else singleLayout"></ng-container>

    <ng-template #tabLayout>
        <mat-tab-group [(selectedIndex)]="selectedIndex" class="adf-info-drawer-tabs" (selectedTabChange)="onTabChange($event)">
            <ng-container *ngFor="let contentBlock of contentBlocks">
                <mat-tab [label]="contentBlock.label" class="adf-info-drawer-tab">
                    <ng-container *ngTemplateOutlet="contentBlock.content"></ng-container>
                </mat-tab>
            </ng-container>
        </mat-tab-group>
    </ng-template>

    <ng-template #singleLayout>
        <ng-content select="[info-drawer-content]"></ng-content>
    </ng-template>
</adf-info-drawer-layout>
`,
                styles: [`.adf-info-drawer{display:block}.adf-info-drawer .adf-info-drawer-layout-content{padding:0}.adf-info-drawer .adf-info-drawer-layout-content>:not(.adf-info-drawer-tabs){padding:10px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content>*,.adf-info-drawer .adf-info-drawer-layout-content>:not(.adf-info-drawer-tabs)>*{margin-bottom:20px;display:block}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content>:last-child{margin-bottom:0}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-label{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-ink-bar{height:4px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body{padding:10px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content{overflow:initial}`],
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer' }
            },] },
];
InfoDrawerComponent.ctorParameters = () => [];
InfoDrawerComponent.propDecorators = {
    "title": [{ type: Input },],
    "selectedIndex": [{ type: Input },],
    "currentTab": [{ type: Output },],
    "contentBlocks": [{ type: ContentChildren, args: [InfoDrawerTabComponent,] },],
};

function declarations() {
    return [
        InfoDrawerLayoutComponent,
        InfoDrawerTabComponent,
        InfoDrawerComponent,
        InfoDrawerTitleDirective,
        InfoDrawerButtonsDirective,
        InfoDrawerContentDirective
    ];
}
class InfoDrawerModule {
}
InfoDrawerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: declarations(),
                exports: declarations()
            },] },
];
InfoDrawerModule.ctorParameters = () => [];

class SidebarActionMenuComponent {
    isExpanded() {
        return this.expanded;
    }
}
SidebarActionMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sidebar-action-menu',
                template: `<div class="adf-sidebar-action-menu">
    <button *ngIf="isExpanded()" mat-raised-button class="adf-sidebar-action-menu-button" data-automation-id="create-button" [matMenuTriggerFor]="adfSidebarMenu">
        <span *ngIf="title" class="adf-sidebar-action-menu-text">{{ title }}</span>
        <ng-content select="[sidebar-menu-title-icon]"></ng-content>
    </button>

    <div *ngIf="!isExpanded()" class="adf-sidebar-action-menu-icon" [matMenuTriggerFor]="adfSidebarMenu">
        <ng-content select="[sidebar-menu-expand-icon]"></ng-content>
    </div>

    <mat-menu #adfSidebarMenu="matMenu" class="adf-sidebar-action-menu-panel" [overlapTrigger]="false" yPosition="below">
        <div class="adf-sidebar-action-menu-options">
            <ng-content select="[sidebar-menu-options]"></ng-content>
        </div>
    </mat-menu>
</div>
`,
                styles: [``],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-sidebar-action-menu' }
            },] },
];
SidebarActionMenuComponent.ctorParameters = () => [];
SidebarActionMenuComponent.propDecorators = {
    "title": [{ type: Input },],
    "expanded": [{ type: Input },],
};
class SidebarMenuDirective {
}
SidebarMenuDirective.decorators = [
    { type: Directive, args: [{ selector: '[sidebar-menu-options]' },] },
];
SidebarMenuDirective.ctorParameters = () => [];
class SidebarMenuTitleIconDirective {
}
SidebarMenuTitleIconDirective.decorators = [
    { type: Directive, args: [{ selector: '[sidebar-menu-title-icon]' },] },
];
SidebarMenuTitleIconDirective.ctorParameters = () => [];
class SidebarMenuExpandIconDirective {
}
SidebarMenuExpandIconDirective.decorators = [
    { type: Directive, args: [{ selector: '[sidebar-menu-expand-icon]' },] },
];
SidebarMenuExpandIconDirective.ctorParameters = () => [];

class DataColumnComponent {
    constructor() {
        this.type = 'text';
        this.sortable = true;
        this.title = '';
    }
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
}
DataColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-column',
                template: ''
            },] },
];
DataColumnComponent.ctorParameters = () => [];
DataColumnComponent.propDecorators = {
    "key": [{ type: Input },],
    "type": [{ type: Input },],
    "format": [{ type: Input },],
    "sortable": [{ type: Input },],
    "title": [{ type: Input },],
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
    "formatTooltip": [{ type: Input },],
    "srTitle": [{ type: Input, args: ['sr-title',] },],
    "cssClass": [{ type: Input, args: ['class',] },],
};

class DataColumnListComponent {
}
DataColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-columns',
                template: ''
            },] },
];
DataColumnListComponent.ctorParameters = () => [];
DataColumnListComponent.propDecorators = {
    "columns": [{ type: ContentChildren, args: [DataColumnComponent,] },],
};

class DataColumnModule {
}
DataColumnModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    DataColumnComponent,
                    DataColumnListComponent
                ],
                exports: [
                    DataColumnComponent,
                    DataColumnListComponent
                ]
            },] },
];
DataColumnModule.ctorParameters = () => [];

class DataRowEvent extends BaseUIEvent {
    constructor(value, domEvent, sender) {
        super();
        this.value = value;
        this.event = domEvent;
        this.sender = sender;
    }
}

class DataSorting {
    constructor(key, direction) {
        this.key = key;
        this.direction = direction;
    }
}

class FileUtils {
    static flattern(folder) {
        let                  reader = folder.createReader();
        let                  files = [];
        return new Promise(resolve => {
            let                  iterations = [];
            (function traverse() {
                reader.readEntries((entries) => {
                    if (!entries.length) {
                        Promise.all(iterations).then(result => resolve(files));
                    }
                    else {
                        iterations.push(Promise.all(entries.map(entry => {
                            if (entry.isFile) {
                                return new Promise(resolveFile => {
                                    entry.file(function (f) {
                                        files.push({
                                            entry: entry,
                                            file: f,
                                            relativeFolder: entry.fullPath.replace(/\/[^\/]*$/, '')
                                        });
                                        resolveFile();
                                    });
                                });
                            }
                            else {
                                return FileUtils.flattern(entry).then(result => {
                                    files.push(...result);
                                });
                            }
                        })));
                        traverse();
                    }
                });
            })();
        });
    }
    static toFileArray(fileList) {
        let                  result = [];
        if (fileList && fileList.length > 0) {
            for (let                  i = 0; i < fileList.length; i++) {
                result.push(fileList[i]);
            }
        }
        return result;
    }
}

const MOMENT_DATE_FORMATS = {
    parse: {
        dateInput: 'DD/MM/YYYY'
    },
    display: {
        dateInput: 'DD/MM/YYYY',
        monthYearLabel: 'MMMM Y',
        dateA11yLabel: 'LL',
        monthYearA11yLabel: 'MMMM Y'
    }
};
const dateNames = [];
for (let                  date = 1; date <= 31; date++) {
    dateNames.push(String(date));
}

const dateNames$1 = [];
for (let                  date = 1; date <= 31; date++) {
    dateNames$1.push(String(date));
}
class MomentDateAdapter extends DateAdapter {
    constructor() {
        super(...arguments);
        this.localeData = moment.localeData();
    }
    getYear(date) {
        return date.year();
    }
    getMonth(date) {
        return date.month();
    }
    getDate(date) {
        return date.date();
    }
    getDayOfWeek(date) {
        return date.day();
    }
    getMonthNames(style$$1) {
        switch (style$$1) {
            case 'long':
                return this.localeData.months();
            case 'short':
                return this.localeData.monthsShort();
            case 'narrow':
                return this.localeData.monthsShort().map(month => month[0]);
            default:
                return;
        }
    }
    getDateNames() {
        return dateNames$1;
    }
    getDayOfWeekNames(style$$1) {
        switch (style$$1) {
            case 'long':
                return this.localeData.weekdays();
            case 'short':
                return this.localeData.weekdaysShort();
            case 'narrow':
                return this.localeData.weekdaysShort();
            default:
                return;
        }
    }
    getYearName(date) {
        return String(date.year());
    }
    getFirstDayOfWeek() {
        return this.localeData.firstDayOfWeek();
    }
    getNumDaysInMonth(date) {
        return date.daysInMonth();
    }
    clone(date) {
        return date.clone();
    }
    createDate(year, month, date) {
        return moment([year, month, date]);
    }
    today() {
        return moment();
    }
    parse(value, parseFormat) {
        let                  m = moment(value, parseFormat, true);
        if (!m.isValid()) {
            m = moment(value, this.overrideDisplyaFormat);
        }
        if (m.isValid()) {
            if (m.year() === 2001 && value.indexOf('2001') === -1) {
                const                  currentYear = new Date().getFullYear();
                m.set('year', currentYear);
                if (m.isAfter(moment())) {
                    m.set('year', currentYear - 1);
                }
            }
            return m;
        }
        else {
            return null;
        }
    }
    format(date, displayFormat) {
        displayFormat = this.overrideDisplyaFormat ? this.overrideDisplyaFormat : displayFormat;
        if (date && date.format) {
            return date.format(displayFormat);
        }
        else {
            return '';
        }
    }
    addCalendarYears(date, years) {
        return date.clone().add(years, 'y');
    }
    addCalendarMonths(date, months) {
        return date.clone().add(months, 'M');
    }
    addCalendarDays(date, days) {
        return date.clone().add(days, 'd');
    }
    getISODateString(date) {
        return date.toISOString();
    }
    setLocale(locale) {
        this.localeData = moment.localeData(locale);
    }
    compareDate(first, second) {
        return first.diff(second, 'seconds', true);
    }
    sameDate(first, second) {
        if (first == null) {
            return second == null;
        }
        else if (isMoment(first)) {
            return first.isSame(second);
        }
        else {
            const                  isSame = super.sameDate(first, second);
            return isSame;
        }
    }
    clampDate(date, min, max) {
        if (min && date.isBefore(min)) {
            return min;
        }
        else if (max && date.isAfter(max)) {
            return max;
        }
        else {
            return date;
        }
    }
    isDateInstance(date) {
        let                  isValidDateInstance = false;
        if (date) {
            isValidDateInstance = date._isAMomentObject;
        }
        return isValidDateInstance;
    }
    isValid(date) {
        return date.isValid();
    }
    toIso8601(date) {
        return this.clone(date).format();
    }
    fromIso8601(iso8601String) {
        let                  d = moment(iso8601String, moment.ISO_8601).locale(this.locale);
        return this.isValid(d) ? d : null;
    }
    invalid() {
        return moment.invalid();
    }
}

class ObjectDataRow {
    constructor(obj, isSelected = false) {
        this.obj = obj;
        this.isSelected = isSelected;
        if (!obj) {
            throw new Error('Object source not found');
        }
    }
    getValue(key) {
        return ObjectUtils.getValue(this.obj, key);
    }
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
}

class ObjectDataColumn {
    constructor(obj) {
        this.key = obj.key;
        this.type = obj.type || 'text';
        this.format = obj.format;
        this.sortable = obj.sortable;
        this.title = obj.title;
        this.srTitle = obj.srTitle;
        this.cssClass = obj.cssClass;
        this.template = obj.template;
    }
}

class ObjectDataTableAdapter {
    static generateSchema(data) {
        let                  schema = [];
        if (data && data.length) {
            let                  rowToExaminate = data[0];
            if (typeof rowToExaminate === 'object') {
                for (let                  key in rowToExaminate) {
                    if (rowToExaminate.hasOwnProperty(key)) {
                        schema.push({
                            type: 'text',
                            key: key,
                            title: key,
                            sortable: false
                        });
                    }
                }
            }
        }
        return schema;
    }
    constructor(data = [], schema = []) {
        this._rows = [];
        this._columns = [];
        if (data && data.length > 0) {
            this._rows = data.map(item => {
                return new ObjectDataRow(item);
            });
        }
        if (schema && schema.length > 0) {
            this._columns = schema.map(item => {
                return new ObjectDataColumn(item);
            });
            let                  sortable = this._columns.filter(c => c.sortable);
            if (sortable.length > 0) {
                this.sort(sortable[0].key, 'asc');
            }
        }
    }
    getRows() {
        return this._rows;
    }
    setRows(rows) {
        this._rows = rows || [];
        this.sort();
    }
    getColumns() {
        return this._columns;
    }
    setColumns(columns) {
        this._columns = columns || [];
    }
    getValue(row, col) {
        if (!row) {
            throw new Error('Row not found');
        }
        if (!col) {
            throw new Error('Column not found');
        }
        let                  value = row.getValue(col.key);
        if (col.type === 'date') {
            try {
                return this.formatDate(col, value);
            }
            catch (                 err) {
                console.error(`Error parsing date ${value} to format ${col.format}`);
            }
        }
        if (col.type === 'icon') {
            const                  icon = row.getValue(col.key);
            return icon;
        }
        return value;
    }
    formatDate(col, value) {
        if (col.type === 'date') {
            const                  format = col.format || 'medium';
            if (format === 'timeAgo') {
                const                  timeAgoPipe = new TimeAgoPipe();
                return timeAgoPipe.transform(value);
            }
            else {
                const                  datePipe = new DatePipe('en-US');
                return datePipe.transform(value, format);
            }
        }
        return value;
    }
    getSorting() {
        return this._sorting;
    }
    setSorting(sorting) {
        this._sorting = sorting;
        if (sorting && sorting.key) {
            this._rows.sort((a, b) => {
                let                  left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                let                  right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right)
                    : right.localeCompare(left);
            });
        }
    }
    sort(key, direction) {
        let                  sorting = this._sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
}

class DataCellEventModel {
    constructor(row, col, actions) {
        this.row = row;
        this.col = col;
        this.actions = actions || [];
    }
}
class DataCellEvent extends BaseEvent {
    constructor(row, col, actions) {
        super();
        this.value = new DataCellEventModel(row, col, actions);
    }
}

class DataRowActionModel {
    constructor(row, action) {
        this.row = row;
        this.action = action;
    }
}
class DataRowActionEvent extends BaseEvent {
    get args() {
        return this.value;
    }
    constructor(row, action) {
        super();
        this.value = new DataRowActionModel(row, action);
    }
}

class DataTableCellComponent {
    ngOnInit() {
        if (!this.value && this.column && this.column.key && this.row && this.data) {
            this.value = this.data.getValue(this.row, this.column);
            if (!this.tooltip) {
                this.tooltip = this.value;
            }
        }
    }
}
DataTableCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span [title]="tooltip" class="adf-datatable-cell-value">{{value}}</span>
        </ng-container>`,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-cell' }
            },] },
];
DataTableCellComponent.ctorParameters = () => [];
DataTableCellComponent.propDecorators = {
    "data": [{ type: Input },],
    "column": [{ type: Input },],
    "row": [{ type: Input },],
    "value": [{ type: Input },],
    "tooltip": [{ type: Input },],
};

const DisplayMode = {
    List: 'list',
    Gallery: 'gallery',
};
class DataTableComponent {
    constructor(elementRef, differs, thumbnailService) {
        this.elementRef = elementRef;
        this.thumbnailService = thumbnailService;
        this.display = DisplayMode.List;
        this.rows = [];
        this.selectionMode = 'single';
        this.multiselect = false;
        this.actions = false;
        this.actionsPosition = 'right';
        this.contextMenu = false;
        this.allowDropFiles = false;
        this.rowStyleClass = '';
        this.showHeader = true;
        this.rowClick = new EventEmitter();
        this.rowDblClick = new EventEmitter();
        this.showRowContextMenu = new EventEmitter();
        this.showRowActionsMenu = new EventEmitter();
        this.executeRowAction = new EventEmitter();
        this.loading = false;
        this.noPermission = false;
        this.isSelectAllChecked = false;
        this.selection = new Array();
        this.schema = [];
        this.rowMenuCache = {};
        if (differs) {
            this.differ = differs.find([]).create(null);
        }
        this.click$ = new Observable(observer => this.clickObserver = observer).share();
    }
    ngAfterContentInit() {
        this.setTableSchema();
    }
    ngOnChanges(changes) {
        this.initAndSubscribeClickStream();
        if (this.isPropertyChanged(changes['data'])) {
            if (this.isTableEmpty()) {
                this.initTable();
            }
            else {
                this.data = changes['data'].currentValue;
            }
            return;
        }
        if (this.isPropertyChanged(changes['rows'])) {
            if (this.isTableEmpty()) {
                this.initTable();
            }
            else {
                this.setTableRows(changes['rows'].currentValue);
            }
            return;
        }
        if (changes["selectionMode"] && !changes["selectionMode"].isFirstChange()) {
            this.resetSelection();
            this.emitRowSelectionEvent('row-unselect', null);
        }
    }
    ngDoCheck() {
        let                  changes = this.differ.diff(this.rows);
        if (changes) {
            this.setTableRows(this.rows);
        }
    }
    isPropertyChanged(property) {
        return property && property.currentValue ? true : false;
    }
    convertToRowsData(rows) {
        return rows.map(row => new ObjectDataRow(row));
    }
    initAndSubscribeClickStream() {
        this.unsubscribeClickStream();
        let                  singleClickStream = this.click$
            .buffer(this.click$.debounceTime(250))
            .map(list => list)
            .filter(x => x.length === 1);
        this.singleClickStreamSub = singleClickStream.subscribe((obj) => {
            let                  event = obj[0];
            this.rowClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-click', {
                    detail: event,
                    bubbles: true
                }));
            }
        });
        let                  multiClickStream = this.click$
            .buffer(this.click$.debounceTime(250))
            .map(list => list)
            .filter(x => x.length >= 2);
        this.multiClickStreamSub = multiClickStream.subscribe((obj) => {
            let                  event = obj[0];
            this.rowDblClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
                    detail: event,
                    bubbles: true
                }));
            }
        });
    }
    unsubscribeClickStream() {
        if (this.singleClickStreamSub) {
            this.singleClickStreamSub.unsubscribe();
        }
        if (this.multiClickStreamSub) {
            this.multiClickStreamSub.unsubscribe();
        }
    }
    initTable() {
        this.data = new ObjectDataTableAdapter(this.rows, this.schema);
        this.rowMenuCache = {};
    }
    isTableEmpty() {
        return this.data === undefined || this.data === null;
    }
    setTableRows(rows) {
        if (this.data) {
            this.data.setRows(this.convertToRowsData(rows));
        }
    }
    setTableSchema() {
        if (this.columnList && this.columnList.columns) {
            this.schema = this.columnList.columns.map(c =>                  (c));
        }
        if (this.data && this.schema && this.schema.length > 0) {
            this.data.setColumns(this.schema);
        }
    }
    onRowClick(row, e) {
        if (e) {
            e.preventDefault();
        }
        if (row) {
            this.handleRowSelection(row, e);
            const                  dataRowEvent = new DataRowEvent(row, e, this);
            this.clickObserver.next(dataRowEvent);
        }
    }
    onEnterKeyPressed(row, e) {
        if (row) {
            this.handleRowSelection(row, e);
        }
    }
    handleRowSelection(row, e) {
        if (this.data) {
            if (this.isSingleSelectionMode()) {
                this.resetSelection();
                this.selectRow(row, true);
                this.emitRowSelectionEvent('row-select', row);
            }
            if (this.isMultiSelectionMode()) {
                const                  modifier = e && (e.metaKey || e.ctrlKey);
                const                  newValue = modifier ? !row.isSelected : true;
                const                  domEventName = newValue ? 'row-select' : 'row-unselect';
                if (!modifier) {
                    this.resetSelection();
                }
                this.selectRow(row, newValue);
                this.emitRowSelectionEvent(domEventName, row);
            }
        }
    }
    resetSelection() {
        if (this.data) {
            const                  rows = this.data.getRows();
            if (rows && rows.length > 0) {
                rows.forEach(r => r.isSelected = false);
            }
            this.selection.splice(0);
        }
        this.isSelectAllChecked = false;
    }
    onRowDblClick(row, e) {
        if (e) {
            e.preventDefault();
        }
        let                  dataRowEvent = new DataRowEvent(row, e, this);
        this.clickObserver.next(dataRowEvent);
    }
    onRowKeyUp(row, e) {
        const                  event = new CustomEvent('row-keyup', {
            detail: {
                row: row,
                keyboardEvent: e,
                sender: this
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(event);
        if (event.defaultPrevented) {
            e.preventDefault();
        }
        else {
            if (e.key === 'Enter') {
                this.onKeyboardNavigate(row, e);
            }
        }
    }
    onKeyboardNavigate(row, e) {
        if (e) {
            e.preventDefault();
        }
        const                  event = new DataRowEvent(row, e, this);
        this.rowDblClick.emit(event);
        this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
            detail: event,
            bubbles: true
        }));
    }
    onColumnHeaderClick(column) {
        if (column && column.sortable) {
            let                  current = this.data.getSorting();
            let                  newDirection = 'asc';
            if (current && column.key === current.key) {
                newDirection = current.direction === 'asc' ? 'desc' : 'asc';
            }
            this.data.setSorting(new DataSorting(column.key, newDirection));
            this.emitSortingChangedEvent(column.key, newDirection);
        }
    }
    onSelectAllClick(e) {
        this.isSelectAllChecked = e.checked;
        if (this.multiselect) {
            let                  rows = this.data.getRows();
            if (rows && rows.length > 0) {
                for (let                  i = 0; i < rows.length; i++) {
                    this.selectRow(rows[i], e.checked);
                }
            }
            const                  domEventName = e.checked ? 'row-select' : 'row-unselect';
            const                  row = this.selection.length > 0 ? this.selection[0] : null;
            this.emitRowSelectionEvent(domEventName, row);
        }
    }
    onCheckboxChange(row, event) {
        const                  newValue = event.checked;
        this.selectRow(row, newValue);
        const                  domEventName = newValue ? 'row-select' : 'row-unselect';
        this.emitRowSelectionEvent(domEventName, row);
    }
    onImageLoadingError(event, mimeType) {
        if (event) {
            let                  element =                  (event.target);
            if (this.fallbackThumbnail) {
                element.src = this.fallbackThumbnail;
            }
            else {
                element.src = this.thumbnailService.getMimeTypeIcon(mimeType);
            }
        }
    }
    isIconValue(row, col) {
        if (row && col) {
            let                  value = row.getValue(col.key);
            return value && value.startsWith('material-icons://');
        }
        return false;
    }
    asIconValue(row, col) {
        if (this.isIconValue(row, col)) {
            let                  value = row.getValue(col.key) || '';
            return value.replace('material-icons://', '');
        }
        return null;
    }
    iconAltTextKey(value) {
        return value ? 'ICONS.' + value.substring(value.lastIndexOf('/') + 1).replace(/\.[a-z]+/, '') : '';
    }
    isColumnSorted(col, direction) {
        if (col && direction) {
            let                  sorting = this.data.getSorting();
            return sorting && sorting.key === col.key && sorting.direction === direction;
        }
        return false;
    }
    getContextMenuActions(row, col) {
        let                  event = new DataCellEvent(row, col, []);
        this.showRowContextMenu.emit(event);
        return event.value.actions;
    }
    getRowActions(row, col) {
        const                  id = row.getValue('id');
        if (!this.rowMenuCache[id]) {
            let                  event = new DataCellEvent(row, col, []);
            this.showRowActionsMenu.emit(event);
            this.rowMenuCache[id] = event.value.actions;
        }
        return this.rowMenuCache[id];
    }
    onExecuteRowAction(row, action) {
        if (action.disabled || action.disabled) {
            event.stopPropagation();
        }
        else {
            this.executeRowAction.emit(new DataRowActionEvent(row, action));
        }
    }
    rowAllowsDrop(row) {
        return row.isDropTarget === true;
    }
    hasSelectionMode() {
        return this.isSingleSelectionMode() || this.isMultiSelectionMode();
    }
    isSingleSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'single';
    }
    isMultiSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'multiple';
    }
    getRowStyle(row) {
        row.cssClass = row.cssClass ? row.cssClass : '';
        this.rowStyleClass = this.rowStyleClass ? this.rowStyleClass : '';
        return `${row.cssClass} ${this.rowStyleClass}`;
    }
    getFilename(row) {
        return row.getValue('name');
    }
    getSortingKey() {
        if (this.data.getSorting()) {
            return this.data.getSorting().key;
        }
    }
    selectRow(row, value) {
        if (row) {
            row.isSelected = value;
            const                  idx = this.selection.indexOf(row);
            if (value) {
                if (idx < 0) {
                    this.selection.push(row);
                }
            }
            else {
                if (idx > -1) {
                    this.selection.splice(idx, 1);
                }
            }
        }
    }
    getCellTooltip(row, col) {
        if (row && col && col.formatTooltip) {
            const                  result = col.formatTooltip(row, col);
            if (result) {
                return result;
            }
        }
        return null;
    }
    getSortableColumns() {
        return this.data.getColumns().filter((currentColum) => {
            return currentColum.sortable === true;
        });
    }
    isEmpty() {
        return this.data.getRows().length === 0;
    }
    isHeaderVisible() {
        return this.showHeader && !this.loading && !this.isEmpty();
    }
    emitRowSelectionEvent(name, row) {
        const                  domEvent = new CustomEvent(name, {
            detail: {
                row: row,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    emitSortingChangedEvent(key, direction) {
        const                  domEvent = new CustomEvent('sorting-changed', {
            detail: {
                key,
                direction
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
}
DataTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable',
                styles: [``],
                template: `<div
    *ngIf="data" class="full-width"
    [class.adf-data-table-card]="display === 'gallery'"
    [class.adf-data-table]="display === 'list'">
    <div *ngIf="isHeaderVisible()" class="adf-datatable-header">
        <div class="adf-datatable-row" *ngIf="display === 'list'">
            <!-- Actions (left) -->
            <div *ngIf="actions && actionsPosition === 'left'" class="actions-column adf-datatable-table-cell-header">
                <span class="sr-only">Actions</span>
            </div>
            <!-- Columns -->
            <div *ngIf="multiselect" class="adf-datatable-table-cell-header">
                <mat-checkbox [checked]="isSelectAllChecked" (change)="onSelectAllClick($event)"></mat-checkbox>
            </div>
            <div class="adf-data-table-cell--{{col.type || 'text'}} {{col.cssClass}} adf-datatable-table-cell-header"
                 *ngFor="let col of data.getColumns()"
                 [class.sortable]="col.sortable"
                 [attr.data-automation-id]="'auto_id_' + col.key"
                 [class.adf-data-table__header--sorted-asc]="isColumnSorted(col, 'asc')"
                 [class.adf-data-table__header--sorted-desc]="isColumnSorted(col, 'desc')"
                 (click)="onColumnHeaderClick(col)"
                 (keyup.enter)="onColumnHeaderClick(col)"
                 role="button"
                 tabindex="0"
                 title="{{ col.title | translate }}">
                <span *ngIf="col.srTitle" class="sr-only">{{ col.srTitle | translate }}</span>
                <span *ngIf="col.title">{{ col.title | translate}}</span>
            </div>
            <!-- Actions (right) -->
            <div *ngIf="actions && actionsPosition === 'right'" class="actions-column adf-datatable-table-cell-header">
                <span class="sr-only">Actions</span>
            </div>
        </div>
        <mat-form-field *ngIf="display === 'gallery'">
            <mat-select [value]="getSortingKey()">
                <mat-option *ngFor="let col of getSortableColumns()"
                            [value]="col.key"
                            (click)="onColumnHeaderClick(col)"
                            (keyup.enter)="onColumnHeaderClick(col)">
                    {{ col.title | translate}}
                </mat-option>
            </mat-select>
        </mat-form-field>

    </div>

    <div class="adf-datatable-body">
        <ng-container *ngIf="!loading && !noPermission">
            <div *ngFor="let row of data.getRows(); let idx = index"
                 class="adf-datatable-row"
                 role="button"
                 [class.is-selected]="row.isSelected"
                 [adf-upload]="allowDropFiles && rowAllowsDrop(row)" [adf-upload-data]="row"
                 [ngStyle]="rowStyle"
                 [ngClass]="getRowStyle(row)"
                 (keyup)="onRowKeyUp(row, $event)">

                <!-- Actions (left) -->
                <div *ngIf="actions && actionsPosition === 'left'" class="adf-datatable-table-cell">
                    <button mat-icon-button [matMenuTriggerFor]="menu"
                            [attr.id]="'action_menu_left_' + idx"
                            [attr.data-automation-id]="'action_menu_' + idx">
                        <mat-icon>more_vert</mat-icon>
                    </button>
                    <mat-menu #menu="matMenu">
                        <button mat-menu-item *ngFor="let action of getRowActions(row)"
                                [attr.data-automation-id]="action.title"
                                [disabled]="action.disabled"
                                (click)="onExecuteRowAction(row, action)">
                            <mat-icon *ngIf="action.icon">{{ action.icon }}</mat-icon>
                            <span>{{ action.title | translate }}</span>
                        </button>
                    </mat-menu>
                </div>

                <div *ngIf="multiselect" class="adf-datatable-table-cell adf-datatable-table-checkbox">
                    <mat-checkbox
                        [checked]="row.isSelected"
                        (change)="onCheckboxChange(row, $event)">
                    </mat-checkbox>
                </div>
                <div *ngFor="let col of data.getColumns()"
                     class="adf-data-table-cell adf-datatable-table-cell adf-data-table-cell--{{col.type || 'text'}} {{col.cssClass}}"
                     [attr.title]="col.title | translate"
                     [attr.filename]="getFilename(row)"
                     tabindex="0"
                     (click)="onRowClick(row, $event)"
                     (keydown.enter)="onEnterKeyPressed(row, $event)"
                     [context-menu]="getContextMenuActions(row, col)"
                     [context-menu-enabled]="contextMenu">
                    <div *ngIf="!col.template" class="cell-container">
                        <ng-container [ngSwitch]="col.type">
                            <div *ngSwitchCase="'image'" class="cell-value">
                                <mat-icon *ngIf="isIconValue(row, col)">{{ asIconValue(row, col) }}</mat-icon>
                                <mat-icon class="adf-datatable-selected"
                                          *ngIf="!isIconValue(row, col) && row.isSelected" svgIcon="selected">
                                </mat-icon>

                                <img *ngIf="!isIconValue(row, col) && !row.isSelected"
                                     alt="{{ iconAltTextKey(data.getValue(row, col)) | translate }}"
                                     src="{{ data.getValue(row, col) }}"
                                     (error)="onImageLoadingError($event, row.obj.entry.content.mimeType)">
                            </div>
                            <div *ngSwitchCase="'icon'" class="cell-value">
                                <span class="sr-only">{{ iconAltTextKey(data.getValue(row, col)) | translate }}</span>
                                <mat-icon>{{ data.getValue(row, col) }}</mat-icon>
                            </div>
                            <div *ngSwitchCase="'date'" class="cell-value"
                                 [attr.data-automation-id]="'date_' + data.getValue(row, col)">
                                <adf-date-cell
                                    [data]="data"
                                    [column]="col"
                                    [row]="row"
                                    [tooltip]="getCellTooltip(row, col)">
                                </adf-date-cell>
                            </div>
                            <div *ngSwitchCase="'location'" class="cell-value"
                                 [attr.data-automation-id]="'location' + data.getValue(row, col)">
                                <adf-location-cell
                                    [data]="data"
                                    [column]="col"
                                    [row]="row"
                                    [tooltip]="getCellTooltip(row, col)">
                                </adf-location-cell>
                            </div>
                            <div *ngSwitchCase="'fileSize'" class="cell-value"
                                 [attr.data-automation-id]="'fileSize_' + data.getValue(row, col)">
                                <adf-filesize-cell
                                    [data]="data"
                                    [column]="col"
                                    [row]="row"
                                    [tooltip]="getCellTooltip(row, col)">
                                </adf-filesize-cell>
                            </div>
                            <div *ngSwitchCase="'text'" class="cell-value"
                                 [attr.data-automation-id]="'text_' + data.getValue(row, col)">
                                <adf-datatable-cell
                                    [data]="data"
                                    [column]="col"
                                    [row]="row"
                                    [tooltip]="getCellTooltip(row, col)">
                                </adf-datatable-cell>
                            </div>
                            <span *ngSwitchDefault class="cell-value">
                    <!-- empty cell for unknown column type -->
                    </span>
                        </ng-container>
                    </div>
                    <div *ngIf="col.template" class="cell-container">
                        <ng-container
                            [ngTemplateOutlet]="col.template"
                            [ngTemplateOutletContext]="{ $implicit: { data: data, row: row, col: col }, value: data.getValue(row, col) }">
                        </ng-container>
                    </div>
                </div>

                <!-- Actions (right) -->
                <div *ngIf="actions && actionsPosition === 'right'"
                     class="adf-datatable-table-cell alfresco-datatable__actions-cell">
                    <button mat-icon-button [matMenuTriggerFor]="menu"
                            [attr.id]="'action_menu_right_' + idx"
                            [attr.data-automation-id]="'action_menu_' + idx">
                        <mat-icon>more_vert</mat-icon>
                    </button>
                    <mat-menu #menu="matMenu">
                        <button mat-menu-item *ngFor="let action of getRowActions(row)"
                                [attr.data-automation-id]="action.title"
                                [disabled]="action.disabled"
                                (click)="onExecuteRowAction(row, action)">
                            <mat-icon *ngIf="action.icon">{{ action.icon }}</mat-icon>
                            <span>{{ action.title | translate }}</span>
                        </button>
                    </mat-menu>
                </div>

            </div>
            <div *ngIf="isEmpty()"
                 [class.adf-datatable-row]="display === 'list'"
                 [class.adf-data-table-card-empty]="display === 'gallery'">
                <div class="adf-no-content-container adf-datatable-table-cell">
                    <ng-template *ngIf="noContentTemplate"
                                 ngFor [ngForOf]="[data]"
                                 [ngForTemplate]="noContentTemplate">
                    </ng-template>
                    <ng-content select="adf-empty-list"></ng-content>
                </div>
            </div>
        </ng-container>
        <div *ngIf="!loading && noPermission"
             [class.adf-datatable-row]="display === 'list'"
             [class.adf-data-table-card-permissions]="display === 'gallery'"
             class="adf-no-permission__row">
            <div class="adf-no-permission__cell adf-no-content-container adf-datatable-table-cell">
                <ng-template *ngIf="noPermissionTemplate"
                             ngFor [ngForOf]="[data]"
                             [ngForTemplate]="noPermissionTemplate">
                </ng-template>
            </div>
        </div>
        <div *ngIf="loading"
             [class.adf-datatable-row]="display === 'list'"
             [class.adf-data-table-card-loading]="display === 'gallery'">
            <div class="adf-datatable-table-cell" >
                <ng-template *ngIf="loadingTemplate"
                             ngFor [ngForOf]="[data]"
                             [ngForTemplate]="loadingTemplate">
                </ng-template>
            </div>
        </div>
    </div>
</div>
`,
                encapsulation: ViewEncapsulation.None
            },] },
];
DataTableComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: IterableDiffers, },
    { type: ThumbnailService, },
];
DataTableComponent.propDecorators = {
    "columnList": [{ type: ContentChild, args: [DataColumnListComponent,] },],
    "data": [{ type: Input },],
    "display": [{ type: Input },],
    "rows": [{ type: Input },],
    "selectionMode": [{ type: Input },],
    "multiselect": [{ type: Input },],
    "actions": [{ type: Input },],
    "actionsPosition": [{ type: Input },],
    "fallbackThumbnail": [{ type: Input },],
    "contextMenu": [{ type: Input },],
    "allowDropFiles": [{ type: Input },],
    "rowStyle": [{ type: Input },],
    "rowStyleClass": [{ type: Input },],
    "showHeader": [{ type: Input },],
    "rowClick": [{ type: Output },],
    "rowDblClick": [{ type: Output },],
    "showRowContextMenu": [{ type: Output },],
    "showRowActionsMenu": [{ type: Output },],
    "executeRowAction": [{ type: Output },],
    "loading": [{ type: Input },],
    "noPermission": [{ type: Input },],
};

class DateCellComponent extends DataTableCellComponent {
}
DateCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span [title]="tooltip">{{value}}</span>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-date-cell' }
            },] },
];
DateCellComponent.ctorParameters = () => [];

class EmptyListComponent {
}
EmptyListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-list',
                styles: [`.adf-empty-list_template{text-align:center;margin-top:20px;margin-bottom:20px}`],
                template: `<div class="adf-empty-list_template">
    <ng-content select="[adf-empty-list-header]"></ng-content>
    <ng-content select="[adf-empty-list-body]"></ng-content>
    <ng-content select="[adf-empty-list-footer]"></ng-content>
    <ng-content></ng-content>
</div>`,
                encapsulation: ViewEncapsulation.None
            },] },
];
EmptyListComponent.ctorParameters = () => [];
class EmptyListHeaderDirective {
}
EmptyListHeaderDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-header]' },] },
];
EmptyListHeaderDirective.ctorParameters = () => [];
class EmptyListBodyDirective {
}
EmptyListBodyDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-body]' },] },
];
EmptyListBodyDirective.ctorParameters = () => [];
class EmptyListFooterDirective {
}
EmptyListFooterDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-footer]' },] },
];
EmptyListFooterDirective.ctorParameters = () => [];

class FileSizeCellComponent extends DataTableCellComponent {
}
FileSizeCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-filesize-cell',
                template: `
        <ng-container>
            <span [title]="tooltip">{{ value | adfFileSize }}</span>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-filesize-cell' }
            },] },
];
FileSizeCellComponent.ctorParameters = () => [];

class LocationCellComponent extends DataTableCellComponent {
    constructor() {
        super(...arguments);
        this.displayText = '';
    }
    ngOnInit() {
        if (!this.value && this.column && this.column.key && this.row && this.data) {
            const                  path = this.data.getValue(this.row, this.column);
            if (path && path.name && path.elements) {
                this.value = path;
                this.displayText = path.name.split('/').pop();
                if (!this.tooltip) {
                    this.tooltip = path.name;
                }
                const                  parent = path.elements[path.elements.length - 1];
                this.link = [this.column.format, parent.id];
            }
        }
    }
}
LocationCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-location-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <a href="" [title]="tooltip" [routerLink]="link">
                {{ displayText }}
            </a>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-location-cell' }
            },] },
];
LocationCellComponent.ctorParameters = () => [];
LocationCellComponent.propDecorators = {
    "link": [{ type: Input },],
    "displayText": [{ type: Input },],
};

class LoadingContentTemplateDirective {
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.loadingTemplate = this.template;
        }
    }
}
LoadingContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'loading-content-template'
            },] },
];
LoadingContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent, },
];
LoadingContentTemplateDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class NoContentTemplateDirective {
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noContentTemplate = this.template;
        }
    }
}
NoContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-content-template'
            },] },
];
NoContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent, },
];
NoContentTemplateDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class NoPermissionTemplateDirective {
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noPermissionTemplate = this.template;
        }
    }
}
NoPermissionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-permission-template'
            },] },
];
NoPermissionTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent, },
];
NoPermissionTemplateDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class ContextMenuService {
    constructor() {
        this.show = new Subject();
    }
}
ContextMenuService.decorators = [
    { type: Injectable },
];
ContextMenuService.ctorParameters = () => [];

class ContextMenuHolderComponent {
    constructor(viewport, overlayContainer, contextMenuService, renderer) {
        this.viewport = viewport;
        this.overlayContainer = overlayContainer;
        this.contextMenuService = contextMenuService;
        this.renderer = renderer;
        this.links = [];
        this.mouseLocation = { left: 0, top: 0 };
        this.menuElement = null;
        this.showIcons = false;
    }
    onShowContextMenu(event) {
        if (event) {
            event.preventDefault();
        }
    }
    onResize(event) {
        if (this.mdMenuElement) {
            this.setPositionAfterCDKrecalculation();
        }
    }
    ngOnInit() {
        this.contextSubscription = this.contextMenuService.show.subscribe(e => this.showMenu(e.event, e.obj));
        this.openSubscription = this.menuTrigger.onMenuOpen.subscribe(() => {
            const                  container = this.overlayContainer.getContainerElement();
            if (container) {
                this.contextMenuListenerFn = this.renderer.listen(container, 'contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            this.menuElement = this.getContextMenuElement();
        });
        this.closeSubscription = this.menuTrigger.onMenuClose.subscribe(() => {
            this.menuElement = null;
            if (this.contextMenuListenerFn) {
                this.contextMenuListenerFn();
            }
        });
    }
    ngOnDestroy() {
        if (this.contextMenuListenerFn) {
            this.contextMenuListenerFn();
        }
        this.contextSubscription.unsubscribe();
        this.openSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
        this.menuElement = null;
    }
    onMenuItemClick(event, menuItem) {
        if (menuItem && menuItem.model && menuItem.model.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
        }
        menuItem.subject.next(menuItem);
    }
    showMenu(e, links) {
        this.links = links;
        if (e) {
            this.mouseLocation = {
                left: e.clientX,
                top: e.clientY
            };
        }
        this.menuTrigger.openMenu();
        if (this.mdMenuElement) {
            this.setPositionAfterCDKrecalculation();
        }
    }
    setPositionAfterCDKrecalculation() {
        setTimeout(() => {
            this.setPosition();
        }, 0);
    }
    get mdMenuElement() {
        return this.menuElement;
    }
    locationCss() {
        return {
            left: this.mouseLocation.left + 'px',
            top: this.mouseLocation.top + 'px'
        };
    }
    setPosition() {
        if (this.mdMenuElement.clientWidth + this.mouseLocation.left > this.viewport.getViewportRect().width) {
            this.menuTrigger.menu.xPosition = 'before';
            this.mdMenuElement.parentElement.style.left = this.mouseLocation.left - this.mdMenuElement.clientWidth + 'px';
        }
        else {
            this.menuTrigger.menu.xPosition = 'after';
            this.mdMenuElement.parentElement.style.left = this.locationCss().left;
        }
        if (this.mdMenuElement.clientHeight + this.mouseLocation.top > this.viewport.getViewportRect().height) {
            this.menuTrigger.menu.yPosition = 'above';
            this.mdMenuElement.parentElement.style.top = this.mouseLocation.top - this.mdMenuElement.clientHeight + 'px';
        }
        else {
            this.menuTrigger.menu.yPosition = 'below';
            this.mdMenuElement.parentElement.style.top = this.locationCss().top;
        }
    }
    getContextMenuElement() {
        return this.overlayContainer.getContainerElement().querySelector('.context-menu');
    }
}
ContextMenuHolderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-context-menu-holder, context-menu-holder',
                template: `
        <button mat-button [matMenuTriggerFor]="contextMenu"></button>
        <mat-menu #contextMenu="matMenu" class="context-menu">
            <button
                *ngFor="let link of links"
                mat-menu-item
                (click)="onMenuItemClick($event, link)"
                [attr.disabled]="link.model?.disabled || undefined">
                <mat-icon *ngIf="showIcons && link.model?.icon">
                    {{ link.model?.icon }}
                </mat-icon>
                    {{ (link.title || link.model?.title) | translate}}
            </button>
        </mat-menu>
    `
            },] },
];
ContextMenuHolderComponent.ctorParameters = () => [
    { type: ViewportRuler, },
    { type: OverlayContainer, },
    { type: ContextMenuService, },
    { type: Renderer2, },
];
ContextMenuHolderComponent.propDecorators = {
    "showIcons": [{ type: Input },],
    "menuTrigger": [{ type: ViewChild, args: [MatMenuTrigger,] },],
    "onShowContextMenu": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],
    "onResize": [{ type: HostListener, args: ['window:resize', ['$event'],] },],
};

class ContextMenuDirective {
    constructor(_contextMenuService) {
        this._contextMenuService = _contextMenuService;
        this.enabled = false;
    }
    onShowContextMenu(event) {
        if (this.enabled) {
            if (event) {
                event.preventDefault();
            }
            if (this.links && this.links.length > 0) {
                if (this._contextMenuService) {
                    this._contextMenuService.show.next({ event: event, obj: this.links });
                }
            }
        }
    }
}
ContextMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-context-menu], [context-menu]'
            },] },
];
ContextMenuDirective.ctorParameters = () => [
    { type: ContextMenuService, },
];
ContextMenuDirective.propDecorators = {
    "links": [{ type: Input, args: ['context-menu',] },],
    "enabled": [{ type: Input, args: ['context-menu-enabled',] },],
    "onShowContextMenu": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],
};

class ContextMenuModule {
}
ContextMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    ContextMenuHolderComponent,
                    ContextMenuDirective
                ],
                exports: [
                    ContextMenuHolderComponent,
                    ContextMenuDirective
                ],
                providers: [
                    ContextMenuService
                ]
            },] },
];
ContextMenuModule.ctorParameters = () => [];

class HighlightDirective {
    constructor(el, renderer, highlightTransformService) {
        this.el = el;
        this.renderer = renderer;
        this.highlightTransformService = highlightTransformService;
        this.selector = '';
        this.search = '';
        this.classToApply = 'adf-highlight';
    }
    highlight(search = this.search, selector = this.selector, classToApply = this.classToApply) {
        if (search && selector) {
            const                  elements = this.el.nativeElement.querySelectorAll(selector);
            elements.forEach((element) => {
                const                  result = this.highlightTransformService.highlight(element.innerHTML, search, classToApply);
                if (result.changed) {
                    this.renderer.setElementProperty(element, 'innerHTML', result.text);
                }
            });
        }
    }
}
HighlightDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-highlight]'
            },] },
];
HighlightDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
    { type: HighlightTransformService, },
];
HighlightDirective.propDecorators = {
    "selector": [{ type: Input, args: ['adf-highlight-selector',] },],
    "search": [{ type: Input, args: ['adf-highlight',] },],
    "classToApply": [{ type: Input, args: ['adf-highlight-class',] },],
};

class LogoutDirective {
    constructor(elementRef, renderer, router, auth) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.router = router;
        this.auth = auth;
    }
    ngOnInit() {
        if (this.elementRef.nativeElement) {
            this.renderer.listen(this.elementRef.nativeElement, 'click', (evt) => {
                evt.preventDefault();
                this.logout();
            });
        }
    }
    logout() {
        this.auth.logout().subscribe(() => this.redirectToLogin(), () => this.redirectToLogin());
    }
    redirectToLogin() {
        this.router.navigate(['/login']);
    }
}
LogoutDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-logout]'
            },] },
];
LogoutDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: Router, },
    { type: AuthenticationService, },
];

class NodeDeleteDirective {
    constructor(alfrescoApiService, translation, elementRef) {
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        this.elementRef = elementRef;
        this.permanent = false;
        this.delete = new EventEmitter();
    }
    onClick() {
        this.process(this.selection);
    }
    ngOnChanges() {
        if (!this.selection || (this.selection && this.selection.length === 0)) {
            this.setDisableAttribute(true);
        }
        else {
            if (!this.elementRef.nativeElement.hasAttribute('adf-node-permission')) {
                this.setDisableAttribute(false);
            }
        }
    }
    setDisableAttribute(disable) {
        this.elementRef.nativeElement.disabled = disable;
    }
    process(selection) {
        if (selection && selection.length) {
            const                  batch = this.getDeleteNodesBatch(selection);
            Observable.forkJoin(...batch)
                .subscribe((data) => {
                const                  processedItems = this.processStatus(data);
                this.delete.emit(this.getMessage(processedItems));
            });
        }
    }
    getDeleteNodesBatch(selection) {
        return selection.map((node) => this.deleteNode(node));
    }
    deleteNode(node) {
        const                  id = (                 (node.entry)).nodeId || node.entry.id;
        let                  promise;
        if (node.entry.hasOwnProperty('archivedAt')) {
            promise = this.alfrescoApiService.getInstance().nodes.purgeDeletedNode(id);
        }
        else {
            promise = this.alfrescoApiService.getInstance().nodes.deleteNode(id, { permanent: this.permanent });
        }
        return Observable.fromPromise(promise)
            .map(() => ({
            entry: node.entry,
            status: 1
        }))
            .catch((error) => {
            return Observable.of({
                entry: node.entry,
                status: 0
            });
        });
    }
    processStatus(data) {
        const                  deleteStatus = {
            success: [],
            failed: [],
            get someFailed() {
                return !!(this.failed.length);
            },
            get someSucceeded() {
                return !!(this.success.length);
            },
            get oneFailed() {
                return this.failed.length === 1;
            },
            get oneSucceeded() {
                return this.success.length === 1;
            },
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            }
        };
        return data.reduce((acc, next) => {
            if (next.status === 1) {
                acc.success.push(next);
            }
            else {
                acc.failed.push(next);
            }
            return acc;
        }, deleteStatus);
    }
    getMessage(status) {
        if (status.allFailed && !status.oneFailed) {
            return this.translation.instant('CORE.DELETE_NODE.ERROR_PLURAL', { number: status.failed.length });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PLURAL', { number: status.success.length });
        }
        if (status.someFailed && status.someSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PARTIAL_PLURAL', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.someFailed && status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PARTIAL_SINGULAR', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.oneFailed && !status.someSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: status.failed[0].entry.name });
        }
        if (status.oneSucceeded && !status.someFailed) {
            return this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: status.success[0].entry.name });
        }
    }
}
NodeDeleteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-delete]'
            },] },
];
NodeDeleteDirective.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: TranslationService, },
    { type: ElementRef, },
];
NodeDeleteDirective.propDecorators = {
    "selection": [{ type: Input, args: ['adf-delete',] },],
    "permanent": [{ type: Input },],
    "delete": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};

class NodeFavoriteDirective {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.favorites = [];
        this.selection = [];
        this.toggle = new EventEmitter();
    }
    onClick() {
        this.toggleFavorite();
    }
    ngOnChanges(changes) {
        if (!changes.selection.currentValue.length) {
            this.favorites = [];
            return;
        }
        this.markFavoritesNodes(changes.selection.currentValue);
    }
    toggleFavorite() {
        if (!this.favorites.length) {
            return;
        }
        const                  every = this.favorites.every((selected) => selected.entry.isFavorite);
        if (every) {
            const                  batch = this.favorites.map((selected) => {
                const                  id = selected.entry.nodeId || selected.entry.id;
                return Observable.fromPromise(this.alfrescoApiService.getInstance().core.favoritesApi.removeFavoriteSite('-me-', id));
            });
            Observable.forkJoin(batch).subscribe(() => {
                this.favorites.map(selected => selected.entry.isFavorite = false);
                this.toggle.emit();
            });
        }
        if (!every) {
            const                  notFavorite = this.favorites.filter((node) => !node.entry.isFavorite);
            const                  body = notFavorite.map((node) => this.createFavoriteBody(node));
            Observable.fromPromise(this.alfrescoApiService.getInstance().core.favoritesApi.addFavorite('-me-',                  (body)))
                .subscribe(() => {
                notFavorite.map(selected => selected.entry.isFavorite = true);
                this.toggle.emit();
            });
        }
    }
    markFavoritesNodes(selection) {
        if (selection.length <= this.favorites.length) {
            const                  newFavorites = this.reduce(this.favorites, selection);
            this.favorites = newFavorites;
        }
        const                  result = this.diff(selection, this.favorites);
        const                  batch = this.getProcessBatch(result);
        Observable.forkJoin(batch).subscribe((data) => this.favorites.push(...data));
    }
    hasFavorites() {
        if (this.favorites && !this.favorites.length) {
            return false;
        }
        return this.favorites.every((selected) => selected.entry.isFavorite);
    }
    getProcessBatch(selection) {
        return selection.map((selected) => this.getFavorite(selected));
    }
    getFavorite(selected) {
        const { name, isFile, isFolder } = selected.entry;
        const                  id = (                 (selected)).entry.nodeId || selected.entry.id;
        const                  promise = this.alfrescoApiService.getInstance()
            .core.favoritesApi.getFavorite('-me-', id);
        return Observable.from(promise)
            .map(() => ({
            entry: {
                id,
                isFolder,
                isFile,
                name,
                isFavorite: true
            }
        }))
            .catch(() => {
            return Observable.of({
                entry: {
                    id,
                    isFolder,
                    isFile,
                    name,
                    isFavorite: false
                }
            });
        });
    }
    createFavoriteBody(node) {
        const                  type = this.getNodeType(node);
        const                  id = node.entry.nodeId || node.entry.id;
        return {
            target: {
                [type]: {
                    guid: id
                }
            }
        };
    }
    getNodeType(node) {
        if (!node.entry.isFile && !node.entry.isFolder) {
            return 'file';
        }
        return node.entry.isFile ? 'file' : 'folder';
    }
    diff(list, patch) {
        const                  ids = patch.map(item => item.entry.id);
        return list.filter(item => ids.includes(item.entry.id) ? null : item);
    }
    reduce(patch, comparator) {
        const                  ids = comparator.map(item => item.entry.id);
        return patch.filter(item => ids.includes(item.entry.id) ? item : null);
    }
}
NodeFavoriteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-favorite]',
                exportAs: 'adfFavorite'
            },] },
];
NodeFavoriteDirective.ctorParameters = () => [
    { type: AlfrescoApiService, },
];
NodeFavoriteDirective.propDecorators = {
    "selection": [{ type: Input, args: ['adf-node-favorite',] },],
    "toggle": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};

const EXTENDIBLE_COMPONENT = new InjectionToken('extendible.component');

class NodePermissionDirective {
    constructor(elementRef, renderer, contentService, changeDetector, parentComponent) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.contentService = contentService;
        this.changeDetector = changeDetector;
        this.parentComponent = parentComponent;
        this.permission = null;
        this.nodes = [];
    }
    ngOnChanges(changes) {
        if (changes["nodes"] && !changes["nodes"].firstChange) {
            this.updateElement();
        }
    }
    updateElement() {
        let                  enable = this.hasPermission(this.nodes, this.permission);
        if (enable) {
            this.enable();
        }
        else {
            this.disable();
        }
        return enable;
    }
    enable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = false;
            this.changeDetector.detectChanges();
        }
        else {
            this.enableElement();
        }
    }
    disable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = true;
            this.changeDetector.detectChanges();
        }
        else {
            this.disableElement();
        }
    }
    enableElement() {
        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
    }
    disableElement() {
        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true');
    }
    hasPermission(nodes, permission) {
        if (nodes && nodes.length > 0) {
            return nodes.every(node => this.contentService.hasPermission(node.entry, permission));
        }
        return false;
    }
}
NodePermissionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-permission]'
            },] },
];
NodePermissionDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ContentService, },
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Host }, { type: Optional }, { type: Inject, args: [EXTENDIBLE_COMPONENT,] },] },
];
NodePermissionDirective.propDecorators = {
    "permission": [{ type: Input, args: ['adf-node-permission',] },],
    "nodes": [{ type: Input, args: ['adf-nodes',] },],
};

class NotificationService {
    constructor(snackbar) {
        this.snackbar = snackbar;
    }
    openSnackMessage(message, millisecondsDuration) {
        return this.snackbar.open(message, null, {
            duration: millisecondsDuration || NotificationService.DEFAULT_DURATION_MESSAGE
        });
    }
    openSnackMessageAction(message, action, millisecondsDuration) {
        return this.snackbar.open(message, action, {
            duration: millisecondsDuration || NotificationService.DEFAULT_DURATION_MESSAGE
        });
    }
}
NotificationService.DEFAULT_DURATION_MESSAGE = 5000;
NotificationService.decorators = [
    { type: Injectable },
];
NotificationService.ctorParameters = () => [
    { type: MatSnackBar, },
];

class NodeRestoreDirective {
    constructor(alfrescoApiService, translation, router, notification) {
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        this.router = router;
        this.notification = notification;
        this.location = '';
        this.restore = new EventEmitter();
        this.restoreProcessStatus = this.processStatus();
    }
    onClick() {
        this.recover(this.selection);
    }
    recover(selection) {
        if (!selection.length) {
            return;
        }
        const                  nodesWithPath = this.getNodesWithPath(selection);
        if (selection.length && !nodesWithPath.length) {
            this.restoreProcessStatus.fail.push(...selection);
            this.restoreNotification();
            this.refresh();
            return;
        }
        this.restoreNodesBatch(nodesWithPath)
            .do((restoredNodes) => {
            const                  status = this.processStatus(restoredNodes);
            this.restoreProcessStatus.fail.push(...status.fail);
            this.restoreProcessStatus.success.push(...status.success);
        })
            .mergeMap(() => this.getDeletedNodes())
            .subscribe((deletedNodesList) => {
            const { entries: nodelist } = deletedNodesList.list;
            const { fail: restoreErrorNodes } = this.restoreProcessStatus;
            const                  selectedNodes = this.diff(restoreErrorNodes, selection, false);
            const                  remainingNodes = this.diff(selectedNodes, nodelist);
            if (!remainingNodes.length) {
                this.restoreNotification();
                this.refresh();
            }
            else {
                this.recover(remainingNodes);
            }
        });
    }
    restoreNodesBatch(batch) {
        return Observable.forkJoin(batch.map((node) => this.restoreNode(node)));
    }
    getNodesWithPath(selection) {
        return selection.filter((node) => node.entry.path);
    }
    getDeletedNodes() {
        const                  promise = this.alfrescoApiService.getInstance()
            .core.nodesApi.getDeletedNodes({ include: ['path'] });
        return Observable.from(promise);
    }
    restoreNode(node) {
        const { entry } = node;
        const                  promise = this.alfrescoApiService.getInstance().nodes.restoreNode(entry.id);
        return Observable.from(promise)
            .map(() => ({
            status: 1,
            entry
        }))
            .catch((error) => {
            const { statusCode } = (JSON.parse(error.message)).error;
            return Observable.of({
                status: 0,
                statusCode,
                entry
            });
        });
    }
    navigateLocation(path) {
        const                  parent = path.elements[path.elements.length - 1];
        this.router.navigate([this.location, parent.id]);
    }
    diff(selection, list, fromList = true) {
        const                  ids = selection.map(item => item.entry.id);
        return list.filter(item => {
            if (fromList) {
                return ids.includes(item.entry.id) ? item : null;
            }
            else {
                return !ids.includes(item.entry.id) ? item : null;
            }
        });
    }
    processStatus(data = []) {
        const                  status = {
            fail: [],
            success: [],
            get someFailed() {
                return !!(this.fail.length);
            },
            get someSucceeded() {
                return !!(this.success.length);
            },
            get oneFailed() {
                return this.fail.length === 1;
            },
            get oneSucceeded() {
                return this.success.length === 1;
            },
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            },
            reset() {
                this.fail = [];
                this.success = [];
            }
        };
        return data.reduce((acc, node) => {
            if (node.status) {
                acc.success.push(node);
            }
            else {
                acc.fail.push(node);
            }
            return acc;
        }, status);
    }
    getRestoreMessage() {
        const { restoreProcessStatus: status } = this;
        if (status.someFailed && !status.oneFailed) {
            return this.translation.instant('CORE.RESTORE_NODE.PARTIAL_PLURAL', {
                number: status.fail.length
            });
        }
        if (status.oneFailed && status.fail[0].statusCode) {
            if (status.fail[0].statusCode === 409) {
                return this.translation.instant('CORE.RESTORE_NODE.NODE_EXISTS', {
                    name: status.fail[0].entry.name
                });
            }
            else {
                return this.translation.instant('CORE.RESTORE_NODE.GENERIC', {
                    name: status.fail[0].entry.name
                });
            }
        }
        if (status.oneFailed && !status.fail[0].statusCode) {
            return this.translation.instant('CORE.RESTORE_NODE.LOCATION_MISSING', {
                name: status.fail[0].entry.name
            });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.RESTORE_NODE.PLURAL');
        }
        if (status.allSucceeded && status.oneSucceeded) {
            return this.translation.instant('CORE.RESTORE_NODE.SINGULAR', {
                name: status.success[0].entry.name
            });
        }
    }
    restoreNotification() {
        const                  status = Object.assign({}, this.restoreProcessStatus);
        let                  message = this.getRestoreMessage();
        const                  action = (status.oneSucceeded && !status.someFailed) ? this.translation.instant('CORE.RESTORE_NODE.VIEW') : '';
        this.notification.openSnackMessageAction(message, action)
            .onAction()
            .subscribe(() => this.navigateLocation(status.success[0].entry.path));
    }
    refresh() {
        this.restoreProcessStatus.reset();
        this.selection = [];
        this.restore.emit();
    }
}
NodeRestoreDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-restore]'
            },] },
];
NodeRestoreDirective.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: TranslationService, },
    { type: Router, },
    { type: NotificationService, },
];
NodeRestoreDirective.propDecorators = {
    "selection": [{ type: Input, args: ['adf-restore',] },],
    "location": [{ type: Input },],
    "restore": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};

class UploadDirective {
    constructor(el, renderer, ngZone) {
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.enabled = true;
        this.mode = ['drop'];
        this.isDragging = false;
        this.cssClassName = 'adf-upload__dragging';
        this.element = el.nativeElement;
    }
    ngOnInit() {
        if (this.isClickMode() && this.renderer) {
            this.upload =                  (this.renderer.createElement(this.el.nativeElement.parentNode, 'input'));
            this.upload.type = 'file';
            this.upload.style.display = 'none';
            this.upload.addEventListener('change', e => this.onSelectFiles(e));
            if (this.multiple) {
                this.upload.setAttribute('multiple', '');
            }
            if (this.accept) {
                this.upload.setAttribute('accept', this.accept);
            }
            if (this.directory) {
                this.upload.setAttribute('webkitdirectory', '');
            }
        }
        if (this.isDropMode()) {
            this.ngZone.runOutsideAngular(() => {
                this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
                this.element.addEventListener('dragover', this.onDragOver.bind(this));
                this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
                this.element.addEventListener('drop', this.onDrop.bind(this));
            });
        }
    }
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDrop);
    }
    onClick(event) {
        if (this.isClickMode() && this.upload) {
            event.preventDefault();
            this.upload.click();
        }
    }
    onDragEnter(event) {
        if (this.isDropMode()) {
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
    }
    onDragOver(event) {
        event.preventDefault();
        if (this.isDropMode()) {
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
        return false;
    }
    onDragLeave(event) {
        if (this.isDropMode()) {
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
        }
    }
    onDrop(event) {
        if (this.isDropMode()) {
            event.stopPropagation();
            event.preventDefault();
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
            const                  dataTranfer = this.getDataTransfer(event);
            if (dataTranfer) {
                this.getFilesDropped(dataTranfer).then(files => {
                    this.onUploadFiles(files);
                });
            }
        }
        return false;
    }
    onUploadFiles(files) {
        if (this.enabled && files.length > 0) {
            let                  e = new CustomEvent('upload-files', {
                detail: {
                    sender: this,
                    data: this.data,
                    files: files
                },
                bubbles: true
            });
            this.el.nativeElement.dispatchEvent(e);
        }
    }
    hasMode(mode) {
        return this.enabled && mode && this.mode && this.mode.indexOf(mode) > -1;
    }
    isDropMode() {
        return this.hasMode('drop');
    }
    isClickMode() {
        return this.hasMode('click');
    }
    getDataTransfer(event) {
        if (event && event.dataTransfer) {
            return event.dataTransfer;
        }
        if (event && event.originalEvent && event.originalEvent.dataTransfer) {
            return event.originalEvent.dataTransfer;
        }
        return null;
    }
    getFilesDropped(dataTransfer) {
        return new Promise(resolve => {
            const                  iterations = [];
            if (dataTransfer) {
                const                  items = dataTransfer.items;
                if (items) {
                    for (let                  i = 0; i < items.length; i++) {
                        if (typeof items[i].webkitGetAsEntry !== 'undefined') {
                            let                  item = items[i].webkitGetAsEntry();
                            if (item) {
                                if (item.isFile) {
                                    iterations.push(Promise.resolve(                 ({
                                        entry: item,
                                        file: items[i].getAsFile(),
                                        relativeFolder: '/'
                                    })));
                                }
                                else if (item.isDirectory) {
                                    iterations.push(new Promise(resolveFolder => {
                                        FileUtils.flattern(item).then(files => resolveFolder(files));
                                    }));
                                }
                            }
                        }
                        else {
                            iterations.push(Promise.resolve(                 ({
                                entry: null,
                                file: items[i].getAsFile(),
                                relativeFolder: '/'
                            })));
                        }
                    }
                }
                else {
                    let                  files = FileUtils
                        .toFileArray(dataTransfer.files)
                        .map(file =>                  ({
                        entry: null,
                        file: file,
                        relativeFolder: '/'
                    }));
                    iterations.push(Promise.resolve(files));
                }
            }
            Promise.all(iterations).then(result => {
                resolve(result.reduce((a, b) => a.concat(b), []));
            });
        });
    }
    onSelectFiles(e) {
        if (this.isClickMode()) {
            const                  input = (                 (e.currentTarget));
            const                  files = FileUtils.toFileArray(input.files);
            this.onUploadFiles(files.map(file =>                  ({
                entry: null,
                file: file,
                relativeFolder: '/'
            })));
            e.target.value = '';
        }
    }
}
UploadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-upload]'
            },] },
];
UploadDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
    { type: NgZone, },
];
UploadDirective.propDecorators = {
    "enabled": [{ type: Input, args: ['adf-upload',] },],
    "data": [{ type: Input, args: ['adf-upload-data',] },],
    "mode": [{ type: Input },],
    "multiple": [{ type: Input },],
    "accept": [{ type: Input },],
    "directory": [{ type: Input },],
    "onClick": [{ type: HostListener, args: ['click', ['$event'],] },],
};

class DirectiveModule {
}
DirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    NodePermissionDirective,
                    NodeRestoreDirective,
                    UploadDirective
                ],
                exports: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    NodePermissionDirective,
                    NodeRestoreDirective,
                    UploadDirective
                ]
            },] },
];
DirectiveModule.ctorParameters = () => [];

class DataTableModule {
}
DataTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule,
                    ContextMenuModule,
                    PipeModule,
                    DirectiveModule
                ],
                declarations: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective
                ],
                exports: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective
                ]
            },] },
];
DataTableModule.ctorParameters = () => [];

class AccordionComponent {
    constructor() {
        this.groups = [];
    }
    addGroup(group) {
        this.groups.push(group);
    }
    closeOthers(openGroup) {
        this.groups.forEach((group) => {
            if (group !== openGroup) {
                group.isOpen = false;
            }
        });
    }
    removeGroup(group) {
        const                  index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(index, 1);
        }
    }
}
AccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-accordion',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    'class': 'panel-group'
                },
                encapsulation: ViewEncapsulation.None
            },] },
];
AccordionComponent.ctorParameters = () => [];

class AccordionGroupComponent {
    constructor(accordion) {
        this.accordion = accordion;
        this._isOpen = false;
        this._isSelected = false;
        this.hasAccordionIcon = true;
        this.headingClick = new EventEmitter();
        this.accordion.addGroup(this);
    }
    set isOpen(value) {
        this._isOpen = value;
        if (value) {
            this.accordion.closeOthers(this);
        }
    }
    get isOpen() {
        return this._isOpen;
    }
    set isSelected(value) {
        this._isSelected = value;
    }
    get isSelected() {
        return this._isSelected;
    }
    ngOnDestroy() {
        this.accordion.removeGroup(this);
    }
    hasHeadingIcon() {
        return this.headingIcon ? true : false;
    }
    toggleOpen(event) {
        event.preventDefault();
        this.isOpen = !this.isOpen;
        this.headingClick.emit(this.heading);
    }
    getAccordionIcon() {
        return this.isOpen ? 'expand_less' : 'expand_more';
    }
}
AccordionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-accordion-group',
                template: `<div class="adf-panel adf-panel-default" [ngClass]="{'adf-panel-open': isOpen}">
    <div class="adf-panel-heading" [ngClass]="{'adf-panel-heading-selected': isSelected}" (click)="toggleOpen($event)">
        <div id="heading-icon" *ngIf="hasHeadingIcon()" class="adf-panel-heading-icon">
            <mat-icon class="material-icons"
               [matTooltip]="headingIconTooltip"
               [matTooltipDisabled]="!headingIconTooltip">
                {{headingIcon}}
            </mat-icon>
        </div>
        <div id="heading-text" class="adf-panel-heading-text">{{heading}}</div>
        <div id="accordion-button" *ngIf="hasAccordionIcon" class="adf-panel-heading-toggle">
            <i class="material-icons">{{getAccordionIcon()}}</i>
        </div>
    </div>
    <div class="adf-panel-collapse" [hidden]="!isOpen">
        <div class="adf-panel-body" #contentWrapper>
            <ng-content></ng-content>
        </div>
    </div>
</div>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
AccordionGroupComponent.ctorParameters = () => [
    { type: AccordionComponent, },
];
AccordionGroupComponent.propDecorators = {
    "contentWrapper": [{ type: ViewChild, args: ['contentWrapper',] },],
    "heading": [{ type: Input },],
    "headingIcon": [{ type: Input },],
    "headingIconTooltip": [{ type: Input },],
    "hasAccordionIcon": [{ type: Input },],
    "headingClick": [{ type: Output },],
    "isOpen": [{ type: Input },],
    "isSelected": [{ type: Input },],
};

class CollapsableModule {
}
CollapsableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MaterialModule,
                    CommonModule
                ],
                declarations: [
                    AccordionComponent,
                    AccordionGroupComponent
                ],
                exports: [
                    AccordionComponent,
                    AccordionGroupComponent
                ]
            },] },
];
CollapsableModule.ctorParameters = () => [];

class CardViewComponent {
    constructor() {
        this.displayEmpty = true;
    }
}
CardViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view',
                template: `<div class="adf-property-list">
    <div *ngFor="let property of properties">
        <div [attr.data-automation-id]="'header-'+property.key" class="adf-property">
            <adf-card-view-item-dispatcher
                [property]="property"
                [editable]="editable"
                [displayEmpty]="displayEmpty">
            </adf-card-view-item-dispatcher>
        </div>
    </div>
</div>
`,
                styles: [``]
            },] },
];
CardViewComponent.ctorParameters = () => [];
CardViewComponent.propDecorators = {
    "properties": [{ type: Input },],
    "editable": [{ type: Input },],
    "displayEmpty": [{ type: Input },],
};

class CardViewBaseItemModel {
    constructor(obj) {
        this.label = obj.label || '';
        this.value = obj.value;
        this.key = obj.key;
        this.default = obj.default;
        this.editable = !!obj.editable;
        this.clickable = !!obj.clickable;
        this.icon = obj.icon || '';
        this.validators = obj.validators || [];
    }
    isEmpty() {
        return this.value === undefined || this.value === null || this.value === '';
    }
    isValid(newValue) {
        if (!this.validators.length) {
            return true;
        }
        return this.validators
            .map((validator) => validator.isValid(newValue))
            .reduce((isValidUntilNow, isValid) => isValidUntilNow && isValid, true);
    }
    getValidationErrors(value) {
        if (!this.validators.length) {
            return [];
        }
        return this.validators
            .filter((validator) => !validator.isValid(value))
            .map((validator) => validator.message);
    }
}

class CardViewBoolItemModel extends CardViewBaseItemModel {
    constructor(obj) {
        super(obj);
        this.type = 'bool';
        this.value = false;
        if (obj.value !== undefined) {
            this.value = !!JSON.parse(obj.value);
        }
    }
    get displayValue() {
        if (this.isEmpty()) {
            return this.default;
        }
        else {
            return this.value;
        }
    }
}

function transformKeyToObject(key, value) {
    const                  objectLevels = key.split('.').reverse();
    return objectLevels.reduce((previousValue, currentValue) => {
        return { [currentValue]: previousValue };
    }, value);
}
class CardViewUpdateService {
    constructor() {
        this.itemUpdatedSource = new Subject();
        this.itemClickedSource = new Subject();
        this.itemUpdated$ =                  (this.itemUpdatedSource.asObservable());
        this.itemClicked$ =                  (this.itemClickedSource.asObservable());
    }
    update(property, newValue) {
        this.itemUpdatedSource.next({
            target: property,
            changed: transformKeyToObject(property.key, newValue)
        });
    }
    clicked(property) {
        this.itemClickedSource.next({
            target: property
        });
    }
}
CardViewUpdateService.decorators = [
    { type: Injectable },
];
CardViewUpdateService.ctorParameters = () => [];

class CardViewBoolItemComponent {
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
    }
    isEditable() {
        return this.editable && this.property.editable;
    }
    changed(change) {
        this.cardViewUpdateService.update(this.property, change.checked);
        this.property.value = change.checked;
    }
}
CardViewBoolItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-boolitem',
                template: `<ng-container *ngIf="!property.isEmpty() || isEditable()">
    <div class="adf-property-label">{{ property.label | translate }}</div>
    <div class="adf-property-value">
        <mat-checkbox
            [attr.title]="'CORE.METADATA.ACTIONS.TOGGLE' | translate"
            [checked]="property.displayValue"
            [disabled]="!isEditable()"
            (change)="changed($event)">
        </mat-checkbox>
    </div>
</ng-container>
`,
                styles: [``]
            },] },
];
CardViewBoolItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService, },
];
CardViewBoolItemComponent.propDecorators = {
    "property": [{ type: Input },],
    "editable": [{ type: Input },],
};

class CardViewDateItemModel extends CardViewBaseItemModel {
    constructor(obj) {
        super(obj);
        this.type = 'date';
        this.format = 'MMM DD YYYY';
        if (obj.format) {
            this.format = obj.format;
        }
    }
    get displayValue() {
        if (!this.value) {
            return this.default;
        }
        else {
            return moment(this.value).format(this.format);
        }
    }
}

const ɵ0 = MOMENT_DATE_FORMATS;
const ɵ1 = MAT_MOMENT_DATETIME_FORMATS;
class CardViewDateItemComponent {
    constructor(cardViewUpdateService, dateAdapter, preferences) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.SHOW_FORMAT = 'MMM DD YY';
        this.editable = false;
        this.displayEmpty = true;
    }
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        (                 (this.dateAdapter)).overrideDisplyaFormat = this.SHOW_FORMAT;
        if (this.property.value) {
            this.valueDate = moment(this.property.value, this.SHOW_FORMAT);
        }
    }
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    isEditable() {
        return this.editable && this.property.editable;
    }
    showDatePicker() {
        this.datepicker.open();
    }
    onDateChanged(newDateValue) {
        if (newDateValue) {
            let                  momentDate = moment(newDateValue.value, this.SHOW_FORMAT, true);
            if (momentDate.isValid()) {
                this.valueDate = momentDate;
                this.cardViewUpdateService.update(this.property, momentDate.toDate());
                this.property.value = momentDate.toDate();
            }
        }
    }
}
CardViewDateItemComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1 }
                ],
                selector: 'adf-card-view-dateitem',
                template: `<div class="adf-property-label" *ngIf="showProperty() || isEditable()">{{ property.label | translate }}</div>
<div class="adf-property-value">
    <span *ngIf="!isEditable()">
        <span [attr.data-automation-id]="'card-dateitem-' + property.key">
            <span *ngIf="showProperty()">{{ property.displayValue }}</span>
        </span>
    </span>
    <div *ngIf="isEditable()" class="adf-dateitem-editable">
        <div class="adf-dateitem-editable-controls">
            <span
                class="adf-datepicker-toggle"
                [attr.data-automation-id]="'datepicker-label-toggle-' + property.key"
                (click)="showDatePicker($event)">
                <span *ngIf="showProperty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
            </span>
            <mat-datetimepicker-toggle
                [attr.title]="'CORE.METADATA.ACTIONS.EDIT' | translate"
                [attr.data-automation-id]="'datepickertoggle-' + property.key"
                [for]="datetimePicker">
            </mat-datetimepicker-toggle>
        </div>

        <input class="adf-invisible-date-input"
            [matDatetimepicker]="datetimePicker"
            [value]="valueDate"
            (dateChange)="onDateChanged($event)">

        <mat-datetimepicker #datetimePicker
            [type]="property.type"
            timeInterval="5"
            [attr.data-automation-id]="'datepicker-' + property.key"
            [startAt]="valueDate">
        </mat-datetimepicker>
    </div>
    <ng-template #elseEmptyValueBlock>
        {{ property.default | translate }}
    </ng-template>
</div>
`,
                styles: [``]
            },] },
];
CardViewDateItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService, },
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];
CardViewDateItemComponent.propDecorators = {
    "property": [{ type: Input },],
    "editable": [{ type: Input },],
    "displayEmpty": [{ type: Input },],
    "datepicker": [{ type: ViewChild, args: ['datetimePicker',] },],
};

class CardViewMapItemModel extends CardViewBaseItemModel {
    constructor() {
        super(...arguments);
        this.type = 'map';
    }
    get displayValue() {
        if (this.value && this.value.size > 0) {
            return this.value.values().next().value;
        }
        else {
            return this.default;
        }
    }
}

class CardViewMapItemComponent {
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.displayEmpty = true;
    }
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    isClickable() {
        return this.property.clickable;
    }
    clicked() {
        this.cardViewUpdateService.clicked(this.property);
    }
}
CardViewMapItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-mapitem',
                template: `<div class="adf-property-label" *ngIf="showProperty()">{{ property.label | translate }}</div>
<div class="adf-property-value">
    <div>
        <span *ngIf="!isClickable(); else elseBlock" [attr.data-automation-id]="'card-mapitem-value-' + property.key">
            <span *ngIf="showProperty();">{{ property.displayValue }}</span>
        </span>
        <ng-template #elseBlock>
            <span class="adf-mapitem-clickable-value" (click)="clicked()" [attr.data-automation-id]="'card-mapitem-value-' + property.key">
                <span *ngIf="showProperty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
            </span>
        </ng-template>
    </div>
    <ng-template #elseEmptyValueBlock>
        {{ property.default | translate }}
    </ng-template>
</div>
`,
                styles: [`.adf-mapitem-clickable-value{cursor:pointer}`]
            },] },
];
CardViewMapItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService, },
];
CardViewMapItemComponent.propDecorators = {
    "property": [{ type: Input },],
    "displayEmpty": [{ type: Input },],
};

class CardViewTextItemModel extends CardViewBaseItemModel {
    constructor(obj) {
        super(obj);
        this.type = 'text';
        this.multiline = !!obj.multiline;
        this.pipes = obj.pipes || [];
    }
    get displayValue() {
        if (this.isEmpty()) {
            return this.default;
        }
        else {
            return this.applyPipes(this.value);
        }
    }
    applyPipes(displayValue) {
        if (this.pipes.length) {
            displayValue = this.pipes.reduce((accumulator, { pipe, params = [] }) => {
                return pipe.transform(accumulator, ...params);
            }, displayValue);
        }
        return displayValue;
    }
}

class CardViewTextItemComponent {
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.editable = false;
        this.displayEmpty = true;
        this.inEdit = false;
    }
    ngOnChanges() {
        this.editedValue = this.property.value;
    }
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    isEditable() {
        return this.editable && this.property.editable;
    }
    isClickable() {
        return this.property.clickable;
    }
    hasIcon() {
        return !!this.property.icon;
    }
    hasErrors() {
        return this.errorMessages && this.errorMessages.length;
    }
    setEditMode(editStatus) {
        this.inEdit = editStatus;
        setTimeout(() => {
            if (this.editorInput) {
                this.editorInput.nativeElement.click();
            }
        }, 0);
    }
    reset() {
        this.editedValue = this.property.value;
        this.setEditMode(false);
    }
    update() {
        if (this.property.isValid(this.editedValue)) {
            this.cardViewUpdateService.update(this.property, this.editedValue);
            this.property.value = this.editedValue;
            this.setEditMode(false);
        }
        else {
            this.errorMessages = this.property.getValidationErrors(this.editedValue);
        }
    }
    clicked() {
        this.cardViewUpdateService.clicked(this.property);
    }
}
CardViewTextItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-textitem',
                template: `<div class="adf-property-label" *ngIf="showProperty() || isEditable()">{{ property.label | translate }}</div>
<div class="adf-property-value">
    <span *ngIf="!isEditable()">
        <span *ngIf="!isClickable(); else elseBlock" [attr.data-automation-id]="'card-textitem-value-' + property.key">
            <span *ngIf="showProperty()">{{ property.displayValue }}</span>
        </span>
        <ng-template #elseBlock>
        <div class="adf-textitem-clickable" (click)="clicked()" fxLayout="row" fxLayoutAlign="space-between center">
            <span class="adf-textitem-clickable-value" [attr.data-automation-id]="'card-textitem-value-' + property.key">
                <span *ngIf="showProperty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
            </span>
            <mat-icon *ngIf="hasIcon()" fxFlex="0 0 auto" [attr.data-automation-id]="'card-textitem-edit-icon-' + property.icon" class="adf-textitem-icon">{{ property.icon }}</mat-icon>
        </div>
        </ng-template>
    </span>
    <span *ngIf="isEditable()">
        <div *ngIf="!inEdit" (click)="setEditMode(true)" class="adf-textitem-readonly" [attr.data-automation-id]="'card-textitem-edit-toggle-' + property.key" fxLayout="row" fxLayoutAlign="space-between center">
            <span [attr.data-automation-id]="'card-textitem-value-' + property.key">
                <span *ngIf="showProperty(); else elseEmptyValueBlock">{{ property.displayValue }}</span>
            </span>
            <mat-icon fxFlex="0 0 auto"
                [attr.data-automation-id]="'card-textitem-edit-icon-' + property.key"
                [attr.title]="'CORE.METADATA.ACTIONS.EDIT' | translate"
                class="adf-textitem-icon">create</mat-icon>
        </div>
        <div *ngIf="inEdit" class="adf-textitem-editable">
            <div class="adf-textitem-editable-controls">
                <mat-form-field floatPlaceholder="never" class="adf-input-container">
                    <input *ngIf="!property.multiline" #editorInput
                        matInput
                        class="adf-input"
                        [placeholder]="property.default | translate"
                        [(ngModel)]="editedValue"
                        [attr.data-automation-id]="'card-textitem-editinput-' + property.key">
                    <textarea *ngIf="property.multiline" #editorInput
                        matInput
                        matTextareaAutosize
                        matAutosizeMaxRows="1"
                        matAutosizeMaxRows="5"
                        class="adf-textarea"
                        [placeholder]="property.default | translate"
                        [(ngModel)]="editedValue"
                        [attr.data-automation-id]="'card-textitem-edittextarea-' + property.key"></textarea>
                </mat-form-field>
                <mat-icon
                    class="adf-textitem-icon adf-update-icon"
                    (click)="update()"
                    [attr.title]="'CORE.METADATA.ACTIONS.SAVE' | translate"
                    [attr.data-automation-id]="'card-textitem-update-' + property.key">done</mat-icon>
                <mat-icon
                    class="adf-textitem-icon adf-reset-icon"
                    (click)="reset()"
                    [attr.title]="'CORE.METADATA.ACTIONS.CANCEL' | translate"
                    [attr.data-automation-id]="'card-textitem-reset-' + property.key">clear</mat-icon>
            </div>
            <mat-error class="adf-textitem-editable-error" *ngIf="hasErrors()">
                <ul>
                    <li *ngFor="let errorMessage of errorMessages">{{ errorMessage | translate }}</li>
                </ul>
            </mat-error>
        </div>
    </span>
    <ng-template #elseEmptyValueBlock>
        <span class="adf-textitem-default-value">{{ property.default | translate }}</span>
    </ng-template>
</div>
`,
                styles: [``]
            },] },
];
CardViewTextItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService, },
];
CardViewTextItemComponent.propDecorators = {
    "property": [{ type: Input },],
    "editable": [{ type: Input },],
    "displayEmpty": [{ type: Input },],
    "editorInput": [{ type: ViewChild, args: ['editorInput',] },],
};

function getType(type) {
    return () => type;
}

class DynamicComponentResolver {
    static fromType(type) {
        return getType(type);
    }
}
class DynamicComponentMapper {
    constructor() {
        this.defaultValue = undefined;
        this.types = {};
    }
    getComponentTypeResolver(type, defaultValue = this.defaultValue) {
        if (type) {
            return this.types[type] || DynamicComponentResolver.fromType(defaultValue);
        }
        return DynamicComponentResolver.fromType(defaultValue);
    }
    setComponentTypeResolver(type, resolver, override = false) {
        if (!type) {
            throw new Error(`type is null or not defined`);
        }
        if (!resolver) {
            throw new Error(`resolver is null or not defined`);
        }
        let                  existing = this.types[type];
        if (existing && !override) {
            throw new Error(`already mapped, use override option if you intend replacing existing mapping.`);
        }
        this.types[type] = resolver;
    }
    resolveComponentType(model, defaultValue = this.defaultValue) {
        if (model) {
            let                  resolver = this.getComponentTypeResolver(model.type, defaultValue);
            return resolver(model);
        }
        return defaultValue;
    }
}

class CardItemTypeService extends DynamicComponentMapper {
    constructor() {
        super(...arguments);
        this.defaultValue = CardViewTextItemComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'int': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'float': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'date': DynamicComponentResolver.fromType(CardViewDateItemComponent),
            'datetime': DynamicComponentResolver.fromType(CardViewDateItemComponent),
            'bool': DynamicComponentResolver.fromType(CardViewBoolItemComponent),
            'map': DynamicComponentResolver.fromType(CardViewMapItemComponent)
        };
    }
}
CardItemTypeService.decorators = [
    { type: Injectable },
];
CardItemTypeService.ctorParameters = () => [];

class CardViewContentProxyDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
CardViewContentProxyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-card-view-content-proxy]'
            },] },
];
CardViewContentProxyDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];

class CardViewItemDispatcherComponent {
    constructor(cardItemTypeService, resolver) {
        this.cardItemTypeService = cardItemTypeService;
        this.resolver = resolver;
        this.displayEmpty = true;
        this.loaded = false;
        this.componentReference = null;
        const                  dynamicLifecycleMethods = [
            'ngOnInit',
            'ngDoCheck',
            'ngAfterContentInit',
            'ngAfterContentChecked',
            'ngAfterViewInit',
            'ngAfterViewChecked',
            'ngOnDestroy'
        ];
        dynamicLifecycleMethods.forEach((dynamicLifecycleMethod) => {
            this[dynamicLifecycleMethod] = this.proxy.bind(this, dynamicLifecycleMethod);
        });
    }
    ngOnChanges(changes) {
        if (!this.loaded) {
            this.loadComponent();
            this.loaded = true;
        }
        Object.keys(changes)
            .map(changeName => [changeName, changes[changeName]])
            .forEach(([inputParamName, simpleChange]) => {
            this.componentReference.instance[inputParamName] = simpleChange.currentValue;
        });
        this.proxy('ngOnChanges', changes);
    }
    loadComponent() {
        const                  factoryClass = this.cardItemTypeService.resolveComponentType(this.property);
        const                  factory = this.resolver.resolveComponentFactory(factoryClass);
        this.componentReference = this.content.viewContainerRef.createComponent(factory);
        this.componentReference.instance.editable = this.editable;
        this.componentReference.instance.property = this.property;
        this.componentReference.instance.displayEmpty = this.displayEmpty;
    }
    proxy(methodName, ...args) {
        if (this.componentReference.instance[methodName]) {
            this.componentReference.instance[methodName].apply(this.componentReference.instance, args);
        }
    }
}
CardViewItemDispatcherComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-item-dispatcher',
                template: '<ng-template adf-card-view-content-proxy></ng-template>'
            },] },
];
CardViewItemDispatcherComponent.ctorParameters = () => [
    { type: CardItemTypeService, },
    { type: ComponentFactoryResolver, },
];
CardViewItemDispatcherComponent.propDecorators = {
    "property": [{ type: Input },],
    "editable": [{ type: Input },],
    "displayEmpty": [{ type: Input },],
    "content": [{ type: ViewChild, args: [CardViewContentProxyDirective,] },],
};

class CardViewItemIntValidator {
    constructor() {
        this.message = 'CORE.CARDVIEW.VALIDATORS.INT_VALIDATION_ERROR';
    }
    isValid(value) {
        return !isNaN(value) && (function (x) { return (x | 0) === x; })(parseFloat(value));
    }
}

class CardViewItemFloatValidator {
    constructor() {
        this.message = 'CORE.CARDVIEW.VALIDATORS.FLOAT_VALIDATION_ERROR';
    }
    isValid(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    }
}

class CardViewDatetimeItemModel extends CardViewDateItemModel {
    constructor() {
        super(...arguments);
        this.type = 'datetime';
        this.format = 'MMM DD YYYY HH:mm';
    }
}

class CardViewFloatItemModel extends CardViewTextItemModel {
    constructor(obj) {
        super(obj);
        this.type = 'float';
        this.validators.push(new CardViewItemFloatValidator());
        if (obj.value) {
            this.value = parseFloat(obj.value);
        }
    }
}

class CardViewIntItemModel extends CardViewTextItemModel {
    constructor(obj) {
        super(obj);
        this.type = 'int';
        this.validators.push(new CardViewItemIntValidator());
        if (obj.value) {
            this.value = parseInt(obj.value, 10);
        }
    }
}

class CardViewModule {
}
CardViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FlexLayoutModule,
                    TranslateModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatCheckboxModule,
                    MatInputModule,
                    MatIconModule,
                    MatButtonModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule
                ],
                declarations: [
                    CardViewComponent,
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent,
                    CardViewItemDispatcherComponent,
                    CardViewContentProxyDirective
                ],
                entryComponents: [
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent
                ],
                exports: [
                    CardViewComponent,
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent
                ]
            },] },
];
CardViewModule.ctorParameters = () => [];

class AppConfigModule {
}
AppConfigModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule
                ],
                providers: [
                    AppConfigService
                ]
            },] },
];
AppConfigModule.ctorParameters = () => [];

class FormEvent {
    constructor(form) {
        this.isDefaultPrevented = false;
        this.form = form;
    }
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    preventDefault() {
        this.isDefaultPrevented = true;
    }
}

class FormErrorEvent extends FormEvent {
    constructor(form, error) {
        super(form);
        this.error = error;
    }
}

class FormFieldEvent extends FormEvent {
    constructor(form, field) {
        super(form);
        this.field = field;
    }
}

class ValidateFormFieldEvent extends FormFieldEvent {
    constructor(form, field) {
        super(form, field);
        this.isValid = true;
    }
}

class ValidateFormEvent extends FormEvent {
    constructor(form) {
        super(form);
        this.isValid = true;
    }
}

class ValidateDynamicTableRowEvent extends FormFieldEvent {
    constructor(form, field, row, summary) {
        super(form, field);
        this.row = row;
        this.summary = summary;
        this.isValid = true;
    }
}

class EcmModelService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    createEcmTypeForActivitiForm(formName, form) {
        return Observable.create(observer => {
            this.searchActivitiEcmModel().subscribe(model => {
                if (!model) {
                    this.createActivitiEcmModel(formName, form).subscribe(typeForm => {
                        observer.next(typeForm);
                        observer.complete();
                    });
                }
                else {
                    this.saveFomType(formName, form).subscribe(typeForm => {
                        observer.next(typeForm);
                        observer.complete();
                    });
                }
            }, err => this.handleError(err));
        });
    }
    searchActivitiEcmModel() {
        return this.getEcmModels().map(function (ecmModels) {
            return ecmModels.list.entries.find(model => model.entry.name === EcmModelService.MODEL_NAME);
        });
    }
    createActivitiEcmModel(formName, form) {
        return Observable.create(observer => {
            this.createEcmModel(EcmModelService.MODEL_NAME, EcmModelService.MODEL_NAMESPACE).subscribe(model => {
                this.logService.info('model created', model);
                this.activeEcmModel(EcmModelService.MODEL_NAME).subscribe(modelActive => {
                    this.logService.info('model active', modelActive);
                    this.createEcmTypeWithProperties(formName, form).subscribe(typeCreated => {
                        observer.next(typeCreated);
                        observer.complete();
                    });
                }, err => this.handleError(err));
            }, err => this.handleError(err));
        });
    }
    saveFomType(formName, form) {
        return Observable.create(observer => {
            this.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe(ecmType => {
                this.logService.info('custom types', ecmType);
                if (!ecmType) {
                    this.createEcmTypeWithProperties(formName, form).subscribe(typeCreated => {
                        observer.next(typeCreated);
                        observer.complete();
                    });
                }
                else {
                    observer.next(ecmType);
                    observer.complete();
                }
            }, err => this.handleError(err));
        });
    }
    createEcmTypeWithProperties(formName, form) {
        return Observable.create(observer => {
            this.createEcmType(formName, EcmModelService.MODEL_NAME, EcmModelService.TYPE_MODEL).subscribe(typeCreated => {
                this.logService.info('type Created', typeCreated);
                this.addPropertyToAType(EcmModelService.MODEL_NAME, formName, form).subscribe(properyAdded => {
                    this.logService.info('property Added', properyAdded);
                    observer.next(typeCreated);
                    observer.complete();
                }, err => this.handleError(err));
            }, err => this.handleError(err));
        });
    }
    searchEcmType(typeName, modelName) {
        return this.getEcmType(modelName).map(function (customTypes) {
            return customTypes.list.entries.find(type => type.entry.prefixedName === typeName || type.entry.title === typeName);
        });
    }
    activeEcmModel(modelName) {
        return Observable.fromPromise(this.apiService.getInstance().core.customModelApi.activateCustomModel(modelName))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    createEcmModel(modelName, nameSpace) {
        return Observable.fromPromise(this.apiService.getInstance().core.customModelApi.createCustomModel('DRAFT', '', modelName, modelName, nameSpace))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getEcmModels() {
        return Observable.fromPromise(this.apiService.getInstance().core.customModelApi.getAllCustomModel())
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getEcmType(modelName) {
        return Observable.fromPromise(this.apiService.getInstance().core.customModelApi.getAllCustomType(modelName))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    createEcmType(typeName, modelName, parentType) {
        let                  name = this.cleanNameType(typeName);
        return Observable.fromPromise(this.apiService.getInstance().core.customModelApi.createCustomType(modelName, name, parentType, typeName, ''))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    addPropertyToAType(modelName, typeName, formFields) {
        let                  name = this.cleanNameType(typeName);
        let                  properties = [];
        if (formFields && formFields.values) {
            for (let                  key in formFields.values) {
                if (key) {
                    properties.push({
                        name: key,
                        title: key,
                        description: key,
                        dataType: 'd:text',
                        multiValued: false,
                        mandatory: false,
                        mandatoryEnforced: false
                    });
                }
            }
        }
        return Observable.fromPromise(this.apiService.getInstance().core.customModelApi.addPropertyToType(modelName, name, properties))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    cleanNameType(name) {
        let                  cleanName = name;
        if (name.indexOf(':') !== -1) {
            cleanName = name.split(':')[1];
        }
        return cleanName.replace(/[^a-zA-Z ]/g, '');
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    handleError(err) {
        this.logService.error(err);
    }
}
EcmModelService.MODEL_NAMESPACE = 'activitiForms';
EcmModelService.MODEL_NAME = 'activitiFormsModel';
EcmModelService.TYPE_MODEL = 'cm:folder';
EcmModelService.decorators = [
    { type: Injectable },
];
EcmModelService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class FormDefinitionModel {
    constructor(id, name, lastUpdatedByFullName, lastUpdated, metadata) {
        this.reusable = false;
        this.newVersion = false;
        this.formImageBase64 = '';
        this.formRepresentation = {
            id: id,
            name: name,
            description: '',
            version: 1,
            lastUpdatedBy: 1,
            lastUpdatedByFullName: lastUpdatedByFullName,
            lastUpdated: lastUpdated,
            stencilSetId: 0,
            referenceId: null,
            formDefinition: {
                fields: [{
                        name: 'Label',
                        type: 'container',
                        fieldType: 'ContainerRepresentation',
                        numberOfColumns: 2,
                        required: false,
                        readOnly: false,
                        sizeX: 2,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        fields: { '1': this.metadataToFields(metadata) }
                    }],
                gridsterForm: false,
                javascriptEvents: [],
                metadata: {},
                outcomes: [],
                className: '',
                style: '',
                tabs: [],
                variables: []
            }
        };
    }
    metadataToFields(metadata) {
        let                  fields = [];
        if (metadata) {
            metadata.forEach(function (property) {
                if (property) {
                    let                  field = {
                        type: 'text',
                        id: property.name,
                        name: property.name,
                        required: false,
                        readOnly: false,
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        colspan: 1,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        layout: {
                            colspan: 1,
                            row: -1,
                            column: -1
                        }
                    };
                    fields.push(field);
                }
            });
        }
        return fields;
    }
}

class FormFieldTypes {
    static isReadOnlyType(type) {
        return FormFieldTypes.READONLY_TYPES.indexOf(type) > -1;
    }
    static isContainerType(type) {
        return type === FormFieldTypes.CONTAINER || type === FormFieldTypes.GROUP;
    }
}
FormFieldTypes.CONTAINER = 'container';
FormFieldTypes.GROUP = 'group';
FormFieldTypes.DYNAMIC_TABLE = 'dynamic-table';
FormFieldTypes.TEXT = 'text';
FormFieldTypes.MULTILINE_TEXT = 'multi-line-text';
FormFieldTypes.DROPDOWN = 'dropdown';
FormFieldTypes.HYPERLINK = 'hyperlink';
FormFieldTypes.RADIO_BUTTONS = 'radio-buttons';
FormFieldTypes.DISPLAY_VALUE = 'readonly';
FormFieldTypes.READONLY_TEXT = 'readonly-text';
FormFieldTypes.UPLOAD = 'upload';
FormFieldTypes.TYPEAHEAD = 'typeahead';
FormFieldTypes.FUNCTIONAL_GROUP = 'functional-group';
FormFieldTypes.PEOPLE = 'people';
FormFieldTypes.BOOLEAN = 'boolean';
FormFieldTypes.NUMBER = 'integer';
FormFieldTypes.DATE = 'date';
FormFieldTypes.AMOUNT = 'amount';
FormFieldTypes.DOCUMENT = 'document';
FormFieldTypes.DATETIME = 'datetime';
FormFieldTypes.READONLY_TYPES = [
    FormFieldTypes.HYPERLINK,
    FormFieldTypes.DISPLAY_VALUE,
    FormFieldTypes.READONLY_TEXT
];

class FormWidgetModel {
    constructor(form, json) {
        this.form = form;
        this.json = json;
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this.tab = json.tab;
        }
    }
}

class ContainerColumnModel {
    constructor() {
        this.size = 12;
        this.fields = [];
        this.colspan = 1;
        this.rowspan = 1;
    }
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
}

class ErrorMessageModel {
    constructor(obj) {
        this.message = '';
        this.attributes = null;
        this.message = obj && obj.message ? obj.message : '';
        this.attributes = new Map();
    }
    isActive() {
        return this.message ? true : false;
    }
    getAttributesAsJsonObj() {
        let                  result = {};
        if (this.attributes.size > 0) {
            let                  obj = Object.create(null);
            this.attributes.forEach((value, key) => {
                obj[key] = value;
            });
            result = JSON.stringify(obj);
        }
        return result;
    }
}

class RequiredFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT,
            FormFieldTypes.NUMBER,
            FormFieldTypes.BOOLEAN,
            FormFieldTypes.TYPEAHEAD,
            FormFieldTypes.DROPDOWN,
            FormFieldTypes.PEOPLE,
            FormFieldTypes.FUNCTIONAL_GROUP,
            FormFieldTypes.RADIO_BUTTONS,
            FormFieldTypes.UPLOAD,
            FormFieldTypes.AMOUNT,
            FormFieldTypes.DYNAMIC_TABLE,
            FormFieldTypes.DATE,
            FormFieldTypes.DATETIME
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.required;
    }
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (field.type === FormFieldTypes.DROPDOWN) {
                if (field.hasEmptyValue && field.emptyOption) {
                    if (field.value === field.emptyOption.id) {
                        return false;
                    }
                }
            }
            if (field.type === FormFieldTypes.RADIO_BUTTONS) {
                let                  option = field.options.find(opt => opt.id === field.value);
                return !!option;
            }
            if (field.type === FormFieldTypes.UPLOAD) {
                return field.value && field.value.length > 0;
            }
            if (field.type === FormFieldTypes.DYNAMIC_TABLE) {
                return field.value && field.value instanceof Array && field.value.length > 0;
            }
            if (field.type === FormFieldTypes.BOOLEAN) {
                return field.value ? true : false;
            }
            if (field.value === null || field.value === undefined || field.value === '') {
                return false;
            }
        }
        return true;
    }
}
class NumberFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    static isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (field.value === null ||
                field.value === undefined ||
                field.value === '') {
                return true;
            }
            let                  valueStr = '' + field.value;
            let                  pattern = new RegExp(/^-?\d+$/);
            if (field.enableFractions) {
                pattern = new RegExp(/^-?[0-9]+(\.[0-9]{1,2})?$/);
            }
            if (valueStr.match(pattern)) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_NUMBER';
            return false;
        }
        return true;
    }
}
class DateFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    static isValidDate(inputDate, dateFormat = 'D-M-YYYY') {
        if (inputDate) {
            let                  d = moment(inputDate, dateFormat, true);
            return d.isValid();
        }
        return false;
    }
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (DateFieldValidator.isValidDate(field.value, field.dateDisplayFormat)) {
                return true;
            }
            field.validationSummary.message = field.dateDisplayFormat;
            return false;
        }
        return true;
    }
}
class MinDateFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.minValue;
    }
    validate(field) {
        let                  isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            const                  dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDate(field, dateFormat);
            }
        }
        return isValid;
    }
    checkDate(field, dateFormat) {
        const                  MIN_DATE_FORMAT = 'DD-MM-YYYY';
        let                  isValid = true;
        let                  fieldValueData;
        if (typeof field.value === 'string') {
            fieldValueData = moment(field.value.split('T')[0], dateFormat);
        }
        else {
            fieldValueData = field.value;
        }
        let                  min = moment(field.minValue, MIN_DATE_FORMAT);
        if (fieldValueData.isBefore(min)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', field.minValue.toLocaleString());
            isValid = false;
        }
        return isValid;
    }
}
class MaxDateFieldValidator {
    constructor() {
        this.MAX_DATE_FORMAT = 'DD-MM-YYYY';
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.maxValue;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            const                  dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                return false;
            }
            let                  d;
            if (typeof field.value === 'string') {
                d = moment(field.value.split('T')[0], dateFormat);
            }
            else {
                d = field.value;
            }
            let                  max = moment(field.maxValue, this.MAX_DATE_FORMAT);
            if (d.isAfter(max)) {
                field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
                field.validationSummary.attributes.set('maxValue', field.maxValue.toLocaleString());
                return false;
            }
        }
        return true;
    }
}
class MinDateTimeFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATETIME
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.minValue;
    }
    validate(field) {
        let                  isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            const                  dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDateTime(field, dateFormat);
            }
        }
        return isValid;
    }
    checkDateTime(field, dateFormat) {
        const                  MIN_DATE_FORMAT = 'YYYY-MM-DD hh:mm A';
        let                  isValid = true;
        let                  fieldValueDate;
        if (typeof field.value === 'string') {
            fieldValueDate = moment(field.value, dateFormat);
        }
        else {
            fieldValueDate = field.value;
        }
        let                  min = moment(field.minValue, MIN_DATE_FORMAT);
        if (fieldValueDate.isBefore(min)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', min.format('D-M-YYYY hh-mm A'));
            isValid = false;
        }
        return isValid;
    }
}
class MaxDateTimeFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATETIME
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.maxValue;
    }
    validate(field) {
        let                  isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            const                  dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDateTime(field, dateFormat);
            }
        }
        return isValid;
    }
    checkDateTime(field, dateFormat) {
        const                  MAX_DATE_FORMAT = 'YYYY-MM-DD hh:mm A';
        let                  isValid = true;
        let                  fieldValueDate;
        if (typeof field.value === 'string') {
            fieldValueDate = moment(field.value, dateFormat);
        }
        else {
            fieldValueDate = field.value;
        }
        let                  max = moment(field.maxValue, MAX_DATE_FORMAT);
        if (fieldValueDate.isAfter(max)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', max.format('D-M-YYYY hh-mm A'));
            isValid = false;
        }
        return isValid;
    }
}
class MinLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.minLength > 0;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length >= field.minLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.AT_LEAST_LONG`;
            field.validationSummary.attributes.set('minLength', field.minLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.maxLength > 0;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length <= field.maxLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NO_LONGER_THAN`;
            field.validationSummary.attributes.set('maxLength', field.maxLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MinValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.minValue);
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            let                  value = +field.value;
            let                  minValue = +field.minValue;
            if (value >= minValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', field.minValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.maxValue);
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            let                  value = +field.value;
            let                  maxValue = +field.maxValue;
            if (value <= maxValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', field.maxValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class RegExFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.regexPattern;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length > 0 && field.value.match(new RegExp('^' + field.regexPattern + '$'))) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            return false;
        }
        return true;
    }
}
class FixedValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TYPEAHEAD
        ];
    }
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    hasValidNameOrValidId(field) {
        return this.hasValidName(field) || this.hasValidId(field);
    }
    hasValidName(field) {
        return field.options.find(item => item.name && item.name.toLocaleLowerCase() === field.value.toLocaleLowerCase()) ? true : false;
    }
    hasValidId(field) {
        return field.options[field.value - 1] ? true : false;
    }
    hasStringValue(field) {
        return field.value && typeof field.value === 'string';
    }
    hasOptions(field) {
        return field.options && field.options.length > 0;
    }
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (this.hasStringValue(field) && this.hasOptions(field) && !this.hasValidNameOrValidId(field)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
                return false;
            }
        }
        return true;
    }
}
const FORM_FIELD_VALIDATORS = [
    new RequiredFieldValidator(),
    new NumberFieldValidator(),
    new MinLengthFieldValidator(),
    new MaxLengthFieldValidator(),
    new MinValueFieldValidator(),
    new MaxValueFieldValidator(),
    new RegExFieldValidator(),
    new DateFieldValidator(),
    new MinDateFieldValidator(),
    new MaxDateFieldValidator(),
    new FixedValueFieldValidator(),
    new MinDateTimeFieldValidator(),
    new MaxDateTimeFieldValidator()
];

class FormFieldModel extends FormWidgetModel {
    constructor(form, json) {
        super(form, json);
        this._readOnly = false;
        this._isValid = true;
        this._required = false;
        this.defaultDateFormat = 'D-M-YYYY';
        this.deafultDateTimeFormat = 'D-M-YYYY hh:mm A';
        this.rowspan = 1;
        this.colspan = 1;
        this.placeholder = null;
        this.minLength = 0;
        this.maxLength = 0;
        this.options = [];
        this.params = {};
        this.isVisible = true;
        this.visibilityCondition = null;
        this.enableFractions = false;
        this.currency = null;
        this.dateDisplayFormat = this.dateDisplayFormat || this.defaultDateFormat;
        this.numberOfColumns = 1;
        this.fields = [];
        this.columns = [];
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this._required =                  (json.required);
            this._readOnly =                  (json.readOnly) || json.type === 'readonly';
            this.overrideId =                  (json.overrideId);
            this.tab = json.tab;
            this.restUrl = json.restUrl;
            this.restResponsePath = json.restResponsePath;
            this.restIdProperty = json.restIdProperty;
            this.restLabelProperty = json.restLabelProperty;
            this.colspan =                  (json.colspan);
            this.minLength =                  (json.minLength) || 0;
            this.maxLength =                  (json.maxLength) || 0;
            this.minValue = json.minValue;
            this.maxValue = json.maxValue;
            this.regexPattern = json.regexPattern;
            this.options =                  (json.options) || [];
            this.hasEmptyValue =                  (json.hasEmptyValue);
            this.className = json.className;
            this.optionType = json.optionType;
            this.params =                  (json.params) || {};
            this.hyperlinkUrl = json.hyperlinkUrl;
            this.displayText = json.displayText;
            this.visibilityCondition =                  (json.visibilityCondition);
            this.enableFractions =                  (json.enableFractions);
            this.currency = json.currency;
            this.dateDisplayFormat = json.dateDisplayFormat || this.getDefaultDateFormat(json);
            this._value = this.parseValue(json);
            this.validationSummary = new ErrorMessageModel();
            if (json.placeholder && json.placeholder !== '' && json.placeholder !== 'null') {
                this.placeholder = json.placeholder;
            }
            if (FormFieldTypes.isReadOnlyType(json.type)) {
                if (json.params && json.params.field) {
                    if (form.processVariables) {
                        const                  processVariable = this.getProcessVariableValue(json.params.field, form);
                        if (processVariable) {
                            this.value = processVariable;
                        }
                    }
                    else if (json.params.field.responseVariable) {
                        const                  formVariable = this.getVariablesValue(json.params.field.name, form);
                        if (formVariable) {
                            this.value = formVariable;
                        }
                    }
                }
            }
            if (FormFieldTypes.isContainerType(json.type)) {
                this.containerFactory(json, form);
            }
        }
        if (this.hasEmptyValue && this.options && this.options.length > 0) {
            this.emptyOption = this.options[0];
        }
        this.updateForm();
    }
    get value() {
        return this._value;
    }
    set value(v) {
        this._value = v;
        this.updateForm();
    }
    get readOnly() {
        if (this.form && this.form.readOnly) {
            return true;
        }
        return this._readOnly;
    }
    set readOnly(readOnly) {
        this._readOnly = readOnly;
        this.updateForm();
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value;
        this.updateForm();
    }
    get isValid() {
        return this._isValid;
    }
    markAsInvalid() {
        this._isValid = false;
    }
    validate() {
        this.validationSummary = new ErrorMessageModel();
        let                  validators = this.form.fieldValidators || [];
        for (let                  validator of validators) {
            if (!validator.validate(this)) {
                this._isValid = false;
                return this._isValid;
            }
        }
        this._isValid = true;
        return this._isValid;
    }
    getDefaultDateFormat(jsonField) {
        let                  originalType = jsonField.type;
        if (FormFieldTypes.isReadOnlyType(jsonField.type) &&
            jsonField.params &&
            jsonField.params.field) {
            originalType = jsonField.params.field.type;
        }
        return originalType === FormFieldTypes.DATETIME ? this.deafultDateTimeFormat : this.defaultDateFormat;
    }
    isTypeaHeadFieldType(type) {
        return type === 'typeahead' ? true : false;
    }
    getFieldNameWithLabel(name) {
        return name += '_LABEL';
    }
    getProcessVariableValue(field, form) {
        let                  fieldName = field.name;
        if (this.isTypeaHeadFieldType(field.type)) {
            fieldName = this.getFieldNameWithLabel(field.id);
        }
        return this.findProcessVariableValue(fieldName, form);
    }
    getVariablesValue(variableName, form) {
        let                  variable = form.json.variables.find((currentVariable) => {
            return currentVariable.name === variableName;
        });
        if (variable) {
            if (variable.type === 'boolean') {
                return JSON.parse(variable.value);
            }
            return variable.value;
        }
        return null;
    }
    findProcessVariableValue(variableName, form) {
        if (form.processVariables) {
            const                  variable = form.processVariables.find((currentVariable) => {
                return currentVariable.name === variableName;
            });
            if (variable) {
                return variable.type === 'boolean' ? JSON.parse(variable.value) : variable.value;
            }
        }
        return undefined;
    }
    containerFactory(json, form) {
        this.numberOfColumns =                  (json.numberOfColumns) || 1;
        this.fields = json.fields;
        this.rowspan = 1;
        this.colspan = 1;
        if (json.fields) {
            for (let                  currentField in json.fields) {
                if (json.fields.hasOwnProperty(currentField)) {
                    let                  col = new ContainerColumnModel();
                    let                  fields = (json.fields[currentField] || []).map(f => new FormFieldModel(form, f));
                    col.fields = fields;
                    col.rowspan = json.fields[currentField].length;
                    col.fields.forEach((colFields) => {
                        this.colspan = colFields.colspan > this.colspan ? colFields.colspan : this.colspan;
                    });
                    this.rowspan = this.rowspan < col.rowspan ? col.rowspan : this.rowspan;
                    this.columns.push(col);
                }
            }
        }
    }
    parseValue(json) {
        let                  value = json.value;
        if (json.type === FormFieldTypes.DROPDOWN) {
            if (json.hasEmptyValue && json.options) {
                let                  options =                  (json.options) || [];
                if (options.length > 0) {
                    let                  emptyOption = json.options[0];
                    if (value === '' || value === emptyOption.id || value === emptyOption.name) {
                        value = emptyOption.id;
                    }
                    else if (value.id && value.name) {
                        value = value.id;
                    }
                }
            }
        }
        if (json.type === FormFieldTypes.RADIO_BUTTONS) {
            let                  entry = this.options.filter(opt => opt.id === value || opt.name === value || (value && (opt.id === value.id || opt.name === value.name)));
            if (entry.length > 0) {
                value = entry[0].id;
            }
            else {
                value = this.options[0] ? this.options[0].id : json.value;
            }
        }
        if (this.isDateField(json) || this.isDateTimeField(json)) {
            if (value) {
                let                  dateValue;
                if (NumberFieldValidator.isNumber(value)) {
                    dateValue = moment(value);
                }
                else {
                    dateValue = this.isDateTimeField(json) ? moment(value, 'YYYY-MM-DD hh:mm A') : moment(value.split('T')[0], 'YYYY-M-D');
                }
                if (dateValue && dateValue.isValid()) {
                    value = dateValue.format(this.dateDisplayFormat);
                }
            }
        }
        return value;
    }
    updateForm() {
        if (!this.form) {
            return;
        }
        switch (this.type) {
            case FormFieldTypes.DROPDOWN:
                if (this.value === 'empty' || this.value === '') {
                    this.form.values[this.id] = {};
                }
                else {
                    let                  entry = this.options.filter(opt => opt.id === this.value);
                    if (entry.length > 0) {
                        this.form.values[this.id] = entry[0];
                    }
                }
                break;
            case FormFieldTypes.RADIO_BUTTONS:
                let                  rbEntry = this.options.filter(opt => opt.id === this.value);
                if (rbEntry.length > 0) {
                    this.form.values[this.id] = rbEntry[0];
                }
                break;
            case FormFieldTypes.UPLOAD:
                if (this.value && this.value.length > 0) {
                    this.form.values[this.id] = this.value.map(elem => elem.id).join(',');
                }
                else {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.TYPEAHEAD:
                let                  taEntry = this.options.filter(opt => opt.id === this.value || opt.name === this.value);
                if (taEntry.length > 0) {
                    this.form.values[this.id] = taEntry[0];
                }
                else if (this.options.length > 0) {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.DATE:
                let                  dateValue = moment(this.value, this.dateDisplayFormat, true);
                if (dateValue && dateValue.isValid()) {
                    this.form.values[this.id] = `${dateValue.format('YYYY-MM-DD')}T00:00:00.000Z`;
                }
                else {
                    this.form.values[this.id] = null;
                    this._value = this.value;
                }
                break;
            case FormFieldTypes.DATETIME:
                const                  dateTimeValue = moment(this.value, this.dateDisplayFormat, true);
                if (dateTimeValue && dateTimeValue.isValid()) {
                    this.form.values[this.id] = dateTimeValue.format('YYYY-MM-DDTHH:mm:ssZ');
                }
                else {
                    this.form.values[this.id] = null;
                    this._value = this.value;
                }
                break;
            case FormFieldTypes.NUMBER:
                this.form.values[this.id] = parseInt(this.value, 10);
                break;
            case FormFieldTypes.AMOUNT:
                this.form.values[this.id] = this.enableFractions ? parseFloat(this.value) : parseInt(this.value, 10);
                break;
            default:
                if (!FormFieldTypes.isReadOnlyType(this.type) && !this.isInvalidFieldType(this.type)) {
                    this.form.values[this.id] = this.value;
                }
        }
        this.form.onFormFieldChanged(this);
    }
    isInvalidFieldType(type) {
        if (type === 'container') {
            return true;
        }
        else {
            return false;
        }
    }
    getOptionName() {
        let                  option = this.options.find(opt => opt.id === this.value);
        return option ? option.name : null;
    }
    hasOptions() {
        return this.options && this.options.length > 0;
    }
    isDateField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.DATE) ||
            json.type === FormFieldTypes.DATE;
    }
    isDateTimeField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.DATETIME) ||
            json.type === FormFieldTypes.DATETIME;
    }
}

class ContainerModel extends FormWidgetModel {
    get isVisible() {
        return this.field.isVisible;
    }
    constructor(field) {
        super(field.form, field.json);
        if (field) {
            this.field = field;
        }
    }
}

class FormOutcomeModel extends FormWidgetModel {
    constructor(form, json) {
        super(form, json);
        this.isSystem = false;
        this.isSelected = false;
        if (json) {
            this.isSystem = json.isSystem ? true : false;
            this.isSelected = form && json.name === form.selectedOutcome ? true : false;
        }
    }
}
FormOutcomeModel.SAVE_ACTION = 'Save';
FormOutcomeModel.COMPLETE_ACTION = 'Complete';
FormOutcomeModel.START_PROCESS_ACTION = 'Start Process';

class TabModel extends FormWidgetModel {
    constructor(form, json) {
        super(form, json);
        this.isVisible = true;
        this.fields = [];
        if (json) {
            this.title = json.title;
            this.visibilityCondition =                  (json.visibilityCondition);
        }
    }
    hasContent() {
        return this.fields && this.fields.length > 0;
    }
}

class FormModel {
    constructor(json, data, readOnly = false, formService) {
        this.formService = formService;
        this.taskName = FormModel.UNSET_TASK_NAME;
        this._isValid = true;
        this.readOnly = false;
        this.tabs = [];
        this.fields = [];
        this.outcomes = [];
        this.customFieldTemplates = {};
        this.fieldValidators = [...FORM_FIELD_VALIDATORS];
        this.values = {};
        this.readOnly = readOnly;
        if (json) {
            this.json = json;
            this.id = json.id;
            this.name = json.name;
            this.taskId = json.taskId;
            this.taskName = json.taskName || json.name || FormModel.UNSET_TASK_NAME;
            this.processDefinitionId = json.processDefinitionId;
            this.customFieldTemplates = json.customFieldTemplates || {};
            this.selectedOutcome = json.selectedOutcome || {};
            this.className = json.className || '';
            let                  tabCache = {};
            this.processVariables = json.processVariables;
            this.tabs = (json.tabs || []).map(t => {
                let                  model = new TabModel(this, t);
                tabCache[model.id] = model;
                return model;
            });
            this.fields = this.parseRootFields(json);
            if (data) {
                this.loadData(data);
            }
            for (let                  i = 0; i < this.fields.length; i++) {
                let                  field = this.fields[i];
                if (field.tab) {
                    let                  tab = tabCache[field.tab];
                    if (tab) {
                        tab.fields.push(field);
                    }
                }
            }
            if (json.fields) {
                let                  saveOutcome = new FormOutcomeModel(this, { id: FormModel.SAVE_OUTCOME, name: 'Save', isSystem: true });
                let                  completeOutcome = new FormOutcomeModel(this, { id: FormModel.COMPLETE_OUTCOME, name: 'Complete', isSystem: true });
                let                  startProcessOutcome = new FormOutcomeModel(this, { id: FormModel.START_PROCESS_OUTCOME, name: 'Start Process', isSystem: true });
                let                  customOutcomes = (json.outcomes || []).map(obj => new FormOutcomeModel(this, obj));
                this.outcomes = [saveOutcome].concat(customOutcomes.length > 0 ? customOutcomes : [completeOutcome, startProcessOutcome]);
            }
        }
        this.validateForm();
    }
    get isValid() {
        return this._isValid;
    }
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
    hasOutcomes() {
        return this.outcomes && this.outcomes.length > 0;
    }
    onFormFieldChanged(field) {
        this.validateField(field);
        if (this.formService) {
            this.formService.formFieldValueChanged.next(new FormFieldEvent(this, field));
        }
    }
    getFieldById(fieldId) {
        return this.getFormFields().find(field => field.id === fieldId);
    }
    getFormFields() {
        let                  result = [];
        for (let                  i = 0; i < this.fields.length; i++) {
            let                  field = this.fields[i];
            if (field instanceof ContainerModel) {
                let                  container =                  (field);
                result.push(container.field);
                container.field.columns.forEach((column) => {
                    result.push(...column.fields);
                });
            }
        }
        return result;
    }
    markAsInvalid() {
        this._isValid = false;
    }
    validateForm() {
        const                  validateFormEvent = new ValidateFormEvent(this);
        if (this.formService) {
            this.formService.validateForm.next(validateFormEvent);
        }
        this._isValid = validateFormEvent.isValid;
        if (validateFormEvent.defaultPrevented) {
            return;
        }
        if (validateFormEvent.isValid) {
            let                  fields = this.getFormFields();
            for (let                  i = 0; i < fields.length; i++) {
                if (!fields[i].validate()) {
                    this._isValid = false;
                    return;
                }
            }
        }
    }
    validateField(field) {
        if (!field) {
            return;
        }
        const                  validateFieldEvent = new ValidateFormFieldEvent(this, field);
        if (this.formService) {
            this.formService.validateFormField.next(validateFieldEvent);
        }
        if (!validateFieldEvent.isValid) {
            this._isValid = false;
            return;
        }
        if (validateFieldEvent.defaultPrevented) {
            return;
        }
        if (!field.validate()) {
            this._isValid = false;
            return;
        }
        this.validateForm();
    }
    parseRootFields(json) {
        let                  fields = [];
        if (json.fields) {
            fields = json.fields;
        }
        else if (json.formDefinition && json.formDefinition.fields) {
            fields = json.formDefinition.fields;
        }
        let                  result = [];
        for (let                  field of fields) {
            if (field.type === FormFieldTypes.DISPLAY_VALUE) {
                if (field.params) {
                    let                  originalField = field.params['field'];
                    if (originalField.type === FormFieldTypes.DYNAMIC_TABLE) {
                        result.push(new ContainerModel(new FormFieldModel(this, field)));
                    }
                }
            }
            else {
                result.push(new ContainerModel(new FormFieldModel(this, field)));
            }
        }
        return result;
    }
    loadData(data) {
        for (let                  field of this.getFormFields()) {
            if (data[field.id]) {
                field.json.value = data[field.id];
                field.value = field.parseValue(field.json);
            }
        }
    }
}
FormModel.UNSET_TASK_NAME = 'Nameless task';
FormModel.SAVE_OUTCOME = '$save';
FormModel.COMPLETE_OUTCOME = '$complete';
FormModel.START_PROCESS_OUTCOME = '$startProcess';

class FormOutcomeEvent {
    constructor(outcome) {
        this._defaultPrevented = false;
        this._outcome = outcome;
    }
    get outcome() {
        return this._outcome;
    }
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    preventDefault() {
        this._defaultPrevented = true;
    }
}

class ContentLinkModel {
    constructor(obj) {
        this.contentAvailable = obj && obj.contentAvailable;
        this.created = obj && obj.created;
        this.createdBy = obj && obj.createdBy || {};
        this.id = obj && obj.id;
        this.link = obj && obj.link;
        this.mimeType = obj && obj.mimeType;
        this.name = obj && obj.name;
        this.previewStatus = obj && obj.previewStatus;
        this.relatedContent = obj && obj.relatedContent;
        this.simpleType = obj && obj.simpleType;
        this.thumbnailStatus = obj && obj.thumbnailStatus;
    }
    hasPreviewStatus() {
        return this.previewStatus === 'supported' ? true : false;
    }
    isTypeImage() {
        return this.simpleType === 'image' ? true : false;
    }
    isTypePdf() {
        return this.simpleType === 'pdf' ? true : false;
    }
    isTypeDoc() {
        return this.simpleType === 'word' || this.simpleType === 'content' ? true : false;
    }
    isThumbnailReady() {
        return this.thumbnailStatus === 'created';
    }
    isThumbnailSupported() {
        return this.isTypeImage() || ((this.isTypePdf() || this.isTypeDoc()) && this.isThumbnailReady());
    }
}

class FormService {
    constructor(ecmModelService, apiService, logService) {
        this.ecmModelService = ecmModelService;
        this.apiService = apiService;
        this.logService = logService;
        this.formLoaded = new Subject();
        this.formDataRefreshed = new Subject();
        this.formFieldValueChanged = new Subject();
        this.formEvents = new Subject();
        this.taskCompleted = new Subject();
        this.taskCompletedError = new Subject();
        this.taskSaved = new Subject();
        this.taskSavedError = new Subject();
        this.formContentClicked = new Subject();
        this.validateForm = new Subject();
        this.validateFormField = new Subject();
        this.validateDynamicTableRow = new Subject();
        this.executeOutcome = new Subject();
    }
    get taskApi() {
        return this.apiService.getInstance().activiti.taskApi;
    }
    get modelsApi() {
        return this.apiService.getInstance().activiti.modelsApi;
    }
    get editorApi() {
        return this.apiService.getInstance().activiti.editorApi;
    }
    get processApi() {
        return this.apiService.getInstance().activiti.processApi;
    }
    get processInstanceVariablesApi() {
        return this.apiService.getInstance().activiti.processInstanceVariablesApi;
    }
    get usersWorkflowApi() {
        return this.apiService.getInstance().activiti.usersWorkflowApi;
    }
    get groupsApi() {
        return this.apiService.getInstance().activiti.groupsApi;
    }
    parseForm(json, data, readOnly = false) {
        if (json) {
            let                  form = new FormModel(json, data, readOnly, this);
            if (!json.fields) {
                form.outcomes = [
                    new FormOutcomeModel(form, {
                        id: '$custom',
                        name: FormOutcomeModel.SAVE_ACTION,
                        isSystem: true
                    })
                ];
            }
            return form;
        }
        return null;
    }
    createFormFromANode(formName) {
        return Observable.create(observer => {
            this.createForm(formName).subscribe(form => {
                this.ecmModelService.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe(customType => {
                    let                  formDefinitionModel = new FormDefinitionModel(form.id, form.name, form.lastUpdatedByFullName, form.lastUpdated, customType.entry.properties);
                    this.addFieldsToAForm(form.id, formDefinitionModel).subscribe(formData => {
                        observer.next(formData);
                        observer.complete();
                    }, err => this.handleError(err));
                }, err => this.handleError(err));
            }, err => this.handleError(err));
        });
    }
    createForm(formName) {
        let                  dataModel = {
            name: formName,
            description: '',
            modelType: 2,
            stencilSet: 0
        };
        return Observable.fromPromise(this.modelsApi.createModel(dataModel));
    }
    saveForm(formId, formModel) {
        return Observable.fromPromise(this.editorApi.saveForm(formId, formModel));
    }
    addFieldsToAForm(formId, formModel) {
        this.logService.log('addFieldsToAForm is deprecated in 1.7.0, use saveForm API instead');
        return Observable.fromPromise(this.editorApi.saveForm(formId, formModel));
    }
    searchFrom(name) {
        let                  opts = {
            'modelType': 2
        };
        return Observable.fromPromise(this.modelsApi.getModels(opts))
            .map(function (forms) {
            return forms.data.find(formdata => formdata.name === name);
        })
            .catch(err => this.handleError(err));
    }
    getForms() {
        let                  opts = {
            'modelType': 2
        };
        return Observable.fromPromise(this.modelsApi.getModels(opts))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    getProcessDefinitions() {
        return Observable.fromPromise(this.processApi.getProcessDefinitions({}))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    getProcessVarablesById(processInstanceId) {
        return Observable.fromPromise(this.processInstanceVariablesApi.getProcessInstanceVariables(processInstanceId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getTasks() {
        return Observable.fromPromise(this.taskApi.listTasks({}))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    getTask(taskId) {
        return Observable.fromPromise(this.taskApi.getTask(taskId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    saveTaskForm(taskId, formValues) {
        let                  body = JSON.stringify({ values: formValues });
        return Observable.fromPromise(this.taskApi.saveTaskForm(taskId, body))
            .catch(err => this.handleError(err));
    }
    completeTaskForm(taskId, formValues, outcome) {
        let                  data = { values: formValues };
        if (outcome) {
            data.outcome = outcome;
        }
        let                  body = JSON.stringify(data);
        return Observable.fromPromise(this.taskApi.completeTaskForm(taskId, body))
            .catch(err => this.handleError(err));
    }
    getTaskForm(taskId) {
        return Observable.fromPromise(this.taskApi.getTaskForm(taskId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getFormDefinitionById(formId) {
        return Observable.fromPromise(this.editorApi.getForm(formId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getFormDefinitionByName(name) {
        let                  opts = {
            'filter': 'myReusableForms',
            'filterText': name,
            'modelType': 2
        };
        return Observable.fromPromise(this.modelsApi.getModels(opts))
            .map(this.getFormId)
            .catch(err => this.handleError(err));
    }
    getStartFormInstance(processId) {
        return Observable.fromPromise(this.processApi.getProcessInstanceStartForm(processId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getProcessIntance(processId) {
        return Observable.fromPromise(this.processApi.getProcessInstance(processId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getStartFormDefinition(processId) {
        return Observable.fromPromise(this.processApi.getProcessDefinitionStartForm(processId))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    getRestFieldValues(taskId, field) {
        return Observable.fromPromise(this.taskApi.getRestFieldValues(taskId, field)).catch(err => this.handleError(err));
    }
    getRestFieldValuesByProcessId(processDefinitionId, field) {
        return Observable.fromPromise(this.processApi.getRestFieldValues(processDefinitionId, field)).catch(err => this.handleError(err));
    }
    getRestFieldValuesColumnByProcessId(processDefinitionId, field, column) {
        return Observable.fromPromise(this.processApi.getRestTableFieldValues(processDefinitionId, field, column)).catch(err => this.handleError(err));
    }
    getRestFieldValuesColumn(taskId, field, column) {
        return Observable.fromPromise(this.taskApi.getRestFieldValuesColumn(taskId, field, column)).catch(err => this.handleError(err));
    }
    getUserProfileImageApi(userId) {
        return this.apiService.getInstance().activiti.userApi.getUserProfilePictureUrl(userId);
    }
    getWorkflowUsers(filter, groupId) {
        let                  option = { filter: filter };
        if (groupId) {
            option.groupId = groupId;
        }
        return Observable.fromPromise(this.usersWorkflowApi.getUsers(option))
            .switchMap((response) =>                  (response.data) || [])
            .map((user) => {
            user.userImage = this.getUserProfileImageApi(user.id);
            return Observable.of(user);
        })
            .combineAll()
            .defaultIfEmpty([])
            .catch(err => this.handleError(err));
    }
    getWorkflowGroups(filter, groupId) {
        let                  option = { filter: filter };
        if (groupId) {
            option.groupId = groupId;
        }
        return Observable.fromPromise(this.groupsApi.getGroups(option))
            .map((response) =>                  (response.data) || [])
            .catch(err => this.handleError(err));
    }
    getFormId(res) {
        let                  result = null;
        if (res && res.data && res.data.length > 0) {
            result = res.data[0].id;
        }
        return result;
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    handleError(error) {
        let                  errMsg = FormService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : FormService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return Observable.throw(errMsg);
    }
}
FormService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
FormService.GENERIC_ERROR_MESSAGE = 'Server error';
FormService.decorators = [
    { type: Injectable },
];
FormService.ctorParameters = () => [
    { type: EcmModelService, },
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class NodeMetadata {
    constructor(metadata, nodeType) {
        this.metadata = metadata;
        this.nodeType = nodeType;
    }
}

class NodeService {
    constructor(apiService) {
        this.apiService = apiService;
    }
    getNodeMetadata(nodeId) {
        return Observable.fromPromise(this.apiService.getInstance().nodes.getNodeInfo(nodeId)).map(this.cleanMetadataFromSemicolon);
    }
    createNodeMetadata(nodeType, nameSpace, data, path, name) {
        let                  properties = {};
        for (let                  key in data) {
            if (data[key]) {
                properties[nameSpace + ':' + key] = data[key];
            }
        }
        return this.createNode(name || this.generateUuid(), nodeType, properties, path);
    }
    createNode(name, nodeType, properties, path) {
        let                  body = {
            name: name,
            nodeType: nodeType,
            properties: properties,
            relativePath: path
        };
        let                  apiService = this.apiService.getInstance();
        return Observable.fromPromise(apiService.nodes.addNode('-root-', body, {}));
    }
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            let                  r = Math.random() * 16 | 0,                  v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    cleanMetadataFromSemicolon(data) {
        let                  metadata = {};
        if (data && data.properties) {
            for (let                  key in data.properties) {
                if (key) {
                    if (key.indexOf(':') !== -1) {
                        metadata[key.split(':')[1]] = data.properties[key];
                    }
                    else {
                        metadata[key] = data.properties[key];
                    }
                }
            }
        }
        return new NodeMetadata(metadata, data.nodeType);
    }
}
NodeService.decorators = [
    { type: Injectable },
];
NodeService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class WidgetVisibilityService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    refreshVisibility(form) {
        if (form && form.tabs && form.tabs.length > 0) {
            form.tabs.map(tabModel => this.refreshEntityVisibility(tabModel));
        }
        if (form) {
            form.getFormFields().map(field => this.refreshEntityVisibility(field));
        }
    }
    refreshEntityVisibility(element) {
        let                  visible = this.evaluateVisibility(element.form, element.visibilityCondition);
        element.isVisible = visible;
    }
    evaluateVisibility(form, visibilityObj) {
        let                  isLeftFieldPresent = visibilityObj && (visibilityObj.leftFormFieldId || visibilityObj.leftRestResponseId);
        if (!isLeftFieldPresent || isLeftFieldPresent === 'null') {
            return true;
        }
        else {
            return this.isFieldVisible(form, visibilityObj);
        }
    }
    isFieldVisible(form, visibilityObj) {
        let                  leftValue = this.getLeftValue(form, visibilityObj);
        let                  rightValue = this.getRightValue(form, visibilityObj);
        let                  actualResult = this.evaluateCondition(leftValue, rightValue, visibilityObj.operator);
        if (visibilityObj.nextCondition) {
            return this.evaluateLogicalOperation(visibilityObj.nextConditionOperator, actualResult, this.isFieldVisible(form, visibilityObj.nextCondition));
        }
        else {
            return actualResult;
        }
    }
    getLeftValue(form, visibilityObj) {
        let                  leftValue = '';
        if (visibilityObj.leftRestResponseId && visibilityObj.leftRestResponseId !== 'null') {
            leftValue = this.getVariableValue(form, visibilityObj.leftRestResponseId, this.processVarList);
        }
        else {
            leftValue = this.getVariableValue(form, visibilityObj.leftFormFieldId, this.processVarList);
            leftValue = leftValue ? leftValue : this.getFormValue(form, visibilityObj.leftFormFieldId);
        }
        return leftValue;
    }
    getRightValue(form, visibilityObj) {
        let                  valueFound = '';
        if (visibilityObj.rightRestResponseId) {
            valueFound = this.getVariableValue(form, visibilityObj.rightRestResponseId, this.processVarList);
        }
        else if (visibilityObj.rightFormFieldId) {
            valueFound = this.getFormValue(form, visibilityObj.rightFormFieldId);
        }
        else {
            if (moment(visibilityObj.rightValue, 'YYYY-MM-DD', true).isValid()) {
                valueFound = visibilityObj.rightValue + 'T00:00:00.000Z';
            }
            else {
                valueFound = visibilityObj.rightValue;
            }
        }
        return valueFound;
    }
    getFormValue(form, fieldId) {
        let                  value = this.getFieldValue(form.values, fieldId);
        if (!value) {
            value = this.searchValueInForm(form, fieldId);
        }
        return value;
    }
    getFieldValue(valueList, fieldId) {
        let                  dropDownFilterByName,                  valueFound;
        if (fieldId && fieldId.indexOf('_LABEL') > 0) {
            dropDownFilterByName = fieldId.substring(0, fieldId.length - 6);
            if (valueList[dropDownFilterByName]) {
                valueFound = valueList[dropDownFilterByName].name;
            }
        }
        else if (valueList[fieldId] && valueList[fieldId].id) {
            valueFound = valueList[fieldId].id;
        }
        else {
            valueFound = valueList[fieldId];
        }
        return valueFound;
    }
    searchValueInForm(form, fieldId) {
        let                  fieldValue = '';
        form.getFormFields().forEach((formField) => {
            if (this.isSearchedField(formField, fieldId)) {
                fieldValue = this.getObjectValue(formField, fieldId);
                if (!fieldValue) {
                    if (formField.value && formField.value.id) {
                        fieldValue = formField.value.id;
                    }
                    else {
                        fieldValue = formField.value;
                    }
                }
            }
        });
        return fieldValue;
    }
    getObjectValue(field, fieldId) {
        let                  value = '';
        if (field.value && field.value.name) {
            value = field.value.name;
        }
        else if (field.options) {
            let                  option = field.options.find(opt => opt.id === field.value);
            if (option) {
                value = this.getValueFromOption(fieldId, option);
            }
        }
        return value;
    }
    getValueFromOption(fieldId, option) {
        let                  optionValue = '';
        if (fieldId && fieldId.indexOf('_LABEL') > 0) {
            optionValue = option.name;
        }
        else {
            optionValue = option.id;
        }
        return optionValue;
    }
    isSearchedField(field, fieldToFind) {
        let                  formattedFieldName = this.removeLabel(field, fieldToFind);
        return field.id ? field.id.toUpperCase() === formattedFieldName.toUpperCase() : false;
    }
    removeLabel(field, fieldToFind) {
        let                  formattedFieldName = fieldToFind || '';
        if (field.fieldType === 'RestFieldRepresentation' && fieldToFind.indexOf('_LABEL') > 0) {
            formattedFieldName = fieldToFind.substring(0, fieldToFind.length - 6);
        }
        return formattedFieldName;
    }
    getVariableValue(form, name, processVarList) {
        return this.getFormVariableValue(form, name) ||
            this.getProcessVariableValue(name, processVarList);
    }
    getFormVariableValue(form, name) {
        if (form.json.variables) {
            let                  formVariable = form.json.variables.find(formVar => formVar.name === name);
            return formVariable ? formVariable.value : formVariable;
        }
    }
    getProcessVariableValue(name, processVarList) {
        if (this.processVarList) {
            let                  processVariable = this.processVarList.find(variable => variable.id === name);
            return processVariable ? processVariable.value : processVariable;
        }
    }
    evaluateLogicalOperation(logicOp, previousValue, newValue) {
        switch (logicOp) {
            case 'and':
                return previousValue && newValue;
            case 'or':
                return previousValue || newValue;
            case 'and-not':
                return previousValue && !newValue;
            case 'or-not':
                return previousValue || !newValue;
            default:
                this.logService.error('NO valid operation! wrong op request : ' + logicOp);
                break;
        }
    }
    evaluateCondition(leftValue, rightValue, operator) {
        switch (operator) {
            case '==':
                return leftValue + '' === rightValue + '';
            case '<':
                return leftValue < rightValue;
            case '!=':
                return leftValue + '' !== rightValue + '';
            case '>':
                return leftValue > rightValue;
            case '>=':
                return leftValue >= rightValue;
            case '<=':
                return leftValue <= rightValue;
            case 'empty':
                return leftValue ? leftValue === '' : true;
            case '!empty':
                return leftValue ? leftValue !== '' : false;
            default:
                this.logService.error('NO valid operation!');
                break;
        }
        return;
    }
    cleanProcessVariable() {
        this.processVarList = [];
    }
    getTaskProcessVariable(taskId) {
        return Observable.fromPromise(this.apiService.getInstance().activiti.taskFormsApi.getTaskFormVariables(taskId))
            .map(res => {
            let                  jsonRes = this.toJson(res);
            this.processVarList =                  (jsonRes);
            return jsonRes;
        })
            .catch(err => this.handleError(err));
    }
    toJson(res) {
        return res || {};
    }
    handleError(err) {
        this.logService.error('Error while performing a call');
        return Observable.throw('Error while performing a call - Server error');
    }
}
WidgetVisibilityService.decorators = [
    { type: Injectable },
];
WidgetVisibilityService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class FormComponent {
    constructor(formService, visibilityService, ecmModelService, nodeService) {
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.ecmModelService = ecmModelService;
        this.nodeService = nodeService;
        this.saveMetadata = false;
        this.showTitle = true;
        this.showCompleteButton = true;
        this.disableCompleteButton = false;
        this.disableStartProcessButton = false;
        this.showSaveButton = true;
        this.showDebugButton = false;
        this.readOnly = false;
        this.showRefreshButton = true;
        this.showValidationIcon = true;
        this.fieldValidators = [];
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.formLoaded = new EventEmitter();
        this.formDataRefreshed = new EventEmitter();
        this.executeOutcome = new EventEmitter();
        this.onError = new EventEmitter();
        this.debugMode = false;
    }
    hasForm() {
        return this.form ? true : false;
    }
    isTitleEnabled() {
        if (this.showTitle) {
            if (this.form && this.form.taskName) {
                return true;
            }
        }
        return false;
    }
    getColorForOutcome(outcomeName) {
        return outcomeName === FormComponent.COMPLETE_OUTCOME_NAME ? FormComponent.COMPLETE_BUTTON_COLOR : '';
    }
    isOutcomeButtonEnabled(outcome) {
        if (this.form.readOnly) {
            return false;
        }
        if (outcome) {
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return true;
            }
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.disableCompleteButton ? false : this.form.isValid;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return this.disableStartProcessButton ? false : this.form.isValid;
            }
            return this.form.isValid;
        }
        return false;
    }
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.name) {
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.showCompleteButton;
            }
            if (isFormReadOnly) {
                return outcome.isSelected;
            }
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return this.showSaveButton;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return false;
            }
            return true;
        }
        return false;
    }
    ngOnInit() {
        this.formService.formContentClicked.subscribe((content) => {
            this.formContentClicked.emit(content);
        });
    }
    ngOnChanges(changes) {
        let                  taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.getFormByTaskId(taskId.currentValue);
            return;
        }
        let                  formId = changes['formId'];
        if (formId && formId.currentValue) {
            this.getFormDefinitionByFormId(formId.currentValue);
            return;
        }
        let                  formName = changes['formName'];
        if (formName && formName.currentValue) {
            this.getFormDefinitionByFormName(formName.currentValue);
            return;
        }
        let                  nodeId = changes['nodeId'];
        if (nodeId && nodeId.currentValue) {
            this.loadFormForEcmNode(nodeId.currentValue);
            return;
        }
        let                  data = changes['data'];
        if (data && data.currentValue) {
            this.refreshFormData();
            return;
        }
    }
    onOutcomeClicked(outcome) {
        if (!this.readOnly && outcome && this.form) {
            if (!this.onExecuteOutcome(outcome)) {
                return false;
            }
            if (outcome.isSystem) {
                if (outcome.id === FormComponent.SAVE_OUTCOME_ID) {
                    this.saveTaskForm();
                    return true;
                }
                if (outcome.id === FormComponent.COMPLETE_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormComponent.START_PROCESS_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormComponent.CUSTOM_OUTCOME_ID) {
                    this.onTaskSaved(this.form);
                    this.storeFormAsMetadata();
                    return true;
                }
            }
            else {
                if (outcome.name) {
                    this.onTaskSaved(this.form);
                    this.completeTaskForm(outcome.name);
                    return true;
                }
            }
        }
        return false;
    }
    onRefreshClicked() {
        this.loadForm();
    }
    loadForm() {
        if (this.taskId) {
            this.getFormByTaskId(this.taskId);
            return;
        }
        if (this.formId) {
            this.getFormDefinitionByFormId(this.formId);
            return;
        }
        if (this.formName) {
            this.getFormDefinitionByFormName(this.formName);
            return;
        }
    }
    findProcessVariablesByTaskId(taskId) {
        return this.formService.getTask(taskId).
            switchMap((task) => {
            if (this.isAProcessTask(task)) {
                return this.visibilityService.getTaskProcessVariable(taskId);
            }
            else {
                return Observable.of({});
            }
        });
    }
    isAProcessTask(taskRepresentation) {
        return taskRepresentation.processDefinitionId && taskRepresentation.processDefinitionDeploymentId !== 'null';
    }
    getFormByTaskId(taskId) {
        return new Promise((resolve, reject) => {
            this.findProcessVariablesByTaskId(taskId).subscribe((processVariables) => {
                this.formService
                    .getTaskForm(taskId)
                    .subscribe(form => {
                    const                  parsedForm = this.parseForm(form);
                    this.visibilityService.refreshVisibility(parsedForm);
                    parsedForm.validateForm();
                    this.form = parsedForm;
                    this.onFormLoaded(this.form);
                    resolve(this.form);
                }, error => {
                    this.handleError(error);
                    resolve(null);
                });
            });
        });
    }
    getFormDefinitionByFormId(formId) {
        this.formService
            .getFormDefinitionById(formId)
            .subscribe(form => {
            this.formName = form.name;
            this.form = this.parseForm(form);
            this.visibilityService.refreshVisibility(this.form);
            this.form.validateForm();
            this.onFormLoaded(this.form);
        }, (error) => {
            this.handleError(error);
        });
    }
    getFormDefinitionByFormName(formName) {
        this.formService
            .getFormDefinitionByName(formName)
            .subscribe(id => {
            this.formService.getFormDefinitionById(id).subscribe(form => {
                this.form = this.parseForm(form);
                this.visibilityService.refreshVisibility(this.form);
                this.form.validateForm();
                this.onFormLoaded(this.form);
            }, (error) => {
                this.handleError(error);
            });
        }, (error) => {
            this.handleError(error);
        });
    }
    saveTaskForm() {
        if (this.form && this.form.taskId) {
            this.formService
                .saveTaskForm(this.form.taskId, this.form.values)
                .subscribe(() => {
                this.onTaskSaved(this.form);
                this.storeFormAsMetadata();
            }, error => this.onTaskSavedError(this.form, error));
        }
    }
    completeTaskForm(outcome) {
        if (this.form && this.form.taskId) {
            this.formService
                .completeTaskForm(this.form.taskId, this.form.values, outcome)
                .subscribe(() => {
                this.onTaskCompleted(this.form);
                this.storeFormAsMetadata();
            }, error => this.onTaskCompletedError(this.form, error));
        }
    }
    handleError(err) {
        this.onError.emit(err);
    }
    parseForm(json) {
        if (json) {
            let                  form = new FormModel(json, this.data, this.readOnly, this.formService);
            if (!json.fields) {
                form.outcomes = this.getFormDefinitionOutcomes(form);
            }
            if (this.fieldValidators && this.fieldValidators.length > 0) {
                form.fieldValidators = this.fieldValidators;
            }
            return form;
        }
        return null;
    }
    getFormDefinitionOutcomes(form) {
        return [
            new FormOutcomeModel(form, { id: '$custom', name: FormOutcomeModel.SAVE_ACTION, isSystem: true })
        ];
    }
    checkVisibility(field) {
        if (field && field.form) {
            this.visibilityService.refreshVisibility(field.form);
        }
    }
    refreshFormData() {
        this.form = this.parseForm(this.form.json);
        this.onFormLoaded(this.form);
        this.onFormDataRefreshed(this.form);
    }
    loadFormForEcmNode(nodeId) {
        this.nodeService.getNodeMetadata(nodeId).subscribe(data => {
            this.data = data.metadata;
            this.loadFormFromActiviti(data.nodeType);
        }, this.handleError);
    }
    loadFormFromActiviti(nodeType) {
        this.formService.searchFrom(nodeType).subscribe(form => {
            if (!form) {
                this.formService.createFormFromANode(nodeType).subscribe(formMetadata => {
                    this.loadFormFromFormId(formMetadata.id);
                });
            }
            else {
                this.loadFormFromFormId(form.id);
            }
        }, (error) => {
            this.handleError(error);
        });
    }
    loadFormFromFormId(formId) {
        this.formId = formId;
        this.loadForm();
    }
    storeFormAsMetadata() {
        if (this.saveMetadata) {
            this.ecmModelService.createEcmTypeForActivitiForm(this.formName, this.form).subscribe(type => {
                this.nodeService.createNodeMetadata(type.nodeType || type.entry.prefixedName, EcmModelService.MODEL_NAMESPACE, this.form.values, this.path, this.nameNode);
            }, (error) => {
                this.handleError(error);
            });
        }
    }
    onFormLoaded(form) {
        this.formLoaded.emit(form);
        this.formService.formLoaded.next(new FormEvent(form));
    }
    onFormDataRefreshed(form) {
        this.formDataRefreshed.emit(form);
        this.formService.formDataRefreshed.next(new FormEvent(form));
    }
    onTaskSaved(form) {
        this.formSaved.emit(form);
        this.formService.taskSaved.next(new FormEvent(form));
    }
    onTaskSavedError(form, error) {
        this.handleError(error);
        this.formService.taskSavedError.next(new FormErrorEvent(form, error));
    }
    onTaskCompleted(form) {
        this.formCompleted.emit(form);
        this.formService.taskCompleted.next(new FormEvent(form));
    }
    onTaskCompletedError(form, error) {
        this.handleError(error);
        this.formService.taskCompletedError.next(new FormErrorEvent(form, error));
    }
    onExecuteOutcome(outcome) {
        let                  args = new FormOutcomeEvent(outcome);
        this.formService.executeOutcome.next(args);
        if (args.defaultPrevented) {
            return false;
        }
        this.executeOutcome.emit(args);
        if (args.defaultPrevented) {
            return false;
        }
        return true;
    }
}
FormComponent.SAVE_OUTCOME_ID = '$save';
FormComponent.COMPLETE_OUTCOME_ID = '$complete';
FormComponent.START_PROCESS_OUTCOME_ID = '$startProcess';
FormComponent.CUSTOM_OUTCOME_ID = '$custom';
FormComponent.COMPLETE_BUTTON_COLOR = 'primary';
FormComponent.COMPLETE_OUTCOME_NAME = 'Complete';
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form',
                template: `<div *ngIf="!hasForm()">
    <ng-content select="[empty-form]">
    </ng-content>
</div>
<div *ngIf="hasForm()" class="{{form.className}} adf-form-container">
    <mat-card>
        <mat-card-header>
            <mat-card-title>
                <h4 *ngIf="isTitleEnabled()">
                    <div *ngIf="showRefreshButton" class="adf-form-reload-button">
                        <button mat-icon-button (click)="onRefreshClicked()">
                            <mat-icon>refresh</mat-icon>
                        </button>
                    </div>
                    <span class="adf-form-title">{{form.taskName}}</span>

                </h4>
            </mat-card-title>
        </mat-card-header>
        <mat-card-content>
            <div *ngIf="form.hasTabs()">
                <tabs-widget [tabs]="form.tabs" (formTabChanged)="onFieldChanged($event);"></tabs-widget>
            </div>

            <div *ngIf="!form.hasTabs() && form.hasFields()">
                <div *ngFor="let field of form.fields">
                    <form-field [field]="field.field"></form-field>
                </div>
            </div>
        </mat-card-content>
        <mat-card-actions *ngIf="form.hasOutcomes()" class="adf-form-mat-card-actions">
            <!--[class.mdl-button--colored]="!outcome.isSystem"-->
            <button [id]="'adf-form-'+ outcome.name  | lowercase" *ngFor="let outcome of form.outcomes"
                    [color]="getColorForOutcome(outcome.name)"
                    mat-button
                    [disabled]="!isOutcomeButtonEnabled(outcome)"
                    [class.adf-form-hide-button]="!isOutcomeButtonVisible(outcome, form.readOnly)"
                    (click)="onOutcomeClicked(outcome, $event)">
                {{outcome.name | uppercase}}
            </button>
        </mat-card-actions>
    </mat-card>
</div>
<!--
For debugging and data visualisation purposes,
will be removed during future revisions
-->
<div *ngIf="showDebugButton" class="adf-form-debug-container">
    <mat-slide-toggle [(ngModel)]="debugMode">Debug mode</mat-slide-toggle>
    <div *ngIf="debugMode && hasForm()">
        <h4>Values</h4>
        <pre>{{form.values | json}}</pre>

        <h4>Form</h4>
        <pre>{{form.json | json}}</pre>
    </div>
</div>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
FormComponent.ctorParameters = () => [
    { type: FormService, },
    { type: WidgetVisibilityService, },
    { type: EcmModelService, },
    { type: NodeService, },
];
FormComponent.propDecorators = {
    "form": [{ type: Input },],
    "taskId": [{ type: Input },],
    "nodeId": [{ type: Input },],
    "formId": [{ type: Input },],
    "formName": [{ type: Input },],
    "saveMetadata": [{ type: Input },],
    "data": [{ type: Input },],
    "path": [{ type: Input },],
    "nameNode": [{ type: Input },],
    "showTitle": [{ type: Input },],
    "showCompleteButton": [{ type: Input },],
    "disableCompleteButton": [{ type: Input },],
    "disableStartProcessButton": [{ type: Input },],
    "showSaveButton": [{ type: Input },],
    "showDebugButton": [{ type: Input },],
    "readOnly": [{ type: Input },],
    "showRefreshButton": [{ type: Input },],
    "showValidationIcon": [{ type: Input },],
    "fieldValidators": [{ type: Input },],
    "formSaved": [{ type: Output },],
    "formCompleted": [{ type: Output },],
    "formContentClicked": [{ type: Output },],
    "formLoaded": [{ type: Output },],
    "formDataRefreshed": [{ type: Output },],
    "executeOutcome": [{ type: Output },],
    "onError": [{ type: Output },],
};

class FormListComponent {
    constructor(formService) {
        this.formService = formService;
        this.forms = [];
    }
    ngOnChanges(changes) {
        this.getForms();
    }
    isEmpty() {
        return this.forms && this.forms.length === 0;
    }
    getForms() {
        this.formService.getForms().subscribe((forms) => {
            this.forms.push(...forms);
        });
    }
}
FormListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-list',
                template: `<adf-datatable *ngIf="!isEmpty()"
    [rows]="forms">
    <data-columns>
        <data-column key="name" type="text" title="Name" class="ellipsis-cell" [sortable]="true"></data-column>
        <data-column key="lastUpdatedByFullName" type="text" title="User" class="ellipsis-cell" [sortable]="true"></data-column>
        <data-column key="lastUpdated" type="date" format="shortDate" title="Date"></data-column>
    </data-columns>
</adf-datatable>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
FormListComponent.ctorParameters = () => [
    { type: FormService, },
];
FormListComponent.propDecorators = {
    "forms": [{ type: Input },],
};

class ProcessContentService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get contentApi() {
        return this.apiService.getInstance().activiti.contentApi;
    }
    createTemporaryRawRelatedContent(file) {
        return Observable.fromPromise(this.contentApi.createTemporaryRawRelatedContent(file)).catch(err => this.handleError(err));
    }
    getFileContent(contentId) {
        return Observable.fromPromise(this.contentApi.getContent(contentId)).catch(err => this.handleError(err));
    }
    getFileRawContent(contentId) {
        return Observable.fromPromise(this.contentApi.getRawContent(contentId)).catch(err => this.handleError(err));
    }
    getContentPreview(contentId) {
        return new Observable(observer => {
            this.contentApi.getContentPreview(contentId).then((result) => {
                observer.next(result);
                observer.complete();
            }, () => {
                this.contentApi.getRawContent(contentId).then((data) => {
                    observer.next(data);
                    observer.complete();
                }, (err) => {
                    observer.error(err);
                    observer.complete();
                });
            });
        });
    }
    getFileRawContentUrl(contentId) {
        return this.contentApi.getRawContentUrl(contentId);
    }
    getContentThumbnail(contentId) {
        return Observable.fromPromise(this.contentApi.getContentThumbnail(contentId)).catch(err => this.handleError(err));
    }
    getTaskRelatedContent(taskId) {
        return Observable.fromPromise(this.contentApi.getRelatedContentForTask(taskId))
            .catch(err => this.handleError(err));
    }
    getProcessRelatedContent(processId) {
        return Observable.fromPromise(this.contentApi.getRelatedContentForProcessInstance(processId))
            .catch(err => this.handleError(err));
    }
    deleteRelatedContent(contentId) {
        return Observable.fromPromise(this.contentApi.deleteContent(contentId))
            .catch(err => this.handleError(err));
    }
    createProcessRelatedContent(processInstanceId, content, opts) {
        return Observable.fromPromise(this.contentApi.createRelatedContentOnProcessInstance(processInstanceId, content, opts))
            .catch(err => this.handleError(err));
    }
    createTaskRelatedContent(taskId, file, opts) {
        return Observable.fromPromise(this.contentApi.createRelatedContentOnTask(taskId, file, opts))
            .catch(err => this.handleError(err));
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    handleError(error) {
        let                  errMsg = ProcessContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ProcessContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return Observable.throw(errMsg);
    }
}
ProcessContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ProcessContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ProcessContentService.decorators = [
    { type: Injectable },
];
ProcessContentService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class ContentWidgetComponent {
    constructor(formService, logService, contentService, processContentService) {
        this.formService = formService;
        this.logService = logService;
        this.contentService = contentService;
        this.processContentService = processContentService;
        this.showDocumentContent = true;
        this.contentClick = new EventEmitter();
        this.thumbnailLoaded = new EventEmitter();
        this.contentLoaded = new EventEmitter();
        this.error = new EventEmitter();
    }
    ngOnChanges(changes) {
        const                  contentId = changes['id'];
        if (contentId && contentId.currentValue) {
            this.loadContent(contentId.currentValue);
        }
    }
    loadContent(id) {
        this.processContentService
            .getFileContent(id)
            .subscribe((response) => {
            this.content = new ContentLinkModel(response);
            this.contentLoaded.emit(this.content);
            this.loadThumbnailUrl(this.content);
        }, (error) => {
            this.error.emit(error);
        });
    }
    loadThumbnailUrl(content) {
        if (this.content.isThumbnailSupported()) {
            let                  observable;
            if (this.content.isTypeImage()) {
                observable = this.processContentService.getFileRawContent(content.id);
            }
            else {
                observable = this.processContentService.getContentThumbnail(content.id);
            }
            if (observable) {
                observable.subscribe((response) => {
                    this.content.thumbnailUrl = this.contentService.createTrustedUrl(response);
                    this.thumbnailLoaded.emit(this.content.thumbnailUrl);
                }, (error) => {
                    this.error.emit(error);
                });
            }
        }
    }
    openViewer(content) {
        let                  fetch = this.processContentService.getContentPreview(content.id);
        if (content.isTypeImage() || content.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(content.id);
        }
        fetch.subscribe((blob) => {
            content.contentBlob = blob;
            this.contentClick.emit(content);
            this.logService.info('Content clicked' + content.id);
            this.formService.formContentClicked.next(content);
        }, (error) => {
            this.error.emit(error);
        });
    }
    download(content) {
        this.processContentService.getFileRawContent(content.id).subscribe((blob) => this.contentService.downloadBlob(blob, content.name), (error) => {
            this.error.emit(error);
        });
    }
}
ContentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content',
                template: `<mat-card class="adf-content-container" *ngIf="content">
    <mat-card-content *ngIf="showDocumentContent">
        <div *ngIf="content.isThumbnailSupported()" >
            <img id="thumbnailPreview" class="adf-img-upload-widget" [src]="content.thumbnailUrl" alt="{{content.name}}">
        </div>
        <div *ngIf="!content.isThumbnailSupported()">
            <mat-icon>image</mat-icon>
            <div id="unsupported-thumbnail" class="adf-content-widget-preview-text">{{ 'FORM.PREVIEW.IMAGE_NOT_AVAILABLE' | translate }}
            </div>
        </div>
        <div class="mdl-card__supporting-text upload-widget__content-text">{{content.name}}</div>
    </mat-card-content>

    <mat-card-actions>
        <button mat-icon-button id="view" (click)="openViewer(content)">
            <mat-icon class="mat-24">zoom_in</mat-icon>
        </button>
        <button mat-icon-button id="download" (click)="download(content)">
            <mat-icon class="mat-24">file_download</mat-icon>
        </button>
    </mat-card-actions>
</mat-card>
`,
                styles: [`.adf-img-upload-widget{width:100%;height:100%;border:1px solid rgba(117,117,117,.57);-webkit-box-shadow:1px 1px 2px #ddd;box-shadow:1px 1px 2px #ddd;background-color:#fff}.adf-content-widget-preview-text{word-wrap:break-word;word-break:break-all;text-align:center}`],
                encapsulation: ViewEncapsulation.None
            },] },
];
ContentWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
    { type: ContentService, },
    { type: ProcessContentService, },
];
ContentWidgetComponent.propDecorators = {
    "id": [{ type: Input },],
    "showDocumentContent": [{ type: Input },],
    "contentClick": [{ type: Output },],
    "thumbnailLoaded": [{ type: Output },],
    "contentLoaded": [{ type: Output },],
    "error": [{ type: Output },],
};

class StartFormComponent extends FormComponent {
    constructor(formService, visibilityService, logService) {
        super(formService, visibilityService, null, null);
        this.showOutcomeButtons = true;
        this.showRefreshButton = true;
        this.readOnlyForm = false;
        this.outcomeClick = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.outcomesContainer = null;
        this.showTitle = false;
    }
    ngOnInit() {
        this.formService.formContentClicked.subscribe((content) => {
            this.formContentClicked.emit(content);
        });
    }
    ngOnChanges(changes) {
        let                  processDefinitionId = changes['processDefinitionId'];
        if (processDefinitionId && processDefinitionId.currentValue) {
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(processDefinitionId.currentValue);
            return;
        }
        let                  processId = changes['processId'];
        if (processId && processId.currentValue) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(processId.currentValue);
            return;
        }
    }
    loadStartForm(processId) {
        this.formService.getProcessIntance(processId)
            .subscribe((intance) => {
            this.formService
                .getStartFormInstance(processId)
                .subscribe(form => {
                this.formName = form.name;
                if (intance.variables) {
                    form.processVariables = intance.variables;
                }
                this.form = this.parseForm(form);
                this.visibilityService.refreshVisibility(this.form);
                this.form.validateForm();
                this.form.readOnly = this.readOnlyForm;
                this.onFormLoaded(this.form);
            }, error => this.handleError(error));
        });
    }
    getStartFormDefinition(processId) {
        this.formService
            .getStartFormDefinition(processId)
            .subscribe(form => {
            this.formName = form.processDefinitionName;
            this.form = this.parseForm(form);
            this.visibilityService.refreshVisibility(this.form);
            this.form.validateForm();
            this.form.readOnly = this.readOnlyForm;
            this.onFormLoaded(this.form);
        }, error => this.handleError(error));
    }
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.isSystem && (outcome.name === FormOutcomeModel.SAVE_ACTION ||
            outcome.name === FormOutcomeModel.COMPLETE_ACTION)) {
            return false;
        }
        else if (outcome && outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
            return true;
        }
        return super.isOutcomeButtonVisible(outcome, isFormReadOnly);
    }
    saveTaskForm() {
    }
    onRefreshClicked() {
        if (this.processDefinitionId) {
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(this.processDefinitionId);
        }
        else if (this.processId) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(this.processId);
        }
    }
    completeTaskForm(outcome) {
        this.outcomeClick.emit(outcome);
    }
}
StartFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-form',
                template: `<div class="adf-start-form-container" *ngIf="hasForm()">
    <mat-card>
        <mat-card-header>
            <mat-card-title>
                <h2 *ngIf="isTitleEnabled()" class="mdl-card__title-text">{{form.taskName}}</h2>
            </mat-card-title>
        </mat-card-header>
        <mat-card-content>
            <div *ngIf="form.hasTabs()">
                <tabs-widget [tabs]="form.tabs" (formTabChanged)="checkVisibility($event);"></tabs-widget>
            </div>

            <div *ngIf="!form.hasTabs() && form.hasFields()">
                <div *ngFor="let field of form.fields">
                    <form-field [field]="field.field"></form-field>
                </div>
            </div>
        </mat-card-content>
        <mat-card-content class="adf-start-form-actions" *ngIf="showOutcomeButtons && form.hasOutcomes()" #outcomesContainer>
             <ng-content select="[form-custom-button]"></ng-content>
            <button *ngFor="let outcome of form.outcomes"
                    mat-button
                    [attr.data-automation-id]="'adf-form-' + outcome.name  | lowercase"
                    [disabled]="!isOutcomeButtonEnabled(outcome)"
                    [class.mdl-button--colored]="!outcome.isSystem"
                    [class.adf-form-hide-button]="!isOutcomeButtonVisible(outcome, form.readOnly)"
                    (click)="onOutcomeClicked(outcome, $event)">
                {{outcome.name}}
            </button>
        </mat-card-content>
        <mat-card-actions *ngIf="showRefreshButton">
            <button mat-button
                    (click)="onRefreshClicked()">
                <mat-icon>refresh</mat-icon>
            </button>
        </mat-card-actions>
    </mat-card>
</div>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
StartFormComponent.ctorParameters = () => [
    { type: FormService, },
    { type: WidgetVisibilityService, },
    { type: LogService, },
];
StartFormComponent.propDecorators = {
    "processDefinitionId": [{ type: Input },],
    "processId": [{ type: Input },],
    "showOutcomeButtons": [{ type: Input },],
    "showRefreshButton": [{ type: Input },],
    "readOnlyForm": [{ type: Input },],
    "outcomeClick": [{ type: Output },],
    "formContentClicked": [{ type: Output },],
    "outcomesContainer": [{ type: ViewChild, args: ['outcomesContainer', {},] },],
};

const baseHost = {
    '(click)': 'event($event)',
    '(blur)': 'event($event)',
    '(change)': 'event($event)',
    '(focus)': 'event($event)',
    '(focusin)': 'event($event)',
    '(focusout)': 'event($event)',
    '(input)': 'event($event)',
    '(invalid)': 'event($event)',
    '(select)': 'event($event)'
};
class WidgetComponent {
    constructor(formService) {
        this.formService = formService;
        this.readOnly = false;
        this.fieldChanged = new EventEmitter();
    }
    hasField() {
        return this.field ? true : false;
    }
    isRequired() {
        if (this.field && this.field.required) {
            return true;
        }
        return null;
    }
    isValid() {
        return this.field.validationSummary ? true : false;
    }
    hasValue() {
        return this.field &&
            this.field.value !== null &&
            this.field.value !== undefined;
    }
    isInvalidFieldRequired() {
        return !this.field.isValid && !this.field.validationSummary && this.isRequired();
    }
    ngAfterViewInit() {
        this.fieldChanged.emit(this.field);
    }
    checkVisibility(field) {
        this.fieldChanged.emit(field);
    }
    onFieldChanged(field) {
        this.fieldChanged.emit(field);
    }
    getHyperlinkUrl(field) {
        let                  url = WidgetComponent.DEFAULT_HYPERLINK_URL;
        if (field && field.hyperlinkUrl) {
            url = field.hyperlinkUrl;
            if (!/^https?:\/\//i.test(url)) {
                url = `${WidgetComponent.DEFAULT_HYPERLINK_SCHEME}${url}`;
            }
        }
        return url;
    }
    getHyperlinkText(field) {
        if (field) {
            return field.displayText || field.hyperlinkUrl;
        }
        return null;
    }
    event(event) {
        this.formService.formEvents.next(event);
    }
}
WidgetComponent.DEFAULT_HYPERLINK_URL = '#';
WidgetComponent.DEFAULT_HYPERLINK_SCHEME = 'http://';
WidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'base-widget',
                template: '',
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
WidgetComponent.ctorParameters = () => [
    { type: FormService, },
];
WidgetComponent.propDecorators = {
    "readOnly": [{ type: Input },],
    "field": [{ type: Input },],
    "fieldChanged": [{ type: Output },],
};

class ContainerWidgetComponentModel extends ContainerModel {
    constructor(field) {
        super(field);
        this.columns = [];
        this.isExpanded = true;
        this.rowspan = 1;
        this.colspan = 1;
        if (this.field) {
            this.columns = this.field.columns || [];
            this.isExpanded = !this.isCollapsedByDefault();
            this.colspan = field.colspan;
            this.rowspan = field.rowspan;
        }
    }
    isGroup() {
        return this.type === FormFieldTypes.GROUP;
    }
    isCollapsible() {
        let                  allowCollapse = false;
        if (this.isGroup() && this.field.params['allowCollapse']) {
            allowCollapse =                  (this.field.params['allowCollapse']);
        }
        return allowCollapse;
    }
    isCollapsedByDefault() {
        let                  collapseByDefault = false;
        if (this.isCollapsible() && this.field.params['collapseByDefault']) {
            collapseByDefault =                  (this.field.params['collapseByDefault']);
        }
        return collapseByDefault;
    }
}

class ContainerWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    onExpanderClicked() {
        if (this.content && this.content.isCollapsible()) {
            this.content.isExpanded = !this.content.isExpanded;
        }
    }
    ngOnInit() {
        if (this.field) {
            this.content = new ContainerWidgetComponentModel(this.field);
        }
    }
    get fields() {
        const                  fields = [];
        let                  rowContainsElement = true,
        rowIndex = 0;
        while (rowContainsElement) {
            rowContainsElement = false;
            for (let                  i = 0; i < this.content.columns.length; i++) {
                let                  field = this.content.columns[i].fields[rowIndex];
                if (field) {
                    rowContainsElement = true;
                }
                fields.push(field);
            }
            rowIndex++;
        }
        return fields;
    }
    getColumnWith(field) {
        const                  colspan = field ? field.colspan : 1;
        return (100 / this.content.json.numberOfColumns) * colspan + '%';
    }
}
ContainerWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'container-widget',
                template: `<div [hidden]="!content?.isGroup()" class="container-widget__header">
    <h4 class="container-widget__header-text" id="container-header"
        [class.collapsible]="content?.isCollapsible()">
        <button *ngIf="content?.isCollapsible()"
                mat-icon-button
                class="mdl-button--icon"
                (click)="onExpanderClicked()">
            <mat-icon>{{ content?.isExpanded ? 'expand_more' : 'expand_less' }}</mat-icon>
        </button>
        <span (click)="onExpanderClicked()" id="container-header-label">{{content.name}}</span>
    </h4>
</div>

<section class="grid-list" *ngIf="content?.isExpanded">
    <div class="grid-list-item" *ngFor="let field of fields" [style.width]="getColumnWith(field)">
        <form-field *ngIf="field" [field]="field"></form-field>
    </div>
</section>


`,
                styles: [``],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
ContainerWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

class TabsWidgetComponent {
    constructor() {
        this.tabs = [];
        this.formTabChanged = new EventEmitter();
        this.visibleTabs = [];
    }
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    ngAfterContentChecked() {
        this.filterVisibleTabs();
    }
    filterVisibleTabs() {
        this.visibleTabs = this.tabs.filter(tab => {
            return tab.isVisible;
        });
    }
    tabChanged(field) {
        this.formTabChanged.emit(field);
    }
}
TabsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'tabs-widget',
                template: `<div *ngIf="hasTabs()" class="alfresco-tabs-widget">
    <mat-tab-group>
        <mat-tab *ngFor="let tab of visibleTabs" [label]="tab.title">
            <div *ngFor="let field of tab.fields">
                <form-field [field]="field.field"></form-field>
             </div>
        </mat-tab>
    </mat-tab-group>
</div>
`,
                encapsulation: ViewEncapsulation.None
            },] },
];
TabsWidgetComponent.ctorParameters = () => [];
TabsWidgetComponent.propDecorators = {
    "tabs": [{ type: Input },],
    "formTabChanged": [{ type: Output },],
};

class UnknownWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
UnknownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'unknown-widget',
                template: `
            <mat-list class="adf-unknown-widget">
                <mat-list-item>
                     <mat-icon class="mat-24">error_outline</mat-icon>
                     <span class="adf-unknown-text">Unknown type: {{field.type}}</span>
                </mat-list-item>
            </mat-list>

    `,
                styles: [`.adf-unknown-text{margin-left:10px;color:red}.adf-unknown-widget{margin:42px}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
UnknownWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

class AmountWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.currency = AmountWidgetComponent.DEFAULT_CURRENCY;
    }
    ngOnInit() {
        if (this.field && this.field.currency) {
            this.currency = this.field.currency;
        }
    }
}
AmountWidgetComponent.DEFAULT_CURRENCY = '$';
AmountWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'amount-widget',
                template: `<div class="adf-amount-widget__container adf-amount-widget {{field.className}}" [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
    <mat-form-field floatPlaceholder="never" class="adf-amount-widget__input">
        <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
        <span matPrefix class="adf-amount-widget__prefix-spacing"> {{currency }}</span>
        <input matInput
                class="adf-amount-widget"
                type="text"
                [id]="field.id"
                [required]="isRequired()"
                [value]="field.value"
                [(ngModel)]="field.value"
                (ngModelChange)="onFieldChanged(field)"
                [disabled]="field.readOnly"
                placeholder="{{field.placeholder}}">
    </mat-form-field>
    <error-widget [error]="field.validationSummary" ></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>

`,
                styles: [`.adf-amount-widget{width:100%;vertical-align:baseline!important}.adf-amount-widget .mat-input-element{margin-left:11px}.adf-amount-widget .mat-input-prefix{position:absolute;margin-top:58px}.adf-amount-widget .mat-input-placeholder{margin-top:5px;display:none}.adf-amount-widget__container{max-width:100%}.adf-amount-widget__container .mat-input-placeholder-wrapper{top:0!important;left:13px}.adf-amount-widget__input .mat-focused{-webkit-transition:none;transition:none}.adf-amount-widget__prefix-spacing{padding-right:5px}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
AmountWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

class CheckboxWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
CheckboxWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'checkbox-widget',
                template: `<div [ngClass]="field.className">
    <mat-checkbox
        [id]="field.id"
        color="primary"
        [required]="field.required"
        [disabled]="field.readOnly || readOnly"
        [(ngModel)]="field.value"
        (ngModelChange)="onFieldChanged(field)">
        {{field.name}}
        <span *ngIf="field.required">*</span>
    </mat-checkbox>
</div>
`,
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
CheckboxWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

const ɵ0$1 = MOMENT_DATE_FORMATS;
class DateWidgetComponent extends WidgetComponent {
    constructor(formService, dateAdapter, preferences) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
    }
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        let                  momentDateAdapter =                  (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, 'DD/MM/YYYY');
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, 'DD/MM/YYYY');
            }
        }
        this.displayDate = moment(this.field.value, this.field.dateDisplayFormat);
    }
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            this.field.value = newDateValue.value.format(this.field.dateDisplayFormat);
        }
        else if (newDateValue) {
            this.field.value = newDateValue;
        }
        else {
            this.field.value = null;
        }
        this.onFieldChanged(this.field);
    }
}
DateWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'date-widget',
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$1 }
                ],
                template: `<div class="{{field.className}}" id="data-widget" [class.adf-invalid]="!field.isValid">
    <mat-form-field class="adf-date-widget">
        <label class="adf-label" [attr.for]="field.id">{{field.name}} ({{field.dateDisplayFormat}})<span *ngIf="isRequired()">*</span></label>
        <input matInput
               [id]="field.id"
               [matDatepicker]="datePicker"
               [(ngModel)]="displayDate"
               [required]="isRequired()"
               [disabled]="field.readOnly"
               [min]="minDate"
               [max]="maxDate"
               (focusout)="onDateChanged($event.srcElement.value)"
               (dateChange)="onDateChanged($event)"
               placeholder="{{field.placeholder}}">
        <mat-datepicker-toggle  matSuffix [for]="datePicker" [disabled]="field.readOnly" ></mat-datepicker-toggle>
    </mat-form-field>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
    <mat-datepicker #datePicker [touchUi]="true" [startAt]="displayDate" ></mat-datepicker>
</div>

`,
                styles: [`.adf-date-widget .mat-input-suffix{text-align:right;position:absolute;margin-top:30px;width:100%}.adf-date-widget-date-widget-button{position:relative;float:right}.adf-date-widget-date-input{padding-top:5px;padding-bottom:5px}.adf-date-widget-grid-date-widget{-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0}.adf-date-widget-date-widget-button__cell{margin-top:0;margin-bottom:0}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
DateWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];

class DisplayTextWidgetComponentComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
DisplayTextWidgetComponentComponent.decorators = [
    { type: Component, args: [{
                selector: 'display-text-widget',
                template: `<div class="adf-display-text-widget {{field.className}}">{{field.value}}</div>
`,
                styles: [`.adf-display-text-widget{white-space:pre-wrap}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
DisplayTextWidgetComponentComponent.ctorParameters = () => [
    { type: FormService, },
];

class DocumentWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.fileId = null;
        this.hasFile = false;
    }
    ngOnInit() {
        if (this.field) {
            const                  file = this.field.value;
            if (file) {
                this.fileId = file.id;
                this.hasFile = true;
            }
            else {
                this.fileId = null;
                this.hasFile = false;
            }
        }
    }
}
DocumentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-document-widget',
                template: `<div class="adf-form-document-widget {{field.className}}">
    <ng-container *ngIf="hasFile">
        <adf-content [id]="fileId" [showDocumentContent]="true"></adf-content>
    </ng-container>
</div>
`,
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
DocumentWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

class DropdownWidgetComponent extends WidgetComponent {
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
    }
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getValuesByTaskId();
            }
            else {
                this.getValuesByProcessDefinitionId();
            }
        }
    }
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((result) => {
            let                  options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((result || []));
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((result) => {
            let                  options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((result || []));
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    getOptionValue(option, fieldValue) {
        let                  optionValue = '';
        if (option.id === 'empty' || option.name !== fieldValue) {
            optionValue = option.id;
        }
        else {
            optionValue = option.name;
        }
        return optionValue;
    }
    handleError(error) {
        this.logService.error(error);
    }
    isReadOnlyType() {
        return this.field.type === 'readonly' ? true : false;
    }
}
DropdownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-widget',
                template: `<div class="adf-dropdown-widget {{field.className}}"
     [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
    <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
    <mat-form-field>
        <mat-select class="adf-select"
                    [id]="field.id"
                    [(ngModel)]="field.value"
                    [disabled]="field.readOnly"
                    (ngModelChange)="onFieldChanged(field)">
            <mat-option *ngFor="let opt of field.options"
                        [value]="getOptionValue(opt, field.value)"
                        [id]="opt.id">{{opt.name}}
            </mat-option>
            <mat-option id="readonlyOption" *ngIf="isReadOnlyType()" [value]="field.value">{{field.value}}</mat-option>
        </mat-select>
    </mat-form-field>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget class="adf-dropdown-required-message" *ngIf="isInvalidFieldRequired()"
                  required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>
`,
                styles: [`.adf-dropdown-widget{width:100%;margin-top:13px}.adf-dropdown-widget .adf-select{padding-top:0!important;width:100%}.adf-dropdown-widget .mat-select-value-text{font-size:14px}.adf-dropdown-widget-select{width:100%}.adf-dropdown-widget-dropdown-required-message .adf-error-text-container{margin-top:1px!important}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
DropdownWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
];

class DateCellValidator {
    constructor() {
        this.supportedTypes = [
            'Date'
        ];
    }
    isSupported(column) {
        return column && column.editable && this.supportedTypes.indexOf(column.type) > -1;
    }
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            let                  value = row.value[column.id];
            let                  dateValue = moment(value, 'D-M-YYYY');
            if (!dateValue.isValid()) {
                if (summary) {
                    summary.isValid = false;
                    summary.message = `Invalid '${column.name}' format.`;
                }
                return false;
            }
        }
        return true;
    }
}

class DynamicRowValidationSummary extends ErrorMessageModel {
    constructor(json) {
        super(json);
        this.isValid = json.isValid;
    }
}

class NumberCellValidator {
    constructor() {
        this.supportedTypes = [
            'Number',
            'Amount'
        ];
    }
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            let                  value = row.value[column.id];
            if (value === null ||
                value === undefined ||
                value === '' ||
                this.isNumber(value)) {
                return true;
            }
            if (summary) {
                summary.isValid = false;
                summary.message = `Field '${column.name}' must be a number.`;
            }
            return false;
        }
        return true;
    }
}

class RequiredCellValidator {
    constructor() {
        this.supportedTypes = [
            'String',
            'Number',
            'Amount',
            'Date',
            'Dropdown'
        ];
    }
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            let                  value = row.value[column.id];
            if (column.required) {
                if (value === null || value === undefined || value === '') {
                    if (summary) {
                        summary.isValid = false;
                        summary.message = `Field '${column.name}' is required.`;
                    }
                    return false;
                }
            }
        }
        return true;
    }
}

class DynamicTableModel extends FormWidgetModel {
    constructor(field, formService) {
        super(field.form, field.json);
        this.formService = formService;
        this.columns = [];
        this.visibleColumns = [];
        this.rows = [];
        this._validators = [];
        this.field = field;
        if (field.json) {
            const                  columns = this.getColumns(field);
            if (columns) {
                this.columns = columns;
                this.visibleColumns = this.columns.filter(col => col.visible);
            }
            if (field.json.value) {
                this.rows = field.json.value.map(obj =>                  ({ selected: false, value: obj }));
            }
        }
        this._validators = [
            new RequiredCellValidator(),
            new DateCellValidator(),
            new NumberCellValidator()
        ];
    }
    get selectedRow() {
        return this._selectedRow;
    }
    set selectedRow(value) {
        if (this._selectedRow && this._selectedRow === value) {
            this._selectedRow.selected = false;
            this._selectedRow = null;
            return;
        }
        this.rows.forEach(row => row.selected = false);
        this._selectedRow = value;
        if (value) {
            this._selectedRow.selected = true;
        }
    }
    getColumns(field) {
        if (field && field.json) {
            let                  definitions = field.json.columnDefinitions;
            if (!definitions && field.json.params && field.json.params.field) {
                definitions = field.json.params.field.columnDefinitions;
            }
            if (definitions) {
                return definitions.map(obj =>                  (obj));
            }
        }
        return null;
    }
    flushValue() {
        if (this.field) {
            this.field.value = this.rows.map(r => r.value);
            this.field.updateForm();
        }
    }
    moveRow(row, offset) {
        let                  oldIndex = this.rows.indexOf(row);
        if (oldIndex > -1) {
            let                  newIndex = (oldIndex + offset);
            if (newIndex < 0) {
                newIndex = 0;
            }
            else if (newIndex >= this.rows.length) {
                newIndex = this.rows.length;
            }
            let                  arr = this.rows.slice();
            arr.splice(oldIndex, 1);
            arr.splice(newIndex, 0, row);
            this.rows = arr;
            this.flushValue();
        }
    }
    deleteRow(row) {
        if (row) {
            if (this.selectedRow === row) {
                this.selectedRow = null;
            }
            let                  idx = this.rows.indexOf(row);
            if (idx > -1) {
                this.rows.splice(idx, 1);
                this.flushValue();
            }
        }
    }
    addRow(row) {
        if (row) {
            this.rows.push(row);
        }
    }
    validateRow(row) {
        const                  summary = new DynamicRowValidationSummary({
            isValid: true,
            message: null
        });
        const                  event = new ValidateDynamicTableRowEvent(this.form, this.field, row, summary);
        this.formService.validateDynamicTableRow.next(event);
        if (event.defaultPrevented || !summary.isValid) {
            return summary;
        }
        if (row) {
            for (let                  col of this.columns) {
                for (let                  validator of this._validators) {
                    if (!validator.validate(row, col, summary)) {
                        return summary;
                    }
                }
            }
        }
        return summary;
    }
    getCellValue(row, column) {
        let                  result = row.value[column.id];
        if (column.type === 'Dropdown') {
            if (result) {
                return result.name;
            }
        }
        if (column.type === 'Boolean') {
            return result ? true : false;
        }
        if (column.type === 'Date') {
            if (result) {
                return moment(result.split('T')[0], 'YYYY-MM-DD').format('DD-MM-YYYY');
            }
        }
        return result || '';
    }
    getDisplayText(column) {
        let                  result = column.name;
        if (column.type === 'Amount') {
            let                  currency = column.amountCurrency || '$';
            result = `${column.name} (${currency})`;
        }
        return result;
    }
}

class DynamicTableWidgetComponent extends WidgetComponent {
    constructor(formService, elementRef, visibilityService, logService, cd) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.visibilityService = visibilityService;
        this.logService = logService;
        this.cd = cd;
        this.ERROR_MODEL_NOT_FOUND = 'Table model not found';
        this.editMode = false;
        this.editRow = null;
        this.selectArrayCode = [32, 0, 13];
    }
    ngOnInit() {
        if (this.field) {
            this.content = new DynamicTableModel(this.field, this.formService);
            this.visibilityService.refreshVisibility(this.field.form);
        }
    }
    forceFocusOnAddButton() {
        if (this.content) {
            this.cd.detectChanges();
            let                  buttonAddRow =                  (this.elementRef.nativeElement.querySelector('#' + this.content.id + '-add-row'));
            if (this.isDynamicTableReady(buttonAddRow)) {
                buttonAddRow.focus();
            }
        }
    }
    isDynamicTableReady(buttonAddRow) {
        return this.field && !this.editMode && buttonAddRow;
    }
    isValid() {
        let                  result = true;
        if (this.content && this.content.field) {
            result = this.content.field.isValid;
        }
        return result;
    }
    onRowClicked(row) {
        if (this.content) {
            this.content.selectedRow = row;
        }
    }
    onKeyPressed($event, row) {
        if (this.content && this.isEnterOrSpacePressed($event.keyCode)) {
            this.content.selectedRow = row;
        }
    }
    isEnterOrSpacePressed(keycode) {
        return this.selectArrayCode.indexOf(keycode) !== -1;
    }
    hasSelection() {
        return !!(this.content && this.content.selectedRow);
    }
    moveSelectionUp() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, -1);
            return true;
        }
        return false;
    }
    moveSelectionDown() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, 1);
            return true;
        }
        return false;
    }
    deleteSelection() {
        if (this.content && !this.readOnly) {
            this.content.deleteRow(this.content.selectedRow);
            return true;
        }
        return false;
    }
    addNewRow() {
        if (this.content && !this.readOnly) {
            this.editRow =                  ({
                isNew: true,
                selected: false,
                value: {}
            });
            this.editMode = true;
            return true;
        }
        return false;
    }
    editSelection() {
        if (this.content && !this.readOnly) {
            this.editRow = this.copyRow(this.content.selectedRow);
            this.editMode = true;
            return true;
        }
        return false;
    }
    getCellValue(row, column) {
        if (this.content) {
            let                  result = this.content.getCellValue(row, column);
            if (column.type === 'Amount') {
                return (column.amountCurrency || '$') + ' ' + (result || 0);
            }
            return result;
        }
        return null;
    }
    onSaveChanges() {
        if (this.content) {
            if (this.editRow.isNew) {
                let                  row = this.copyRow(this.editRow);
                this.content.selectedRow = null;
                this.content.addRow(row);
                this.editRow.isNew = false;
            }
            else {
                this.content.selectedRow.value = this.copyObject(this.editRow.value);
            }
            this.content.flushValue();
        }
        else {
            this.logService.error(this.ERROR_MODEL_NOT_FOUND);
        }
        this.editMode = false;
        this.forceFocusOnAddButton();
    }
    onCancelChanges() {
        this.editMode = false;
        this.editRow = null;
        this.forceFocusOnAddButton();
    }
    copyRow(row) {
        return                  ({
            value: this.copyObject(row.value)
        });
    }
    copyObject(obj) {
        let                  result = obj;
        if (typeof obj === 'object' && obj !== null && obj !== undefined) {
            result = Object.assign({}, obj);
            Object.keys(obj).forEach(key => {
                if (typeof obj[key] === 'object') {
                    result[key] = this.copyObject(obj[key]);
                }
            });
        }
        return result;
    }
}
DynamicTableWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dynamic-table-widget',
                template: `<div class="{{field.className}}"
    [class.adf-invalid]="!isValid()">
    <div class="adf-label">{{content.name}}<span *ngIf="isRequired()">*</span></div>

    <div *ngIf="!editMode">
        <div class="adf-table-container">
            <table class="full-width adf-dynamic-table" id="dynamic-table-{{content.id}}">
                <thead>
                    <tr>
                        <th *ngFor="let column of content.visibleColumns">
                            {{column.name}}
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr *ngFor="let row of content.rows; let idx = index" tabindex="0" id="{{content.id}}-row-{{idx}}"
                        [class.adf-dynamic-table-widget__row-selected]="row.selected" (keyup)="onKeyPressed($event, row)">
                        <td *ngFor="let column of content.visibleColumns"
                            (click)="onRowClicked(row)">
                            {{ getCellValue(row, column) }}
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div *ngIf="!readOnly">
            <button mat-button
                    [disabled]="!hasSelection()"
                    (click)="moveSelectionUp()">
                <mat-icon>arrow_upward</mat-icon>
            </button>
            <button mat-button
                    [disabled]="!hasSelection()"
                    (click)="moveSelectionDown()">
                <mat-icon>arrow_downward</mat-icon>
            </button>
            <button mat-button
                    [disabled]="field.readOnly"
                    id="{{content.id}}-add-row"
                    (click)="addNewRow()">
                <mat-icon>add_circle_outline</mat-icon>
            </button>
            <button mat-button
                    [disabled]="!hasSelection()"
                    (click)="deleteSelection()">
                <mat-icon>remove_circle_outline</mat-icon>
            </button>
            <button mat-button
                    [disabled]="!hasSelection()"
                    (click)="editSelection()">
                <mat-icon>edit</mat-icon>
            </button>
        </div>
     </div>

     <row-editor *ngIf="editMode"
        [table]="content"
        [row]="editRow"
        [column]="column"
        (save)="onSaveChanges()"
        (cancel)="onCancelChanges()">
     </row-editor>
    <error-widget [error]="field.validationSummary" ></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>
`,
                styles: [``],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
DynamicTableWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: ElementRef, },
    { type: WidgetVisibilityService, },
    { type: LogService, },
    { type: ChangeDetectorRef, },
];

class BooleanEditorComponent {
    onValueChanged(row, column, event) {
        let                  value = (                 (event)).checked;
        row.value[column.id] = value;
    }
}
BooleanEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-boolean-editor',
                template: ` <label [attr.for]="column.id">
    <mat-checkbox
        color="primary"
        [id]="column.id"
        [checked]="table.getCellValue(row, column)"
        [required]="column.required"
        [disabled]="!column.editable"
        (change)="onValueChanged(row, column, $event)">
    <span class="adf-checkbox-label">{{column.name}}</span>
    </mat-checkbox>
</label>
`,
                styles: [`.adf-checkbox-label{position:relative;cursor:pointer;font-size:16px;line-height:24px;margin:0}`]
            },] },
];
BooleanEditorComponent.ctorParameters = () => [];
BooleanEditorComponent.propDecorators = {
    "table": [{ type: Input },],
    "row": [{ type: Input },],
    "column": [{ type: Input },],
};

const ɵ0$2 = MOMENT_DATE_FORMATS;
class DateEditorComponent {
    constructor(dateAdapter, preferences) {
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.DATE_FORMAT = 'DD-MM-YYYY';
    }
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        let                  momentDateAdapter =                  (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), this.DATE_FORMAT);
    }
    onDateChanged(newDateValue) {
        if (newDateValue) {
            let                  momentDate = moment(newDateValue, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = '';
            }
            else {
                this.row.value[this.column.id] = `${momentDate.format('YYYY-MM-DD')}T00:00:00.000Z`;
                this.table.flushValue();
            }
        }
    }
}
DateEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-editor',
                template: `<div>
    <mat-form-field class="adf-date-editor">
        <label [attr.for]="column.id">{{column.name}} (d-M-yyyy)</label>
        <input matInput
            id="dateInput"
            type="text"
            [matDatepicker]="datePicker"
            [value]="value"
            [id]="column.id"
            [required]="column.required"
            [disabled]="!column.editable"
           (focusout)="onDateChanged($event.srcElement.value)">
        <mat-datepicker-toggle  *ngIf="column.editable" matSuffix [for]="datePicker" class="adf-date-editor-button" ></mat-datepicker-toggle>
    </mat-form-field>
    <mat-datepicker #datePicker (dateChange)="onDateChanged($event)" [touchUi]="true"></mat-datepicker>
</div>
`,
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$2 }
                ],
                styles: [`.adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}`]
            },] },
];
DateEditorComponent.ctorParameters = () => [
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];
DateEditorComponent.propDecorators = {
    "table": [{ type: Input },],
    "row": [{ type: Input },],
    "column": [{ type: Input },],
};

class DropdownEditorComponent {
    constructor(formService, logService) {
        this.formService = formService;
        this.logService = logService;
        this.value = null;
        this.options = [];
    }
    ngOnInit() {
        let                  field = this.table.field;
        if (field) {
            if (this.column.optionType === 'rest') {
                if (this.table.form && this.table.form.taskId) {
                    this.getValuesByTaskId(field);
                }
                else {
                    this.getValuesByProcessDefinitionId(field);
                }
            }
            else {
                this.options = this.column.options || [];
                this.value = this.table.getCellValue(this.row, this.column);
            }
        }
    }
    getValuesByTaskId(field) {
        this.formService
            .getRestFieldValuesColumn(field.form.taskId, field.id, this.column.id)
            .subscribe((result) => {
            this.column.options = result || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, err => this.handleError(err));
    }
    getValuesByProcessDefinitionId(field) {
        this.formService
            .getRestFieldValuesColumnByProcessId(field.form.processDefinitionId, field.id, this.column.id)
            .subscribe((result) => {
            this.column.options = result || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, err => this.handleError(err));
    }
    onValueChanged(row, column, event) {
        let                  value = (                 (event)).value;
        value = column.options.find(opt => opt.name === value);
        row.value[column.id] = value;
    }
    handleError(error) {
        this.logService.error(error);
    }
}
DropdownEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-editor',
                template: `<div class="dropdown-editor">
    <label [attr.for]="column.id">{{column.name}}</label>
    <mat-form-field>
        <mat-select
            floatPlaceholder="never"
            class="adf-dropdown-editor-select"
            [id]="column.id"
            [(ngModel)]="value"
            [required]="column.required"
            [disabled]="!column.editable"
            (change)="onValueChanged(row, column, $event)">
            <mat-option></mat-option>
            <mat-option *ngFor="let opt of options" [value]="opt.name" [id]="opt.id">{{opt.name}}</mat-option>
        </mat-select>
    </mat-form-field>
</div>
`,
                styles: [`.adf-dropdown-editor-select{width:100%}`]
            },] },
];
DropdownEditorComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
];
DropdownEditorComponent.propDecorators = {
    "table": [{ type: Input },],
    "row": [{ type: Input },],
    "column": [{ type: Input },],
};

class RowEditorComponent {
    constructor() {
        this.save = new EventEmitter();
        this.cancel = new EventEmitter();
        this.validationSummary = new DynamicRowValidationSummary({ isValid: true, message: '' });
    }
    onCancelChanges() {
        this.cancel.emit({
            table: this.table,
            row: this.row,
            column: this.column
        });
    }
    onSaveChanges() {
        this.validate();
        if (this.isValid()) {
            this.save.emit({
                table: this.table,
                row: this.row,
                column: this.column
            });
        }
    }
    isValid() {
        return this.validationSummary && this.validationSummary.isValid;
    }
    validate() {
        this.validationSummary = this.table.validateRow(this.row);
    }
}
RowEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'row-editor',
                template: `<div class="row-editor mdl-shadow--2dp"
    [class.row-editor__invalid]="!validationSummary.isValid">
    <div class="mdl-grid" *ngFor="let column of table.columns">
        <div class="mdl-cell mdl-cell--6-col" [ngSwitch]="column.type">
            <div *ngSwitchCase="'Dropdown'">
                <adf-dropdown-editor
                    [table]="table"
                    [row]="row"
                    [column]="column">
                </adf-dropdown-editor>
                </div>
                <div *ngSwitchCase="'Date'">
                    <adf-date-editor
                    [table]="table"
                    [row]="row"
                    [column]="column">
                </adf-date-editor>
                </div>

                <div *ngSwitchCase="'Boolean'">
                <adf-boolean-editor
                    [table]="table"
                    [row]="row"
                    [column]="column">
                </adf-boolean-editor>
                </div>
                <div *ngSwitchDefault>
                <adf-text-editor
                    [table]="table"
                    [row]="row"
                    [column]="column">
                </adf-text-editor>
            </div>
        </div>
    </div>
    <error-widget [error]="validationSummary"></error-widget>
    <div>
        <button mat-button (click)="onCancelChanges()">Cancel</button>
        <button mat-button (click)="onSaveChanges()">Save</button>
    </div>
</div>
`,
                styles: [`.row-editor{padding:8px}.row-editor__validation-summary{visibility:hidden}.row-editor__invalid .row-editor__validation-summary{color:#d50000;visibility:visible;padding:8px 16px}`]
            },] },
];
RowEditorComponent.ctorParameters = () => [];
RowEditorComponent.propDecorators = {
    "table": [{ type: Input },],
    "row": [{ type: Input },],
    "column": [{ type: Input },],
    "save": [{ type: Output },],
    "cancel": [{ type: Output },],
};

class TextEditorComponent {
    ngOnInit() {
        this.displayName = this.table.getDisplayText(this.column);
    }
    onValueChanged(row, column, event) {
        let                  value = (                 (event.target)).value;
        row.value[column.id] = value;
    }
}
TextEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-text-editor',
                template: `<div class="adf-text-editor">
    <mat-form-field>
    <label [attr.for]="column.id">{{displayName}}</label>
    <input matInput
        type="text"
        [value]="table.getCellValue(row, column)"
        (keyup)="onValueChanged(row, column, $event)"
        [required]="column.required"
        [disabled]="!column.editable"
        [id]="column.id">
    </mat-form-field>
</div>
`,
                styles: [`.adf-text-editor{width:100%}`]
            },] },
];
TextEditorComponent.ctorParameters = () => [];
TextEditorComponent.propDecorators = {
    "table": [{ type: Input },],
    "row": [{ type: Input },],
    "column": [{ type: Input },],
};

class ErrorWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.translateParameters = null;
        this._subscriptAnimationState = '';
    }
    ngOnChanges(changes) {
        if (changes['required']) {
            this.required = changes["required"].currentValue;
            this._subscriptAnimationState = 'enter';
        }
        if (changes['error'] && changes['error'].currentValue) {
            if (changes["error"].currentValue.isActive()) {
                this.error = changes["error"].currentValue;
                this.translateParameters = this.error.getAttributesAsJsonObj();
                this._subscriptAnimationState = 'enter';
            }
        }
    }
}
ErrorWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'error-widget',
                template: `<div class="adf-error-text-container">
    <div *ngIf="error?.isActive()" [@transitionMessages]="_subscriptAnimationState">
        <div class="adf-error-text">{{error.message | translate:translateParameters}}</div>
        <mat-icon class="adf-error-icon">warning</mat-icon>
    </div>
    <div *ngIf="required" [@transitionMessages]="_subscriptAnimationState">
            <div class="adf-error-text">{{required}}</div>
    </div>
</div>
`,
                styles: [`.adf-error-text{width:85%}`],
                animations: [
                    trigger('transitionMessages', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
                        transition('void => enter', [
                            style({ opacity: 0, transform: 'translateY(-100%)' }),
                            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                        ])
                    ])
                ],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
ErrorWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];
ErrorWidgetComponent.propDecorators = {
    "error": [{ type: Input },],
    "required": [{ type: Input },],
};

class FunctionalGroupWidgetComponent extends WidgetComponent {
    constructor(formService, elementRef) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.groups = [];
        this.minTermLength = 1;
    }
    ngOnInit() {
        if (this.field) {
            let                  group = this.field.value;
            if (group) {
                this.value = group.name;
            }
            let                  params = this.field.params;
            if (params && params['restrictWithGroup']) {
                let                  restrictWithGroup =                  (params['restrictWithGroup']);
                this.groupId = restrictWithGroup.id;
            }
            if (this.value) {
                this.formService
                    .getWorkflowGroups(this.value, this.groupId)
                    .subscribe((result) => this.groups = result || []);
            }
        }
    }
    onKeyUp(event) {
        if (this.value && this.value.length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                this.oldValue = this.value;
                this.formService.getWorkflowGroups(this.value, this.groupId)
                    .subscribe((result) => {
                    this.groups = result || [];
                });
            }
        }
    }
    flushValue() {
        let                  option = this.groups.find(item => item.name.toLocaleLowerCase() === this.value.toLocaleLowerCase());
        if (option) {
            this.field.value = option;
            this.value = option.name;
        }
        else {
            this.field.value = null;
            this.value = null;
        }
        this.field.updateForm();
    }
    onItemClick(item, event) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
        if (event) {
            event.preventDefault();
        }
    }
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
    }
}
FunctionalGroupWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'functional-group-widget',
                template: `<div class="adf-group-widget {{field.className}}"
     [class.is-dirty]="value"
     [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly" id="functional-group-div">
    <mat-form-field>
        <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
        <input matInput
               class="adf-input"
               type="text"
               [id]="field.id"
               [(ngModel)]="value"
               (keyup)="onKeyUp($event)"
               [disabled]="field.readOnly"
               placeholder="{{field.placeholder}}"
               [matAutocomplete]="auto">
        <mat-autocomplete #auto="matAutocomplete" (optionSelected)="onItemSelect($event.option.value)">
            <mat-option *ngFor="let item of groups"
                       [id]="field.id +'-'+item.id"
                       (click)="onItemClick(item, $event)"  [value]="item">
                <span>{{item.name}}</span>
            </mat-option>
        </mat-autocomplete>

    </mat-form-field>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>
`,
                styles: [`.adf-group-widget{width:100%}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
FunctionalGroupWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: ElementRef, },
];

class HyperlinkWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.linkUrl = WidgetComponent.DEFAULT_HYPERLINK_URL;
        this.linkText = null;
    }
    ngOnInit() {
        if (this.field) {
            this.linkUrl = this.getHyperlinkUrl(this.field);
            this.linkText = this.getHyperlinkText(this.field);
        }
    }
}
HyperlinkWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'hyperlink-widget',
                template: `<div class="adf-hyperlink-widget {{field.className}}">
    <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
    <div>
        <a [href]="linkUrl" target="_blank" rel="nofollow">{{linkText}}</a>
    </div>
</div>
`,
                styles: [``],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
HyperlinkWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

class MultilineTextWidgetComponentComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
MultilineTextWidgetComponentComponent.decorators = [
    { type: Component, args: [{
                selector: 'multiline-text-widget',
                template: `<div class="adf-multiline-text-widget {{field.className}}"
     [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
    <mat-form-field floatPlaceholder="never">
        <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
        <textarea matInput class="adf-input"
                  matTextareaAutosize
                  type="text"
                  rows="3"
                  [id]="field.id"
                  [required]="isRequired()"
                  [(ngModel)]="field.value"
                  (ngModelChange)="onFieldChanged(field)"
                  [disabled]="field.readOnly || readOnly"
                  placeholder="{{field.placeholder}}">
        </textarea>
    </mat-form-field>
    <div *ngIf="field.maxLength > 0" class="adf-multiline-word-counter">
        <span>{{field?.value?.length || 0}}/{{field.maxLength}}</span>
    </div>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget class="adf-multiline-required-message" *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>

`,
                styles: [`.adf-multiline-text-widget{width:100%}.adf-multiline-word-counter{float:right;margin-top:-20px!important;min-height:24px;min-width:1px;font-size:12px;line-height:14px;overflow:hidden;-webkit-transition:all .3s cubic-bezier(.55,0,.55,.2);transition:all .3s cubic-bezier(.55,0,.55,.2);opacity:1;padding-top:5px;text-align:right;padding-right:2px;padding-left:0}.adf-multiline-required-message{display:-webkit-box;display:-ms-flexbox;display:flex}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
MultilineTextWidgetComponentComponent.ctorParameters = () => [
    { type: FormService, },
];

class NumberWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
NumberWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'number-widget',
                template: `<div class="adf-textfield adf-number-widget {{field.className}}"
     [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
    <mat-form-field>
        <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
        <input matInput
               class="adf-input"
               type="text"
               pattern="-?[0-9]*(\.[0-9]+)?"
               [id]="field.id"
               [required]="isRequired()"
               [value]="field.value"
               [(ngModel)]="field.value"
               (ngModelChange)="onFieldChanged(field)"
               [disabled]="field.readOnly"
               placeholder="{{field.placeholder}}">
    </mat-form-field>
    <error-widget [error]="field.validationSummary" ></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>
`,
                styles: [`.adf-number-widget{width:100%}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
NumberWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

class PeopleProcessService {
    constructor(alfrescoJsApi, logService) {
        this.alfrescoJsApi = alfrescoJsApi;
        this.logService = logService;
    }
    getWorkflowUsers(taskId, searchWord) {
        let                  option = { excludeTaskId: taskId, filter: searchWord };
        return Observable.fromPromise(this.getWorkflowUserApi(option))
            .map((response) =>                  (response.data) || [])
            .catch(err => this.handleError(err));
    }
    getUserImage(user) {
        return this.getUserProfileImageApi(user.id);
    }
    involveUserWithTask(taskId, idToInvolve) {
        let                  node = { userId: idToInvolve };
        return Observable.fromPromise(this.involveUserToTaskApi(taskId, node))
            .catch(err => this.handleError(err));
    }
    removeInvolvedUser(taskId, idToRemove) {
        let                  node = { userId: idToRemove };
        return Observable.fromPromise(this.removeInvolvedUserFromTaskApi(taskId, node))
            .catch(err => this.handleError(err));
    }
    getWorkflowUserApi(options) {
        return this.alfrescoJsApi.getInstance().activiti.usersWorkflowApi.getUsers(options);
    }
    involveUserToTaskApi(taskId, node) {
        return this.alfrescoJsApi.getInstance().activiti.taskActionsApi.involveUser(taskId, node);
    }
    removeInvolvedUserFromTaskApi(taskId, node) {
        return this.alfrescoJsApi.getInstance().activiti.taskActionsApi.removeInvolvedUser(taskId, node);
    }
    getUserProfileImageApi(userId) {
        return this.alfrescoJsApi.getInstance().activiti.userApi.getUserProfilePictureUrl(userId);
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
PeopleProcessService.decorators = [
    { type: Injectable },
];
PeopleProcessService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class PeopleWidgetComponent extends WidgetComponent {
    constructor(formService, peopleProcessService) {
        super(formService);
        this.formService = formService;
        this.peopleProcessService = peopleProcessService;
        this.minTermLength = 1;
        this.users = [];
    }
    ngOnInit() {
        if (this.field) {
            let                  params = this.field.params;
            if (params && params["restrictWithGroup"]) {
                let                  restrictWithGroup =                  (params["restrictWithGroup"]);
                this.groupId = restrictWithGroup.id;
            }
        }
    }
    onKeyUp(event) {
        let                  value = (                 (this.input.nativeElement)).value;
        if (value && value.length >= this.minTermLength && this.oldValue !== value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                if (value.length >= this.minTermLength) {
                    this.oldValue = value;
                    this.searchUsers(value);
                }
            }
        }
        else {
            this.validateValue(value);
        }
    }
    searchUsers(userName) {
        this.formService.getWorkflowUsers(userName, this.groupId)
            .subscribe((result) => {
            this.users = result || [];
            this.validateValue(userName);
        });
    }
    validateValue(userName) {
        if (this.isValidUser(userName)) {
            this.field.validationSummary.message = '';
        }
        else if (!userName) {
            this.field.value = null;
            this.users = [];
        }
        else {
            this.field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            this.field.markAsInvalid();
            this.field.form.markAsInvalid();
        }
    }
    isValidUser(value) {
        let                  isValid = false;
        if (value) {
            let                  resultUser = this.users.find((user) => this.getDisplayName(user).toLocaleLowerCase() === value.toLocaleLowerCase());
            if (resultUser) {
                isValid = true;
            }
        }
        return isValid;
    }
    getDisplayName(model) {
        if (model) {
            let                  displayName = `${model.firstName || ''} ${model.lastName || ''}`;
            return displayName.trim();
        }
        return '';
    }
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
        }
    }
}
PeopleWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'people-widget',
                template: `<div class="adf-people-widget {{field.className}}"
     [class.adf-invalid]="!field.isValid"
     [class.adf-readonly]="field.readOnly"
     id="people-widget-content">
    <mat-form-field>
        <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
        <input #inputValue
               matInput
               class="adf-input"
               type="text"
               [id]="field.id"
               [value]="getDisplayName(field.value)"
               (keyup)="onKeyUp($event)"
               [disabled]="field.readOnly"
               placeholder="{{field.placeholder}}"
               [matAutocomplete]="auto">
        <mat-autocomplete #auto="matAutocomplete" (optionSelected)="onItemSelect($event.option.value)"  [displayWith]="getDisplayName">
            <mat-option *ngFor="let user of users; let i = index" [value]="user">
                <div class="adf-people-widget-row" id="adf-people-widget-user-{{i}}">
                    <div [outerHTML]="user | usernameInitials:'adf-people-widget-pic'"></div>
                    <div *ngIf="user.pictureId" class="adf-people-widget-image-row">
                        <img id="adf-people-widget-pic-{{i}}" class="adf-people-widget-image"
                             [src]="peopleProcessService.getUserImage(user)"/>
                    </div>
                    <span class="adf-people-label-name">{{getDisplayName(user)}}</span>
                </div>
            </mat-option>
        </mat-autocomplete>
    </mat-form-field>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>
`,
                styles: [``],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
PeopleWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: PeopleProcessService, },
];
PeopleWidgetComponent.propDecorators = {
    "input": [{ type: ViewChild, args: ['inputValue',] },],
};

class RadioButtonsWidgetComponent extends WidgetComponent {
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
    }
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getOptionsByTaskId();
            }
            else {
                this.getOptionsByProcessDefinitionId();
            }
        }
    }
    getOptionsByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((result) => {
            this.field.options = result || [];
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    getOptionsByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((result) => {
            this.field.options = result || [];
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    onOptionClick(optionSelected) {
        this.field.value = optionSelected;
        this.fieldChanged.emit(this.field);
    }
    handleError(error) {
        this.logService.error(error);
    }
}
RadioButtonsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'radio-buttons-widget',
                template: `<div class="adf-radio-buttons-widget {{field.className}}"
     [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly" [id]="field.id">
    <div class="adf-radio-button-container">
        <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
        <mat-radio-group class="adf-radio-group" [(ngModel)]="field.value">
            <mat-radio-button
                [id]="field.id + '-' + opt.id"
                [name]="field.id"
                [value]="opt.id"
                [disabled]="field.readOnly"
                [checked]="field.value === opt.id"
                (change)="onOptionClick(opt.id)"
                color="primary"
                class="adf-radio-button" *ngFor="let opt of field.options" >
                {{opt.name}}
            </mat-radio-button>
        </mat-radio-group>
    </div>
    <error-widget [error]="field.validationSummary" ></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>


`,
                styles: [`.adf-radio-button-container{margin-bottom:15px}.adf-radio-group{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.adf-radio-button{margin:5px}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
RadioButtonsWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
];

const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => InputMaskDirective),
    multi: true
};
class InputMaskDirective {
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.translationMask = {
            '0': { pattern: /\d/ },
            '9': { pattern: /\d/, optional: true },
            '#': { pattern: /\d/, recursive: true },
            'A': { pattern: /[a-zA-Z0-9]/ },
            'S': { pattern: /[a-zA-Z]/ }
        };
        this.byPassKeys = [9, 16, 17, 18, 36, 37, 38, 39, 40, 91];
        this.invalidCharacters = [];
        this._onChange = (_) => {
        };
        this._onTouched = () => {
        };
    }
    onTextInput(event) {
        if (this.inputMask && this.inputMask.mask) {
            this.maskValue(this.el.nativeElement.value, this.el.nativeElement.selectionStart, this.inputMask.mask, this.inputMask.isReversed, event.keyCode);
        }
        else {
            this._onChange(this.el.nativeElement.value);
        }
    }
    ngOnChanges(changes) {
        if (changes['inputMask'] && changes['inputMask'].currentValue['mask']) {
            this.inputMask = changes['inputMask'].currentValue;
        }
    }
    writeValue(value) {
        this.el.nativeElement.value = value;
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    maskValue(actualValue, startCaret, maskToApply, isMaskReversed, keyCode) {
        if (this.byPassKeys.indexOf(keyCode) === -1) {
            let                  value = this.getMasked(false, actualValue, maskToApply, isMaskReversed);
            let                  calculatedCaret = this.calculateCaretPosition(startCaret, actualValue, keyCode);
            this.render.setElementAttribute(this.el.nativeElement, 'value', value);
            this.el.nativeElement.value = value;
            this.setValue(value);
            this._onChange(value);
            this.setCaretPosition(calculatedCaret);
        }
    }
    setCaretPosition(caretPosition) {
        this.el.nativeElement.moveStart = caretPosition;
        this.el.nativeElement.moveEnd = caretPosition;
    }
    calculateCaretPosition(caretPosition, newValue, keyCode) {
        let                  newValueLength = newValue.length;
        let                  oldValue = this.getValue() || '';
        let                  oldValueLength = oldValue.length;
        if (keyCode === 8 && oldValue !== newValue) {
            caretPosition = caretPosition - (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
        }
        else if (oldValue !== newValue) {
            if (caretPosition >= oldValueLength) {
                caretPosition = newValueLength;
            }
            else {
                caretPosition = caretPosition + (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
            }
        }
        return caretPosition;
    }
    getMasked(skipMaskChars, val, mask, isReversed = false) {
        let                  buf = [],
        value = val,
        maskIndex = 0,
        maskLen = mask.length,
        valueIndex = 0,
        valueLength = value.length,
        offset = 1,
        addMethod = 'push',
        resetPos = -1,
        lastMaskChar,
        lastUntranslatedMaskChar,
        check;
        if (isReversed) {
            addMethod = 'unshift';
            offset = -1;
            lastMaskChar = 0;
            maskIndex = maskLen - 1;
            valueIndex = valueLength - 1;
        }
        else {
            lastMaskChar = maskLen - 1;
        }
        check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        while (check) {
            let                  maskDigit = mask.charAt(maskIndex),
            valDigit = value.charAt(valueIndex),
            translation = this.translationMask[maskDigit];
            if (translation) {
                if (valDigit.match(translation.pattern)) {
                    buf[addMethod](valDigit);
                    if (translation.recursive) {
                        if (resetPos === -1) {
                            resetPos = maskIndex;
                        }
                        else if (maskIndex === lastMaskChar) {
                            maskIndex = resetPos - offset;
                        }
                        if (lastMaskChar === resetPos) {
                            maskIndex -= offset;
                        }
                    }
                    maskIndex += offset;
                }
                else if (valDigit === lastUntranslatedMaskChar) {
                    lastUntranslatedMaskChar = undefined;
                }
                else if (translation.optional) {
                    maskIndex += offset;
                    valueIndex -= offset;
                }
                else {
                    this.invalidCharacters.push({
                        index: valueIndex,
                        digit: valDigit,
                        translated: translation.pattern
                    });
                }
                valueIndex += offset;
            }
            else {
                if (!skipMaskChars) {
                    buf[addMethod](maskDigit);
                }
                if (valDigit === maskDigit) {
                    valueIndex += offset;
                }
                else {
                    lastUntranslatedMaskChar = maskDigit;
                }
                maskIndex += offset;
            }
            check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        }
        let                  lastMaskCharDigit = mask.charAt(lastMaskChar);
        if (maskLen === valueLength + 1 && !this.translationMask[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
        }
        return buf.join('');
    }
    isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength) {
        let                  check = false;
        if (isReversed) {
            check = (maskIndex > -1) && (valueIndex > -1);
        }
        else {
            check = (maskIndex < maskLen) && (valueIndex < valueLength);
        }
        return check;
    }
    setValue(value) {
        this.value = value;
    }
    getValue() {
        return this.value;
    }
}
InputMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[textMask]',
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR]
            },] },
];
InputMaskDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
];
InputMaskDirective.propDecorators = {
    "inputMask": [{ type: Input, args: ['textMask',] },],
    "onTextInput": [{ type: HostListener, args: ['input', ['$event'],] }, { type: HostListener, args: ['keyup', ['$event'],] },],
};

class TextWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    ngOnInit() {
        if (this.field.params) {
            this.mask = this.field.params['inputMask'];
            this.placeholder = this.field.params['inputMask'] && this.field.params['inputMaskPlaceholder'] ? this.field.params['inputMaskPlaceholder'] : this.field.placeholder;
            this.isMaskReversed = this.field.params['inputMaskReversed'] ? this.field.params['inputMaskReversed'] : false;
        }
    }
}
TextWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'text-widget',
                template: `<div class="adf-textfield adf-text-widget {{field.className}}"
     [class.adf-invalid]="!field.isValid" [class.adf-readonly]="field.readOnly">
    <mat-form-field>
        <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
        <input matInput
               class="adf-input"
               type="text"
               [id]="field.id"
               [required]="isRequired()"
               [value]="field.value"
               [(ngModel)]="field.value"
               (ngModelChange)="onFieldChanged(field)"
               [disabled]="field.readOnly || readOnly"
               [textMask]="{mask: mask, isReversed: isMaskReversed}"
               [placeholder]="placeholder">
    </mat-form-field>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>
`,
                styles: [`.adf-text-widget{width:100%}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
TextWidgetComponent.ctorParameters = () => [
    { type: FormService, },
];

class TypeaheadWidgetComponent extends WidgetComponent {
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.minTermLength = 1;
        this.options = [];
    }
    ngOnInit() {
        if (this.field.form.taskId && this.field.restUrl) {
            this.getValuesByTaskId();
        }
        else if (this.field.form.processDefinitionId && this.field.restUrl) {
            this.getValuesByProcessDefinitionId();
        }
        if (this.isReadOnlyType()) {
            this.value = this.field.value;
        }
    }
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((result) => {
            let                  options = result || [];
            this.field.options = options;
            let                  fieldValue = this.field.value;
            if (fieldValue) {
                let                  toSelect = options.find(item => item.id === fieldValue || item.name.toLocaleLowerCase() === fieldValue.toLocaleLowerCase());
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.onFieldChanged(this.field);
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((result) => {
            let                  options = result || [];
            this.field.options = options;
            let                  fieldValue = this.field.value;
            if (fieldValue) {
                let                  toSelect = options.find(item => item.id === fieldValue);
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.onFieldChanged(this.field);
            this.field.updateForm();
        }, err => this.handleError(err));
    }
    getOptions() {
        let                  val = this.value.trim().toLocaleLowerCase();
        return this.field.options.filter(item => {
            let                  name = item.name.toLocaleLowerCase();
            return name.indexOf(val) > -1;
        });
    }
    isValidOptionName(optionName) {
        let                  option = this.field.options.find(item => item.name && item.name.toLocaleLowerCase() === optionName.toLocaleLowerCase());
        return option ? true : false;
    }
    onKeyUp(event) {
        if (this.value && this.value.trim().length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                if (this.value.length >= this.minTermLength) {
                    this.options = this.getOptions();
                    this.oldValue = this.value;
                    if (this.isValidOptionName(this.value)) {
                        this.field.value = this.options[0].id;
                    }
                }
            }
        }
        if (this.isValueDefined() && this.value.trim().length === 0) {
            this.oldValue = this.value;
            this.options = [];
        }
    }
    onItemSelect(item) {
        if (item) {
            this.field.value = item.id;
            this.value = item.name;
            this.onFieldChanged(this.field);
        }
    }
    validate() {
        this.field.value = this.value;
    }
    isValueDefined() {
        return this.value !== null && this.value !== undefined;
    }
    handleError(error) {
        this.logService.error(error);
    }
    isReadOnlyType() {
        return this.field.type === 'readonly' ? true : false;
    }
}
TypeaheadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'typeahead-widget',
                template: `<div class="adf-typeahead-widget-container">
    <div class="adf-typeahead-widget {{field.className}}"
        [class.is-dirty]="value"
        [class.adf-invalid]="!field.isValid"
        [class.adf-readonly]="field.readOnly"
        id="typehead-div">
        <mat-form-field>
            <label class="adf-label" [attr.for]="field.id">{{field.name}}</label>
            <input matInput class="adf-input"
                   type="text"
                   [id]="field.id"
                   [(ngModel)]="value"
                   (ngModelChange)="validate()"
                   (keyup)="onKeyUp($event)"
                   [disabled]="field.readOnly"
                   placeholder="{{field.placeholder}}"
                   [matAutocomplete]="auto">
            <mat-autocomplete #auto="matAutocomplete" (optionSelected)="onItemSelect($event.option.value)">
                <mat-option *ngFor="let item of options" [value]="item">
                    <span [id]="field.name+'_option_'+item.id">{{item.name}}</span>
                </mat-option>
            </mat-autocomplete>
        </mat-form-field>

        <error-widget [error]="field.validationSummary"></error-widget>
        <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
    </div>
</div>
`,
                styles: [`.adf-typeahead-widget-container{position:relative;display:block}.adf-typeahead-widget{width:100%}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
TypeaheadWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
];

class UploadWidgetComponent extends WidgetComponent {
    constructor(formService, logService, thumbnailService, processContentService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
        this.processContentService = processContentService;
        this.multipleOption = '';
    }
    ngOnInit() {
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0) {
            this.hasFile = true;
        }
        this.getMultipleFileParam();
    }
    removeFile(file) {
        if (this.field) {
            this.removeElementFromList(file);
        }
    }
    onFileChanged(event) {
        let                  files = event.target.files;
        let                  filesSaved = [];
        if (this.field.json.value) {
            filesSaved = [...this.field.json.value];
        }
        if (files && files.length > 0) {
            Observable.from(files).mergeMap(file => this.uploadRawContent(file)).subscribe((res) => {
                filesSaved.push(res);
            }, (error) => {
                this.logService.error('Error uploading file. See console output for more details.');
            }, () => {
                this.field.value = filesSaved;
                this.field.json.value = filesSaved;
            });
            this.hasFile = true;
        }
    }
    uploadRawContent(file) {
        return this.processContentService.createTemporaryRawRelatedContent(file)
            .map((response) => {
            this.logService.info(response);
            response.contentBlob = file;
            return response;
        });
    }
    getMultipleFileParam() {
        if (this.field &&
            this.field.params && this.field.params["multiple"]) {
            this.multipleOption = this.field.params["multiple"] ? 'multiple' : '';
        }
    }
    removeElementFromList(file) {
        let                  index = this.field.value.indexOf(file);
        if (index !== -1) {
            this.field.value.splice(index, 1);
            this.field.json.value = this.field.value;
            this.field.updateForm();
        }
        this.hasFile = this.field.value.length > 0;
        this.resetFormValueWithNoFiles();
    }
    resetFormValueWithNoFiles() {
        if (this.field.value.length === 0) {
            this.field.value = [];
            this.field.json.value = [];
        }
    }
    getIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    fileClicked(obj) {
        const                  file = new ContentLinkModel(obj);
        let                  fetch = this.processContentService.getContentPreview(file.id);
        if (file.isTypeImage() || file.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(file.id);
        }
        fetch.subscribe((blob) => {
            file.contentBlob = blob;
            this.formService.formContentClicked.next(file);
        }, (error) => {
            this.logService.error('Unable to send event for file ' + file.name);
        });
    }
}
UploadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'upload-widget',
                template: `<div class="adf-upload-widget {{field.className}}"
     [class.adf-invalid]="!field.isValid"
     [class.adf-readonly]="field.readOnly">
    <label class="adf-label" [attr.for]="field.id">{{field.name}}<span *ngIf="isRequired()">*</span></label>
    <div class="adf-upload-widget-container">
        <div>
            <mat-list *ngIf="hasFile">
                <mat-list-item class="adf-upload-files-row" *ngFor="let file of field.value">
                    <img mat-list-icon class="adf-upload-widget__icon"
                         [id]="'file-'+file.id+'-icon'"
                         [src]="getIcon(file.mimeType)"
                         [alt]="mimeTypeIcon"
                         (click)="fileClicked(file)"
                         (keyup.enter)="fileClicked(file)"
                         role="button"
                         tabindex="0"/>
                    <span matLine id="{{'file-'+file.id}}" (click)="fileClicked(file)" (keyup.enter)="fileClicked(file)"
                          role="button" tabindex="0" class="adf-file">{{file.name}}</span>
                    <button *ngIf="!field.readOnly" mat-icon-button [id]="'file-'+file.id+'-remove'"
                            (click)="removeFile(file);" (keyup.enter)="removeFile(file);">
                        <mat-icon class="mat-24">highlight_off</mat-icon>
                    </button>
                </mat-list-item>
            </mat-list>
        </div>

        <div class="button-row" *ngIf="(!hasFile || multipleOption) && !field.readOnly">
            <a mat-raised-button color="primary">
                {{ 'FORM.FIELD.UPLOAD' | translate }}<mat-icon>file_upload</mat-icon>
                <input #uploadFiles
                       [multiple]="multipleOption"
                       type="file"
                       [id]="field.id"
                       (change)="onFileChanged($event)"/>
            </a>
        </div>
    </div>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
</div>
`,
                styles: [`.adf-upload-widget-container{margin-bottom:15px}.adf-upload-widget-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}.adf-upload-widget{width:100%;word-break:break-all;padding:.4375em 0;border-top:.84375em solid transparent}.adf-upload-widget__icon{padding:6px;float:left;cursor:pointer}.adf-upload-widget__reset{margin-top:-2px}.adf-upload-files-row .mat-line{margin-bottom:0}`],
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            },] },
];
UploadWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: LogService, },
    { type: ThumbnailService, },
    { type: ProcessContentService, },
];
UploadWidgetComponent.propDecorators = {
    "fileInput": [{ type: ViewChild, args: ['uploadFiles',] },],
};

const ɵ0$3 = MOMENT_DATE_FORMATS;
const ɵ1$1 = MAT_MOMENT_DATETIME_FORMATS;
class DateTimeWidgetComponent extends WidgetComponent {
    constructor(formService, dateAdapter, preferences) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
    }
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        let                  momentDateAdapter =                  (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
        }
        this.displayDate = moment(this.field.value, this.field.dateDisplayFormat);
    }
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            this.field.value = newDateValue.value.format(this.field.dateDisplayFormat);
        }
        else if (newDateValue) {
            this.field.value = newDateValue;
        }
        else {
            this.field.value = null;
        }
        this.onFieldChanged(this.field);
    }
}
DateTimeWidgetComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$3 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1$1 }
                ],
                selector: 'date-time-widget',
                template: `<div class="{{field.className}}"
     id="data-time-widget" [class.adf-invalid]="!field.isValid">
    <mat-form-field class="adf-date-time-widget">
        <label class="adf-label" [attr.for]="field.id">{{field.name}} ({{field.dateDisplayFormat}})<span *ngIf="isRequired()">*</span></label>
        <input matInput
               [matDatetimepicker]="datetimePicker"
               [id]="field.id"
               [(ngModel)]="displayDate"
               [required]="isRequired()"
               [disabled]="field.readOnly"
               [min]="minDate"
               [max]="maxDate"
               (focusout)="onDateChanged($event.srcElement.value)"
               (dateChange)="onDateChanged($event)"
               placeholder="{{field.placeholder}}">
        <mat-datetimepicker-toggle matSuffix [for]="datetimePicker" [disabled]="field.readOnly"></mat-datetimepicker-toggle>
    </mat-form-field>
    <error-widget [error]="field.validationSummary"></error-widget>
    <error-widget *ngIf="isInvalidFieldRequired()" required="{{ 'FORM.FIELD.REQUIRED' | translate }}"></error-widget>
    <mat-datetimepicker #datetimePicker type="datetime" openOnFocus="true" timeInterval="5"></mat-datetimepicker>
</div>
`,
                styles: [`.adf-date-time-widget .mat-input-suffix{text-align:right;position:absolute;margin-top:30px;width:100%}`],
                encapsulation: ViewEncapsulation.None
            },] },
];
DateTimeWidgetComponent.ctorParameters = () => [
    { type: FormService, },
    { type: DateAdapter, },
    { type: UserPreferencesService, },
];

const WIDGET_DIRECTIVES = [
    UnknownWidgetComponent,
    TabsWidgetComponent,
    ContainerWidgetComponent,
    TextWidgetComponent,
    NumberWidgetComponent,
    CheckboxWidgetComponent,
    MultilineTextWidgetComponentComponent,
    DropdownWidgetComponent,
    HyperlinkWidgetComponent,
    RadioButtonsWidgetComponent,
    DisplayTextWidgetComponentComponent,
    UploadWidgetComponent,
    TypeaheadWidgetComponent,
    FunctionalGroupWidgetComponent,
    PeopleWidgetComponent,
    DateWidgetComponent,
    AmountWidgetComponent,
    DynamicTableWidgetComponent,
    DateEditorComponent,
    DropdownEditorComponent,
    BooleanEditorComponent,
    TextEditorComponent,
    RowEditorComponent,
    ErrorWidgetComponent,
    DocumentWidgetComponent,
    DateTimeWidgetComponent
];
const MASK_DIRECTIVE = [
    InputMaskDirective
];

class FormRenderingService extends DynamicComponentMapper {
    constructor() {
        super();
        this.defaultValue = UnknownWidgetComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(TextWidgetComponent),
            'string': DynamicComponentResolver.fromType(TextWidgetComponent),
            'integer': DynamicComponentResolver.fromType(NumberWidgetComponent),
            'multi-line-text': DynamicComponentResolver.fromType(MultilineTextWidgetComponentComponent),
            'boolean': DynamicComponentResolver.fromType(CheckboxWidgetComponent),
            'dropdown': DynamicComponentResolver.fromType(DropdownWidgetComponent),
            'date': DynamicComponentResolver.fromType(DateWidgetComponent),
            'amount': DynamicComponentResolver.fromType(AmountWidgetComponent),
            'radio-buttons': DynamicComponentResolver.fromType(RadioButtonsWidgetComponent),
            'hyperlink': DynamicComponentResolver.fromType(HyperlinkWidgetComponent),
            'readonly-text': DynamicComponentResolver.fromType(DisplayTextWidgetComponentComponent),
            'typeahead': DynamicComponentResolver.fromType(TypeaheadWidgetComponent),
            'people': DynamicComponentResolver.fromType(PeopleWidgetComponent),
            'functional-group': DynamicComponentResolver.fromType(FunctionalGroupWidgetComponent),
            'dynamic-table': DynamicComponentResolver.fromType(DynamicTableWidgetComponent),
            'container': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'group': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'document': DynamicComponentResolver.fromType(DocumentWidgetComponent),
            'upload': DynamicComponentResolver.fromType(UploadWidgetComponent),
            'datetime': DynamicComponentResolver.fromType(DateTimeWidgetComponent)
        };
    }
}
FormRenderingService.decorators = [
    { type: Injectable },
];
FormRenderingService.ctorParameters = () => [];

class ActivitiContentService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    getAlfrescoNodes(accountId, folderId) {
        let                  apiService = this.apiService.getInstance();
        let                  accountShortId = accountId.replace('alfresco-', '');
        return Observable.fromPromise(apiService.activiti.alfrescoApi.getContentInFolder(accountShortId, folderId))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    getAlfrescoRepositories(tenantId, includeAccount) {
        let                  apiService = this.apiService.getInstance();
        const                  opts = {
            tenantId: tenantId,
            includeAccounts: includeAccount
        };
        return Observable.fromPromise(apiService.activiti.alfrescoApi.getRepositories(opts))
            .map(this.toJsonArray)
            .catch(err => this.handleError(err));
    }
    linkAlfrescoNode(accountId, node, siteId) {
        let                  apiService = this.apiService.getInstance();
        return Observable.fromPromise(apiService.activiti.contentApi.createTemporaryRelatedContent({
            link: true,
            name: node.title,
            simpleType: node.simpleType,
            source: accountId,
            sourceId: node.id + '@' + siteId
        })).map(this.toJson).catch(err => this.handleError(err));
    }
    applyAlfrescoNode(node, siteId, accountId) {
        let                  apiService = this.apiService.getInstance();
        let                  params = {
            source: accountId,
            sourceId: node.id + ';1.0@' + siteId,
            name: node.name,
            link: false
        };
        return Observable.fromPromise(apiService.activiti.contentApi.createTemporaryRelatedContent(params))
            .map(this.toJson)
            .catch(err => this.handleError(err));
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    handleError(error) {
        let                  errMsg = ActivitiContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ActivitiContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return Observable.throw(errMsg);
    }
}
ActivitiContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ActivitiContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ActivitiContentService.decorators = [
    { type: Injectable },
];
ActivitiContentService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class StartFormCustomButtonDirective {
}
StartFormCustomButtonDirective.decorators = [
    { type: Directive, args: [{ selector: '[form-custom-button]' },] },
];
StartFormCustomButtonDirective.ctorParameters = () => [];

class FormFieldComponent {
    constructor(formRenderingService, componentFactoryResolver, visibilityService, compiler) {
        this.formRenderingService = formRenderingService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.visibilityService = visibilityService;
        this.compiler = compiler;
        this.field = null;
        this.focus = false;
    }
    ngOnInit() {
        const                  w = window;
        if (w.adf === undefined) {
            w.adf = {};
        }
        let                  originalField = this.getField();
        if (originalField) {
            let                  customTemplate = this.field.form.customFieldTemplates[originalField.type];
            if (customTemplate && this.hasController(originalField.type)) {
                let                  factory = this.getComponentFactorySync(originalField.type, customTemplate);
                this.componentRef = this.container.createComponent(factory);
                let                  instance = this.componentRef.instance;
                if (instance) {
                    instance.field = originalField;
                }
            }
            else {
                let                  componentType = this.formRenderingService.resolveComponentType(originalField);
                if (componentType) {
                    let                  factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
                    this.componentRef = this.container.createComponent(factory);
                    let                  instance =                  (this.componentRef.instance);
                    instance.field = this.field;
                    instance.fieldChanged.subscribe(field => {
                        if (field && this.field.form) {
                            this.visibilityService.refreshVisibility(field.form);
                            field.form.onFormFieldChanged(field);
                        }
                    });
                }
            }
        }
    }
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    getField() {
        if (this.field && this.field.params) {
            const                  wrappedField = this.field.params["field"];
            if (wrappedField && wrappedField.type) {
                return wrappedField;
            }
        }
        return this.field;
    }
    hasController(type) {
        return (adf && adf.components && adf.components[type]);
    }
    getComponentFactorySync(type, template) {
        let                  componentInfo = adf.components[type];
        if (componentInfo.factory) {
            return componentInfo.factory;
        }
        let                  metadata = {
            selector: `runtime-component-${type}`,
            template: template
        };
        let                  factory = this.createComponentFactorySync(this.compiler, metadata, componentInfo.class);
        componentInfo.factory = factory;
        return factory;
    }
    createComponentFactorySync(compiler, metadata, componentClass) {
        const                  cmpClass = componentClass || class RuntimeComponent {
        };
        const                  decoratedCmp = Component(metadata)(cmpClass);
        class RuntimeComponentModule {
        }
        RuntimeComponentModule.decorators = [
            { type: NgModule, args: [{ imports: [], declarations: [decoratedCmp] },] },
        ];
        RuntimeComponentModule.ctorParameters = () => [];
        let                  module = compiler.compileModuleAndAllComponentsSync(RuntimeComponentModule);
        return module.componentFactories.find(x => x.componentType === decoratedCmp);
    }
    focusToggle() {
        this.focus = !this.focus;
    }
}
FormFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-field, form-field',
                template: `
        <div [id]="'field-'+field?.id+'-container'"
            [hidden]="!field?.isVisible"
            [class.adf-focus]="focus"
            (focusin)="focusToggle()"
            (focusout)="focusToggle()">
            <div #container></div>
        </div>
    `,
                encapsulation: ViewEncapsulation.None
            },] },
];
FormFieldComponent.ctorParameters = () => [
    { type: FormRenderingService, },
    { type: ComponentFactoryResolver, },
    { type: WidgetVisibilityService, },
    { type: Compiler, },
];
FormFieldComponent.propDecorators = {
    "container": [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] },],
    "field": [{ type: Input },],
};

class FormModule {
}
FormModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    DataTableModule,
                    HttpModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DataColumnModule,
                    PipeModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule
                ],
                declarations: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormComponent,
                    FormListComponent,
                    StartFormComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES,
                    ...MASK_DIRECTIVE,
                    WidgetComponent
                ],
                entryComponents: [
                    ...WIDGET_DIRECTIVES
                ],
                providers: [
                    ActivitiContentService,
                    EcmModelService,
                    FormRenderingService,
                    FormService,
                    NodeService,
                    ProcessContentService,
                    WidgetVisibilityService
                ],
                exports: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormComponent,
                    FormListComponent,
                    StartFormComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES
                ]
            },] },
];
FormModule.ctorParameters = () => [];

class SidenavLayoutContentDirective {
}
SidenavLayoutContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-content'
            },] },
];
SidenavLayoutContentDirective.ctorParameters = () => [];
SidenavLayoutContentDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class SidenavLayoutHeaderDirective {
}
SidenavLayoutHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-header'
            },] },
];
SidenavLayoutHeaderDirective.ctorParameters = () => [];
SidenavLayoutHeaderDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class SidenavLayoutNavigationDirective {
}
SidenavLayoutNavigationDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-navigation'
            },] },
];
SidenavLayoutNavigationDirective.ctorParameters = () => [];
SidenavLayoutNavigationDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class SidenavLayoutComponent {
    constructor(mediaMatcher) {
        this.mediaMatcher = mediaMatcher;
        this.hideSidenav = false;
        this.expandedSidenav = true;
        this.templateContext = {
            toggleMenu: () => { },
            isMenuMinimized: () => this.isMenuMinimized
        };
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    ngOnInit() {
        const                  stepOver = this.stepOver || SidenavLayoutComponent.STEP_OVER;
        this.isMenuMinimized = !this.expandedSidenav;
        this.mediaQueryList = this.mediaMatcher.matchMedia(`(max-width: ${stepOver}px)`);
        this.mediaQueryList.addListener(this.onMediaQueryChange);
    }
    ngAfterViewInit() {
        this.templateContext.toggleMenu = this.toggleMenu.bind(this);
    }
    ngOnDestroy() {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
    }
    toggleMenu() {
        if (!this.mediaQueryList.matches) {
            this.isMenuMinimized = !this.isMenuMinimized;
        }
        else {
            this.isMenuMinimized = false;
        }
        this.container.toggleMenu();
    }
    get isHeaderInside() {
        return this.mediaQueryList.matches;
    }
    get headerTemplate() {
        return this.headerDirective && this.headerDirective.template || this.emptyTemplate;
    }
    get navigationTemplate() {
        return this.navigationDirective && this.navigationDirective.template || this.emptyTemplate;
    }
    get contentTemplate() {
        return this.contentDirective && this.contentDirective.template || this.emptyTemplate;
    }
    onMediaQueryChange() {
        this.isMenuMinimized = false;
    }
}
SidenavLayoutComponent.STEP_OVER = 600;
SidenavLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sidenav-layout',
                template: `<div class="sidenav-layout">
    <ng-container *ngIf="!isHeaderInside">
        <ng-container class="adf-sidenav-layout-outer-header" *ngTemplateOutlet="headerTemplate; context:templateContext"></ng-container>
    </ng-container>

    <adf-layout-container #container
        [sidenavMin]="sidenavMin"
        [sidenavMax]="sidenavMax"
        [mediaQueryList]="mediaQueryList"
        [hideSidenav]="hideSidenav"
        [expandedSidenav]="expandedSidenav"
        data-automation-id="adf-layout-container"
        class="layout__content">

        <ng-container app-layout-navigation *ngTemplateOutlet="navigationTemplate; context:templateContext"></ng-container>

        <ng-container app-layout-content>
            <ng-container *ngIf="isHeaderInside">
                <ng-container *ngTemplateOutlet="headerTemplate; context:templateContext"></ng-container>
            </ng-container>
            <ng-container *ngTemplateOutlet="contentTemplate; context:templateContext"></ng-container>
        </ng-container>
    </adf-layout-container>
</div>

<ng-template #emptyTemplate></ng-template>`,
                styles: [`:host{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex:1;flex:1}:host .sidenav-layout{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}:host .sidenav-layout .layout__content{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}:host router-outlet{-webkit-box-flex:0;-ms-flex:0 0;flex:0 0}`]
            },] },
];
SidenavLayoutComponent.ctorParameters = () => [
    { type: MediaMatcher, },
];
SidenavLayoutComponent.propDecorators = {
    "sidenavMin": [{ type: Input },],
    "sidenavMax": [{ type: Input },],
    "stepOver": [{ type: Input },],
    "hideSidenav": [{ type: Input },],
    "expandedSidenav": [{ type: Input },],
    "headerDirective": [{ type: ContentChild, args: [SidenavLayoutHeaderDirective,] },],
    "navigationDirective": [{ type: ContentChild, args: [SidenavLayoutNavigationDirective,] },],
    "contentDirective": [{ type: ContentChild, args: [SidenavLayoutContentDirective,] },],
    "container": [{ type: ViewChild, args: ['container',] },],
    "emptyTemplate": [{ type: ViewChild, args: ['emptyTemplate',] },],
};

const sidenavAnimation = trigger('sidenavAnimation', [
    state('expanded', style({ width: '{{ width }}px' }), { params: { width: 0 } }),
    state('compact', style({ width: '{{ width }}px' }), { params: { width: 0 } }),
    transition('compact <=> expanded', animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);
const contentAnimation = trigger('contentAnimation', [
    state('expanded', style({ 'margin-left': '{{ marginLeft }}px' }), { params: { marginLeft: 0 } }),
    state('compact', style({ 'margin-left': '{{ marginLeft }}px' }), { params: { marginLeft: 0 } }),
    transition('expanded <=> compact', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);

class LayoutContainerComponent {
    constructor() {
        this.hideSidenav = false;
        this.expandedSidenav = true;
        this.SIDENAV_STATES = { MOBILE: {}, EXPANDED: {}, COMPACT: {} };
        this.CONTENT_STATES = { MOBILE: {}, EXPANDED: {}, COMPACT: {} };
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    ngOnInit() {
        this.SIDENAV_STATES.MOBILE = { value: 'expanded', params: { width: this.sidenavMax } };
        this.SIDENAV_STATES.EXPANDED = { value: 'expanded', params: { width: this.sidenavMax } };
        this.SIDENAV_STATES.COMPACT = { value: 'compact', params: { width: this.sidenavMin } };
        this.CONTENT_STATES.MOBILE = { value: 'expanded', params: { marginLeft: 0 } };
        this.CONTENT_STATES.EXPANDED = { value: 'expanded', params: { marginLeft: this.sidenavMin } };
        this.CONTENT_STATES.COMPACT = { value: 'compact', params: { marginLeft: this.sidenavMax } };
        this.mediaQueryList.addListener(this.onMediaQueryChange);
        if (this.isMobileScreenSize) {
            this.sidenavAnimationState = this.SIDENAV_STATES.MOBILE;
            this.contentAnimationState = this.CONTENT_STATES.MOBILE;
        }
        else if (this.expandedSidenav) {
            this.sidenavAnimationState = this.SIDENAV_STATES.EXPANDED;
            this.contentAnimationState = this.CONTENT_STATES.COMPACT;
        }
        else {
            this.sidenavAnimationState = this.SIDENAV_STATES.COMPACT;
            this.contentAnimationState = this.CONTENT_STATES.EXPANDED;
        }
    }
    ngOnDestroy() {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
    }
    toggleMenu() {
        if (this.isMobileScreenSize) {
            this.sidenav.toggle();
        }
        else {
            this.sidenavAnimationState = this.toggledSidenavAnimation;
            this.contentAnimationState = this.toggledContentAnimation;
        }
    }
    get toggledSidenavAnimation() {
        return this.sidenavAnimationState === this.SIDENAV_STATES.EXPANDED
            ? this.SIDENAV_STATES.COMPACT
            : this.SIDENAV_STATES.EXPANDED;
    }
    get toggledContentAnimation() {
        if (this.isMobileScreenSize) {
            return this.CONTENT_STATES.MOBILE;
        }
        if (this.sidenavAnimationState === this.SIDENAV_STATES.EXPANDED) {
            return this.CONTENT_STATES.COMPACT;
        }
        else {
            return this.CONTENT_STATES.EXPANDED;
        }
    }
    get isMobileScreenSize() {
        return this.mediaQueryList.matches;
    }
    onMediaQueryChange() {
        this.sidenavAnimationState = this.SIDENAV_STATES.EXPANDED;
        this.contentAnimationState = this.toggledContentAnimation;
    }
}
LayoutContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-layout-container',
                template: `<mat-sidenav-container>
    <mat-sidenav
        [ngClass]="{ 'sidenav--hidden': hideSidenav }"
        [@sidenavAnimation]="sidenavAnimationState"
        [opened]="!isMobileScreenSize"
        [mode]="isMobileScreenSize ? 'over' : 'side'">
        <ng-content sidenav select="[app-layout-navigation]"></ng-content>
    </mat-sidenav>

    <div>
        <div [@contentAnimation]="contentAnimationState" style="margin-left: 0 !important">
            <ng-content select="[app-layout-content]"></ng-content>
        </div>
    </div>
</mat-sidenav-container>
`,
                styles: [`:host{display:block;width:100%;height:100%;overflow:hidden}ng-content{display:block;width:100%;height:100%;overflow:hidden}.sidenav--hidden{visibility:hidden!important;width:0!important;-webkit-transform:unset!important;transform:unset!important;opacity:0!important}.mat-sidenav-container{display:block;width:100%;height:100%;overflow:hidden}.mat-sidenav{overflow:hidden}:host ::ng-deep mat-sidenav-content{margin-left:0!important}.mat-drawer-transition .mat-drawer-content,.mat-sidenav-content{-webkit-transform:unset!important;transform:unset!important;-webkit-transition-property:unset!important;transition-property:unset!important;-webkit-transition-duration:unset!important;transition-duration:unset!important;-webkit-transition-timing-function:unset!important;transition-timing-function:unset!important}`],
                animations: [sidenavAnimation, contentAnimation]
            },] },
];
LayoutContainerComponent.ctorParameters = () => [];
LayoutContainerComponent.propDecorators = {
    "sidenavMin": [{ type: Input },],
    "sidenavMax": [{ type: Input },],
    "mediaQueryList": [{ type: Input },],
    "hideSidenav": [{ type: Input },],
    "expandedSidenav": [{ type: Input },],
    "sidenav": [{ type: ViewChild, args: [MatSidenav,] },],
};

class SidenavLayoutModule {
}
SidenavLayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                exports: [
                    SidenavLayoutHeaderDirective,
                    SidenavLayoutContentDirective,
                    SidenavLayoutNavigationDirective,
                    SidenavLayoutComponent,
                    LayoutContainerComponent
                ],
                declarations: [
                    SidenavLayoutHeaderDirective,
                    SidenavLayoutContentDirective,
                    SidenavLayoutNavigationDirective,
                    SidenavLayoutComponent,
                    LayoutContainerComponent
                ]
            },] },
];
SidenavLayoutModule.ctorParameters = () => [];

class CommentListComponent {
    constructor(datePipe, peopleProcessService, ecmUserService) {
        this.datePipe = datePipe;
        this.peopleProcessService = peopleProcessService;
        this.ecmUserService = ecmUserService;
        this.clickRow = new EventEmitter();
    }
    selectComment(comment) {
        if (this.selectedComment) {
            this.selectedComment.isSelected = false;
        }
        comment.isSelected = true;
        this.selectedComment = comment;
        this.clickRow.emit(this.selectedComment);
    }
    getUserShortName(user) {
        let                  shortName = '';
        if (user) {
            if (user.firstName) {
                shortName = user.firstName[0].toUpperCase();
            }
            if (user.lastName) {
                shortName += user.lastName[0].toUpperCase();
            }
        }
        return shortName;
    }
    isPictureDefined(user) {
        return user.pictureId || user.avatarId;
    }
    getUserImage(user) {
        if (this.isAContentUsers(user)) {
            return this.ecmUserService.getUserProfileImage(user.avatarId);
        }
        else {
            return this.peopleProcessService.getUserImage(user);
        }
    }
    transformDate(aDate) {
        let                  formattedDate;
        let                  givenDate = Number.parseInt(this.datePipe.transform(aDate, 'yMMdd'));
        let                  today = Number.parseInt(this.datePipe.transform(Date.now(), 'yMMdd'));
        if (givenDate === today) {
            formattedDate = 'Today, ' + this.datePipe.transform(aDate, 'hh:mm a');
        }
        else {
            let                  yesterday = Number.parseInt(this.datePipe.transform(Date.now() - 24 * 3600 * 1000, 'yMMdd'));
            if (givenDate === yesterday) {
                formattedDate = 'Yesterday, ' + this.datePipe.transform(aDate, 'hh:mm a');
            }
            else {
                formattedDate = this.datePipe.transform(aDate, 'MMM dd y, hh:mm a');
            }
        }
        return formattedDate;
    }
    isAContentUsers(user) {
        return user.avatarId;
    }
}
CommentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comment-list',
                template: ` <mat-list class="adf-comment-list">
    <mat-list-item *ngFor="let comment of comments"
                  (click)="selectComment(comment)"
                  class="adf-comment-list-item"
                  [class.is-selected]="comment.isSelected"
                  id="adf-comment-{{comment?.id}}">
        <div id="comment-user-icon" class="adf-comment-img-container">
            <div
                *ngIf="!isPictureDefined(comment.createdBy)"
                class="adf-comment-user-icon">
                {{getUserShortName(comment.createdBy)}}
            </div>
            <div>
                <img *ngIf="isPictureDefined(comment.createdBy)"
                      class="adf-people-img"
                     [src]="getUserImage(comment.createdBy)"
                />
            </div>
        </div>
        <div class="adf-comment-contents">
            <div matLine id="comment-user" class="adf-comment-user-name">
                {{comment.createdBy?.firstName}} {{comment.createdBy?.lastName}}
            </div>
            <div matLine id="comment-message" class="adf-comment-message">
                {{comment.message}}
            </div>
            <div matLine id="comment-time" class="adf-comment-message-time">
                {{transformDate(comment.created)}}
            </div>
        </div>
    </mat-list-item>
</mat-list>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
CommentListComponent.ctorParameters = () => [
    { type: DatePipe, },
    { type: PeopleProcessService, },
    { type: EcmUserService, },
];
CommentListComponent.propDecorators = {
    "comments": [{ type: Input },],
    "clickRow": [{ type: Output },],
};

class CommentModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id;
            this.message = obj.message;
            this.created = obj.created;
            this.createdBy = obj.createdBy;
            this.isSelected = obj.isSelected ? obj.isSelected : false;
        }
    }
}

class UserProcessModel {
    constructor(obj) {
        this.pictureId = null;
        if (obj) {
            this.id = obj.id;
            this.email = obj.email || null;
            this.firstName = obj.firstName || null;
            this.lastName = obj.lastName || null;
            this.pictureId = obj.pictureId || null;
        }
    }
}

class CommentProcessService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    addTaskComment(taskId, message) {
        return Observable.fromPromise(this.apiService.getInstance().activiti.taskApi.addTaskComment({ message: message }, taskId))
            .map(res => res)
            .map((response) => {
            return new CommentModel({
                id: response.id,
                message: response.message,
                created: response.created,
                createdBy: response.createdBy
            });
        }).catch(err => this.handleError(err));
    }
    getTaskComments(taskId) {
        return Observable.fromPromise(this.apiService.getInstance().activiti.taskApi.getTaskComments(taskId))
            .map(res => res)
            .map((response) => {
            let                  comments = [];
            response.data.forEach((comment) => {
                let                  user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentModel({ id: comment.id, message: comment.message, created: comment.created, createdBy: user }));
            });
            return comments;
        }).catch(err => this.handleError(err));
    }
    getProcessInstanceComments(processInstanceId) {
        return Observable.fromPromise(this.apiService.getInstance().activiti.commentsApi.getProcessInstanceComments(processInstanceId))
            .map(res => res)
            .map((response) => {
            let                  comments = [];
            response.data.forEach((comment) => {
                let                  user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentModel({ id: comment.id, message: comment.message, created: comment.created, createdBy: user }));
            });
            return comments;
        }).catch(err => this.handleError(err));
    }
    addProcessInstanceComment(processInstanceId, message) {
        return Observable.fromPromise(this.apiService.getInstance().activiti.commentsApi.addProcessInstanceComment({ message: message }, processInstanceId))
            .map((response) => {
            return new CommentModel({
                id: response.id,
                message: response.message,
                created: response.created,
                createdBy: response.createdBy
            });
        }).catch(err => this.handleError(err));
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
CommentProcessService.decorators = [
    { type: Injectable },
];
CommentProcessService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class CommentContentService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    addNodeComment(nodeId, message) {
        return Observable.fromPromise(this.apiService.getInstance().core.commentsApi.addComment(nodeId, { content: message }))
            .map((response) => {
            return new CommentModel({
                id: response.entry.id,
                message: response.entry.content,
                created: response.entry.createdAt,
                createdBy: response.entry.createdBy
            });
        }).catch(err => this.handleError(err));
    }
    getNodeComments(nodeId) {
        return Observable.fromPromise(this.apiService.getInstance().core.commentsApi.getComments(nodeId))
            .map((response) => {
            const                  comments = [];
            response.list.entries.forEach((comment) => {
                comments.push(new CommentModel({
                    id: comment.entry.id,
                    message: comment.entry.content,
                    created: comment.entry.createdAt,
                    createdBy: comment.entry.createdBy
                }));
            });
            return comments;
        }).catch(err => this.handleError(err));
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
CommentContentService.decorators = [
    { type: Injectable },
];
CommentContentService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class CommentsComponent {
    constructor(commentProcessService, commentContentService) {
        this.commentProcessService = commentProcessService;
        this.commentContentService = commentContentService;
        this.readOnly = false;
        this.error = new EventEmitter();
        this.comments = [];
        this.beingAdded = false;
        this.comment$ = new Observable(observer => this.commentObserver = observer).share();
        this.comment$.subscribe((comment) => {
            this.comments.push(comment);
        });
    }
    ngOnChanges(changes) {
        this.taskId = null;
        this.nodeId = null;
        this.taskId = changes['taskId'] ? changes['taskId'].currentValue : null;
        this.nodeId = changes['nodeId'] ? changes['nodeId'].currentValue : null;
        if (this.taskId || this.nodeId) {
            this.getComments();
        }
        else {
            this.resetComments();
        }
    }
    getComments() {
        this.resetComments();
        if (this.isATask()) {
            this.commentProcessService.getTaskComments(this.taskId).subscribe((res) => {
                if (res && res instanceof Array) {
                    res = res.sort((comment1, comment2) => {
                        let                  date1 = new Date(comment1.created);
                        let                  date2 = new Date(comment2.created);
                        return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                    });
                    res.forEach((comment) => {
                        this.commentObserver.next(comment);
                    });
                }
            }, (err) => {
                this.error.emit(err);
            });
        }
        if (this.isANode()) {
            this.commentContentService.getNodeComments(this.nodeId).subscribe((res) => {
                if (res && res instanceof Array) {
                    res = res.sort((comment1, comment2) => {
                        const                  date1 = new Date(comment1.created);
                        const                  date2 = new Date(comment2.created);
                        return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                    });
                    res.forEach((comment) => {
                        this.commentObserver.next(comment);
                    });
                }
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    resetComments() {
        this.comments = [];
    }
    add() {
        if (this.message && this.message.trim() && !this.beingAdded) {
            this.beingAdded = true;
            if (this.isATask()) {
                this.commentProcessService.addTaskComment(this.taskId, this.message)
                    .subscribe((res) => {
                    this.comments.unshift(res);
                    this.message = '';
                    this.beingAdded = false;
                }, (err) => {
                    this.error.emit(err);
                    this.beingAdded = false;
                });
            }
            if (this.isANode()) {
                this.commentContentService.addNodeComment(this.nodeId, this.message)
                    .subscribe((res) => {
                    this.comments.unshift(res);
                    this.message = '';
                    this.beingAdded = false;
                }, (err) => {
                    this.error.emit(err);
                    this.beingAdded = false;
                });
            }
        }
    }
    clear() {
        this.message = '';
    }
    isReadOnly() {
        return this.readOnly;
    }
    isATask() {
        return this.taskId ? true : false;
    }
    isANode() {
        return this.nodeId ? true : false;
    }
}
CommentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comments',
                template: `<div class="adf-comments-container">
    <div id="comment-header" class="adf-comments-header">
        {{'COMMENTS.HEADER' | translate: { count: comments?.length} }}
    </div>
    <div class="adf-comments-input-container" *ngIf="!isReadOnly()">
            <mat-form-field class="adf-full-width">
                <input matInput id="comment-input" placeholder="{{'COMMENTS.ADD' | translate}}" [(ngModel)]="message" (keyup.enter)="add()" (keyup.esc)="clear()">
            </mat-form-field>
    </div>

    <div *ngIf="comments.length > 0">
        <adf-comment-list [comments]="comments">
        </adf-comment-list>
    </div>
</div>
`,
                styles: [``]
            },] },
];
CommentsComponent.ctorParameters = () => [
    { type: CommentProcessService, },
    { type: CommentContentService, },
];
CommentsComponent.propDecorators = {
    "taskId": [{ type: Input },],
    "nodeId": [{ type: Input },],
    "readOnly": [{ type: Input },],
    "error": [{ type: Output },],
};

class CommentsModule {
}
CommentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    DataColumnModule,
                    DataTableModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    CommentListComponent,
                    CommentsComponent
                ],
                exports: [
                    CommentListComponent,
                    CommentsComponent
                ]
            },] },
];
CommentsModule.ctorParameters = () => [];

class AuthGuard {
    constructor(authService, router, appConfig) {
        this.authService = authService;
        this.router = router;
        this.appConfig = appConfig;
    }
    canActivate(route, state$$1) {
        const                  redirectUrl = state$$1.url;
        return this.checkLogin(redirectUrl);
    }
    canActivateChild(route, state$$1) {
        return this.canActivate(route, state$$1);
    }
    checkLogin(redirectUrl) {
        if (this.authService.isLoggedIn()) {
            return true;
        }
        this.authService.setRedirectUrl({ provider: 'ALL', url: redirectUrl });
        const                  pathToLogin = this.getRouteDestinationForLogin();
        this.router.navigate(['/' + pathToLogin]);
        return false;
    }
    getRouteDestinationForLogin() {
        return this.appConfig &&
            this.appConfig.get('loginRoute') ?
            this.appConfig.get('loginRoute') : 'login';
    }
}
AuthGuard.decorators = [
    { type: Injectable },
];
AuthGuard.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: Router, },
    { type: AppConfigService, },
];

class AuthGuardEcm {
    constructor(authService, apiService, router, appConfig) {
        this.authService = authService;
        this.apiService = apiService;
        this.router = router;
        this.appConfig = appConfig;
    }
    get authApi() {
        return this.apiService.getInstance().ecmAuth;
    }
    isLoggedIn() {
        if (!this.authApi.isLoggedIn()) {
            return Promise.resolve(false);
        }
        return this.authApi
            .validateTicket()
            .then(() => true, () => false)
            .catch(() => false);
    }
    canActivateChild(route, state$$1) {
        return this.canActivate(route, state$$1);
    }
    canActivate(route, state$$1) {
        return this.isLoggedIn().then(isLoggedIn => {
            if (!isLoggedIn) {
                this.authService.setRedirectUrl({ provider: 'ECM', url: state$$1.url });
                const                  pathToLogin = this.getRouteDestinationForLogin();
                this.router.navigate(['/' + pathToLogin]);
            }
            return isLoggedIn;
        });
    }
    getRouteDestinationForLogin() {
        return this.appConfig &&
            this.appConfig.get('loginRoute') ?
            this.appConfig.get('loginRoute') : 'login';
    }
}
AuthGuardEcm.decorators = [
    { type: Injectable },
];
AuthGuardEcm.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: AlfrescoApiService, },
    { type: Router, },
    { type: AppConfigService, },
];

class AuthGuardBpm {
    constructor(authService, router, appConfig) {
        this.authService = authService;
        this.router = router;
        this.appConfig = appConfig;
    }
    canActivate(route, state$$1) {
        return this.checkLogin(state$$1.url);
    }
    canActivateChild(route, state$$1) {
        return this.canActivate(route, state$$1);
    }
    checkLogin(redirectUrl) {
        if (this.authService.isBpmLoggedIn()) {
            return true;
        }
        this.authService.setRedirectUrl({ provider: 'BPM', url: redirectUrl });
        const                  pathToLogin = this.getRouteDestinationForLogin();
        this.router.navigate(['/' + pathToLogin]);
        return false;
    }
    getRouteDestinationForLogin() {
        return this.appConfig &&
            this.appConfig.get('loginRoute') ?
            this.appConfig.get('loginRoute') : 'login';
    }
}
AuthGuardBpm.decorators = [
    { type: Injectable },
];
AuthGuardBpm.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: Router, },
    { type: AppConfigService, },
];

class AppsProcessService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    getDeployedApplications() {
        return Observable.fromPromise(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .map((response) => {
            return response.data;
        })
            .catch(err => this.handleError(err));
    }
    getDeployedApplicationsByName(name) {
        return Observable.fromPromise(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .map((response) => {
            return response.data.find(app => app.name === name);
        })
            .catch(err => this.handleError(err));
    }
    getApplicationDetailsById(appId) {
        return Observable.fromPromise(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .map((response) => {
            return response.data.find(app => app.id === appId);
        })
            .catch(err => this.handleError(err));
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
AppsProcessService.decorators = [
    { type: Injectable },
];
AppsProcessService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

class PageTitleService {
    constructor(titleService, appConfig) {
        this.titleService = titleService;
        this.appConfig = appConfig;
    }
    setTitle(value = '') {
        const                  name = this.appConfig.get('application.name') || 'Alfresco ADF Application';
        const                  title = value ? `${value} - ${name}` : `${name}`;
        this.titleService.setTitle(title);
    }
}
PageTitleService.decorators = [
    { type: Injectable },
];
PageTitleService.ctorParameters = () => [
    { type: Title, },
    { type: AppConfigService, },
];

class RenditionsService {
    constructor(apiService) {
        this.apiService = apiService;
    }
    isRenditionAvailable(nodeId, encoding) {
        return Observable.create((observer) => {
            this.getRendition(nodeId, encoding).subscribe((res) => {
                let                  isAvailable = true;
                if (res.entry.status.toString() === 'NOT_CREATED') {
                    isAvailable = false;
                }
                observer.next(isAvailable);
                observer.complete();
            }, () => {
                observer.next(false);
                observer.complete();
            });
        });
    }
    isConversionPossible(nodeId, encoding) {
        return Observable.create((observer) => {
            this.getRendition(nodeId, encoding).subscribe(() => {
                observer.next(true);
                observer.complete();
            }, () => {
                observer.next(false);
                observer.complete();
            });
        });
    }
    getRenditionUrl(nodeId, encoding) {
        return this.apiService.contentApi.getRenditionUrl(nodeId, encoding);
    }
    getRendition(nodeId, encoding) {
        return Observable.fromPromise(this.apiService.renditionsApi.getRendition(nodeId, encoding));
    }
    getRenditionsListByNodeId(nodeId) {
        return Observable.fromPromise(this.apiService.renditionsApi.getRenditions(nodeId));
    }
    createRendition(nodeId, encoding) {
        return Observable.fromPromise(this.apiService.renditionsApi.createRendition(nodeId, { id: encoding }));
    }
    convert(nodeId, encoding, pollingInterval = 1000, retries = 5) {
        return this.createRendition(nodeId, encoding)
            .concatMap(() => this.pollRendition(nodeId, encoding, pollingInterval, retries));
    }
    pollRendition(nodeId, encoding, interval = 1000, retries = 5) {
        let                  attempts = 0;
        return Observable.interval(interval)
            .switchMap(() => this.getRendition(nodeId, encoding))
            .takeWhile((data) => {
            attempts += 1;
            if (attempts > retries) {
                return false;
            }
            return (data.entry.status.toString() !== 'CREATED');
        });
    }
}
RenditionsService.decorators = [
    { type: Injectable },
];
RenditionsService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class ComponentTranslationModel {
    constructor(obj) {
        this.name = obj && obj.name;
        this.path = obj && obj.path;
        this.json = obj && obj.json || [];
    }
}

class TranslateLoaderService {
    constructor(http, logService) {
        this.http = http;
        this.logService = logService;
        this.prefix = 'i18n';
        this.suffix = '.json';
        this.providers = [];
        this.queue = [];
    }
    registerProvider(name, path) {
        let                  registered = this.providers.find(provider => provider.name === name);
        if (registered) {
            registered.path = path;
        }
        else {
            this.providers.push(new ComponentTranslationModel({ name: name, path: path }));
        }
    }
    providerRegistered(name) {
        return this.providers.find(x => x.name === name) ? true : false;
    }
    getComponentToFetch(lang) {
        let                  observableBatch = [];
        if (!this.queue[lang]) {
            this.queue[lang] = [];
        }
        this.providers.forEach((component) => {
            if (!this.isComponentInQueue(lang, component.name)) {
                this.queue[lang].push(component.name);
                const                  loader = Observable.create(observer => {
                    const                  translationUrl = `${component.path}/${this.prefix}/${lang}${this.suffix}?v=${Date.now()}`;
                    this.http.get(translationUrl).pipe(map((res) => {
                        component.json[lang] = res;
                    })).subscribe((result) => {
                        observer.next(result);
                        observer.complete();
                    }, () => {
                        observer.next('');
                        observer.complete();
                    });
                });
                observableBatch.push(loader);
            }
        });
        return observableBatch;
    }
    init(lang) {
        if (this.queue[lang] === undefined) {
            this.queue[lang] = [];
        }
    }
    isComponentInQueue(lang, name) {
        return (this.queue[lang] || []).find(x => x === name) ? true : false;
    }
    getFullTranslationJSON(lang) {
        let                  result = {};
        this.providers
            .slice(0)
            .sort((a, b) => {
            if (a.name === 'app') {
                return 1;
            }
            if (b.name === 'app') {
                return -1;
            }
            return a.name.localeCompare(b.name);
        })
            .forEach(model => {
            if (model.json && model.json[lang]) {
                result = ObjectUtils.merge(result, model.json[lang]);
            }
        });
        return result;
    }
    getTranslation(lang) {
        let                  observableBatch = this.getComponentToFetch(lang);
        return Observable.create(observer => {
            if (observableBatch.length > 0) {
                Observable.forkJoin(observableBatch).subscribe(() => {
                    let                  fullTranslation = this.getFullTranslationJSON(lang);
                    if (fullTranslation) {
                        observer.next(fullTranslation);
                    }
                    observer.complete();
                }, (err) => {
                    this.logService.error(err);
                });
            }
            else {
                let                  fullTranslation = this.getFullTranslationJSON(lang);
                if (fullTranslation) {
                    observer.next(fullTranslation);
                }
            }
        });
    }
}
TranslateLoaderService.decorators = [
    { type: Injectable },
];
TranslateLoaderService.ctorParameters = () => [
    { type: HttpClient, },
    { type: LogService, },
];

let minimatch = minimatch___default || minimatch_;
class UploadService {
    constructor(apiService, appConfigService) {
        this.apiService = apiService;
        this.queue = [];
        this.cache = {};
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
        this.activeTask = null;
        this.excludedFileList = [];
        this.queueChanged = new Subject();
        this.fileUpload = new Subject();
        this.fileUploadStarting = new Subject();
        this.fileUploadCancelled = new Subject();
        this.fileUploadProgress = new Subject();
        this.fileUploadAborted = new Subject();
        this.fileUploadError = new Subject();
        this.fileUploadComplete = new Subject();
        this.fileUploadDeleted = new Subject();
        this.fileDeleted = new Subject();
        this.excludedFileList =                  (appConfigService.get('files.excluded'));
    }
    isUploading() {
        return this.activeTask ? true : false;
    }
    getQueue() {
        return this.queue;
    }
    addToQueue(...files) {
        const                  allowedFiles = files.filter(f => this.filterElement(f));
        this.queue = this.queue.concat(allowedFiles);
        this.queueChanged.next(this.queue);
        return allowedFiles;
    }
    filterElement(file) {
        let                  isAllowed = true;
        if (this.excludedFileList) {
            isAllowed = this.excludedFileList.filter(expr => minimatch(file.name, expr)).length === 0;
        }
        return isAllowed;
    }
    uploadFilesInTheQueue(emitter) {
        if (!this.activeTask) {
            let                  file = this.queue.find(f => f.status === FileUploadStatus.Pending);
            if (file) {
                this.onUploadStarting(file);
                const                  promise = this.beginUpload(file, emitter);
                this.activeTask = promise;
                this.cache[file.id] = promise;
                let                  next = () => {
                    this.activeTask = null;
                    setTimeout(() => this.uploadFilesInTheQueue(emitter), 100);
                };
                promise.next = next;
                promise.then(() => next(), () => next());
            }
        }
    }
    cancelUpload(...files) {
        files.forEach(file => {
            const                  promise = this.cache[file.id];
            if (promise) {
                promise.abort();
                delete this.cache[file.id];
            }
            else {
                const                  performAction = this.getAction(file);
                performAction();
            }
        });
    }
    clearQueue() {
        this.queue = [];
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
    }
    getUploadPromise(file) {
        let                  opts = {
            renditions: 'doclib'
        };
        if (file.options.newVersion === true) {
            opts.overwrite = true;
            opts.majorVersion = true;
        }
        else {
            opts.autoRename = true;
        }
        if (file.options.newVersionBaseName) {
            opts.name = file.options.newVersionBaseName;
        }
        return this.apiService.getInstance().upload.uploadFile(file.file, file.options.path, file.options.parentId, null, opts);
    }
    beginUpload(file,                                     emitter) {
        let                  promise = this.getUploadPromise(file);
        promise.on('progress', (progress) => {
            this.onUploadProgress(file, progress);
        })
            .on('abort', () => {
            this.onUploadAborted(file);
            emitter.emit({ value: 'File aborted' });
        })
            .on('error', err => {
            this.onUploadError(file, err);
            emitter.emit({ value: 'Error file uploaded' });
        })
            .on('success', data => {
            this.onUploadComplete(file, data);
            emitter.emit({ value: data });
        })
            .catch(err => {
            throw err;
        });
        return promise;
    }
    onUploadStarting(file) {
        if (file) {
            file.status = FileUploadStatus.Starting;
            const                  event = new FileUploadEvent(file, FileUploadStatus.Starting);
            this.fileUpload.next(event);
            this.fileUploadStarting.next(event);
        }
    }
    onUploadProgress(file, progress) {
        if (file) {
            file.progress = progress;
            file.status = FileUploadStatus.Progress;
            const                  event = new FileUploadEvent(file, FileUploadStatus.Progress);
            this.fileUpload.next(event);
            this.fileUploadProgress.next(event);
        }
    }
    onUploadError(file, error) {
        if (file) {
            file.status = FileUploadStatus.Error;
            this.totalError++;
            const                  promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            const                  event = new FileUploadErrorEvent(file, error, this.totalError);
            this.fileUpload.next(event);
            this.fileUploadError.next(event);
        }
    }
    onUploadComplete(file, data) {
        if (file) {
            file.status = FileUploadStatus.Complete;
            file.data = data;
            this.totalComplete++;
            const                  promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            const                  event = new FileUploadCompleteEvent(file, this.totalComplete, data, this.totalAborted);
            this.fileUpload.next(event);
            this.fileUploadComplete.next(event);
        }
    }
    onUploadAborted(file) {
        if (file) {
            file.status = FileUploadStatus.Aborted;
            this.totalAborted++;
            const                  promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            const                  event = new FileUploadEvent(file, FileUploadStatus.Aborted);
            this.fileUpload.next(event);
            this.fileUploadAborted.next(event);
            promise.next();
        }
    }
    onUploadCancelled(file) {
        if (file) {
            file.status = FileUploadStatus.Cancelled;
            const                  event = new FileUploadEvent(file, FileUploadStatus.Cancelled);
            this.fileUpload.next(event);
            this.fileUploadCancelled.next(event);
        }
    }
    onUploadDeleted(file) {
        if (file) {
            file.status = FileUploadStatus.Deleted;
            this.totalComplete--;
            const                  event = new FileUploadDeleteEvent(file, this.totalComplete);
            this.fileUpload.next(event);
            this.fileUploadDeleted.next(event);
        }
    }
    getAction(file) {
        const                  actions = {
            [FileUploadStatus.Pending]: () => this.onUploadCancelled(file),
            [FileUploadStatus.Deleted]: () => this.onUploadDeleted(file),
            [FileUploadStatus.Error]: () => this.onUploadError(file, null)
        };
        return actions[file.status];
    }
}
UploadService.decorators = [
    { type: Injectable },
];
UploadService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: AppConfigService, },
];

class DeletedNodesApiService {
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    get nodesApi() {
        return this.apiService.getInstance().core.nodesApi;
    }
    getDeletedNodes(options) {
        const { nodesApi, handleError } = this;
        const                  defaultOptions = {
            include: ['path', 'properties'],
            maxItems: this.preferences.paginationSize,
            skipCount: 0
        };
        const                  queryOptions = Object.assign(defaultOptions, options);
        const                  promise = nodesApi.getDeletedNodes(queryOptions);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    handleError(error) {
        return Observable.of(error);
    }
}
DeletedNodesApiService.decorators = [
    { type: Injectable },
];
DeletedNodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

class FavoritesApiService {
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    static remapEntry({ entry }) {
        entry.properties = {
            'cm:title': entry.title,
            'cm:description': entry.description
        };
        return { entry };
    }
    remapFavoritesData(data = {}) {
        const                  list = (data.list || {});
        const                  pagination = (list.pagination || {});
        const                  entries = this
            .remapFavoriteEntries(list.entries || []);
        return                  ({
            list: { entries, pagination }
        });
    }
    remapFavoriteEntries(entries) {
        return entries
            .map(({ entry: { target } }) => ({
            entry: target.file || target.folder
        }))
            .filter(({ entry }) => (!!entry))
            .map(FavoritesApiService.remapEntry);
    }
    get favoritesApi() {
        return this.apiService.getInstance().core.favoritesApi;
    }
    getFavorites(personId, options) {
        const { favoritesApi, handleError } = this;
        const                  defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: ['properties', 'allowableOperations']
        };
        const                  queryOptions = Object.assign(defaultOptions, options);
        const                  promise = favoritesApi
            .getFavorites(personId, queryOptions)
            .then(this.remapFavoritesData);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    handleError(error) {
        return Observable.of(error);
    }
}
FavoritesApiService.decorators = [
    { type: Injectable },
];
FavoritesApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

class NodesApiService {
    constructor(api, preferences) {
        this.api = api;
        this.preferences = preferences;
    }
    get nodesApi() {
        return this.api.getInstance().core.nodesApi;
    }
    getEntryFromEntity(entity) {
        return entity.entry;
    }
    getNode(nodeId, options = {}) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const                  defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        const                  queryOptions = Object.assign(defaults, options);
        const                  promise = nodesApi
            .getNode(nodeId, queryOptions)
            .then(getEntryFromEntity);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    getNodeChildren(nodeId, options = {}) {
        const { nodesApi, handleError } = this;
        const                  defaults = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        const                  queryOptions = Object.assign(defaults, options);
        const                  promise = nodesApi
            .getNodeChildren(nodeId, queryOptions);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    createNode(parentNodeId, nodeBody, options = {}) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const                  promise = nodesApi
            .addNode(parentNodeId, nodeBody, options)
            .then(getEntryFromEntity);
        return Observable.fromPromise(promise).catch(handleError);
    }
    createFolder(parentNodeId, nodeBody, options = {}) {
        const                  body = Object.assign({ nodeType: 'cm:folder' }, nodeBody);
        return this.createNode(parentNodeId, body, options);
    }
    updateNode(nodeId, nodeBody, options = {}) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const                  promise = nodesApi
            .updateNode(nodeId, nodeBody, options)
            .then(getEntryFromEntity);
        return Observable.fromPromise(promise).catch(handleError);
    }
    deleteNode(nodeId, options = {}) {
        const { nodesApi, handleError } = this;
        const                  promise = nodesApi
            .deleteNode(nodeId, options);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    restoreNode(nodeId) {
        const { nodesApi, handleError, getEntryFromEntity } = this;
        const                  promise = nodesApi
            .restoreNode(nodeId)
            .then(getEntryFromEntity);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    handleError(error) {
        return Observable.throw(error);
    }
}
NodesApiService.decorators = [
    { type: Injectable },
];
NodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

class PeopleContentService {
    constructor(apiService) {
        this.apiService = apiService;
    }
    get peopleApi() {
        return this.apiService.getInstance().core.peopleApi;
    }
    getPerson(personId) {
        const { peopleApi, handleError } = this;
        const                  promise = peopleApi.getPerson(personId);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    getCurrentPerson() {
        return this.getPerson('-me-');
    }
    handleError(error) {
        return Observable.of(error);
    }
}
PeopleContentService.decorators = [
    { type: Injectable },
];
PeopleContentService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class SearchConfigurationService {
    constructor() {
    }
    generateQueryBody(searchTerm, maxResults, skipCount) {
        let                  defaultQueryBody = {
            query: {
                query: searchTerm ? `${searchTerm}* OR name:${searchTerm}*` : searchTerm
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxResults,
                skipCount: skipCount
            },
            filterQueries: [
                { query: "TYPE:'cm:folder' OR TYPE:'cm:content'" },
                { query: 'NOT cm:creator:System' }
            ]
        };
        return defaultQueryBody;
    }
}
SearchConfigurationService.decorators = [
    { type: Injectable },
];
SearchConfigurationService.ctorParameters = () => [];

class SearchService {
    constructor(apiService, searchConfigurationService) {
        this.apiService = apiService;
        this.searchConfigurationService = searchConfigurationService;
        this.dataLoaded = new Subject();
    }
    getNodeQueryResults(term, options) {
        const                  promise = this.apiService.getInstance().core.queriesApi.findNodes(term, options);
        promise.then((data) => {
            this.dataLoaded.next(data);
        });
        return Observable
            .fromPromise(promise)
            .catch(err => this.handleError(err));
    }
    search(searchTerm, maxResults, skipCount) {
        const                  searchQuery = Object.assign(this.searchConfigurationService.generateQueryBody(searchTerm, maxResults, skipCount));
        const                  promise = this.apiService.getInstance().search.searchApi.search(searchQuery);
        promise.then((data) => {
            this.dataLoaded.next(data);
        });
        return Observable
            .fromPromise(promise)
            .catch(err => this.handleError(err));
    }
    searchByQueryBody(queryBody) {
        const                  promise = this.apiService.getInstance().search.searchApi.search(queryBody);
        promise.then((data) => {
            this.dataLoaded.next(data);
        });
        return Observable
            .fromPromise(promise)
            .catch(err => this.handleError(err));
    }
    handleError(error) {
        return Observable.throw(error || 'Server error');
    }
}
SearchService.decorators = [
    { type: Injectable },
];
SearchService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: SearchConfigurationService, },
];

class SharedLinksApiService {
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    get sharedLinksApi() {
        return this.apiService.getInstance().core.sharedlinksApi;
    }
    getSharedLinks(options = {}) {
        const { sharedLinksApi, handleError } = this;
        const                  defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['properties', 'allowableOperations']
        };
        const                  queryOptions = Object.assign({}, defaultOptions, options);
        const                  promise = sharedLinksApi
            .findSharedLinks(queryOptions);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    createSharedLinks(nodeId, options = {}) {
        const { sharedLinksApi, handleError } = this;
        const                  promise = sharedLinksApi.addSharedLink({ nodeId: nodeId });
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    deleteSharedLink(sharedId) {
        const { sharedLinksApi, handleError } = this;
        const                  promise = sharedLinksApi.deleteSharedLink(sharedId);
        return Observable
            .fromPromise(promise)
            .catch(handleError);
    }
    handleError(error) {
        return Observable.of(error);
    }
}
SharedLinksApiService.decorators = [
    { type: Injectable },
];
SharedLinksApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];

class SitesService {
    constructor(apiService) {
        this.apiService = apiService;
    }
    getSites(opts = {}) {
        const                  defaultOptions = {
            skipCount: 0,
            include: ['properties']
        };
        const                  queryOptions = Object.assign({}, defaultOptions, opts);
        return Observable.fromPromise(this.apiService.getInstance().core.sitesApi.getSites(queryOptions))
            .catch(this.handleError);
    }
    getSite(siteId, opts) {
        return Observable.fromPromise(this.apiService.getInstance().core.sitesApi.getSite(siteId, opts))
            .catch(this.handleError);
    }
    deleteSite(siteId, permanentFlag = true) {
        let                  options = {};
        options.permanent = permanentFlag;
        return Observable.fromPromise(this.apiService.getInstance().core.sitesApi.deleteSite(siteId, options)
            .catch(this.handleError));
    }
    getSiteContent(siteId) {
        return this.getSite(siteId, { relations: ['containers'] });
    }
    getSiteMembers(siteId) {
        return this.getSite(siteId, { relations: ['members'] });
    }
    getEcmCurrentLoggedUserName() {
        return this.apiService.getInstance().ecmAuth.username;
    }
    handleError(error) {
        console.error(error);
        return Observable.throw(error || 'Server error');
    }
}
SitesService.decorators = [
    { type: Injectable },
];
SitesService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class BpmProductVersionModel {
    constructor(obj) {
        if (obj) {
            this.edition = obj.edition || null;
            this.majorVersion = obj.majorVersion || null;
            this.revisionVersion = obj.revisionVersion || null;
            this.minorVersion = obj.minorVersion || null;
            this.type = obj.type || null;
        }
    }
}
class VersionModel {
    constructor(obj) {
        if (obj) {
            this.major = obj.major || null;
            this.minor = obj.minor || null;
            this.patch = obj.patch || null;
            this.hotfix = obj.hotfix || null;
            this.schema = obj.schema || null;
            this.label = obj.label || null;
            this.display = obj.display || null;
        }
    }
}
class LicenseModel {
    constructor(obj) {
        if (obj) {
            this.issuedAt = obj.issuedAt || null;
            this.expiresAt = obj.expiresAt || null;
            this.remainingDays = obj.remainingDays || null;
            this.holder = obj.holder || null;
            this.mode = obj.mode || null;
            this.isClusterEnabled = obj.isClusterEnabled ? true : false;
            this.isCryptodocEnabled = obj.isCryptodocEnabled ? true : false;
        }
    }
}
class VersionStatusModel {
    constructor(obj) {
        if (obj) {
            this.isReadOnly = obj.isReadOnly ? true : false;
            this.isAuditEnabled = obj.isAuditEnabled ? true : false;
            this.isQuickShareEnabled = obj.isQuickShareEnabled ? true : false;
            this.isThumbnailGenerationEnabled = obj.isThumbnailGenerationEnabled ? true : false;
        }
    }
}
class VersionModuleModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.title = obj.title || null;
            this.description = obj.description || null;
            this.version = obj.version || null;
            this.installDate = obj.installDate || null;
            this.installState = obj.installState || null;
            this.versionMin = obj.versionMin || null;
            this.versionMax = obj.versionMax || null;
        }
    }
}
class EcmProductVersionModel {
    constructor(obj) {
        this.modules = [];
        if (obj && obj.entry && obj.entry.repository) {
            this.edition = obj.entry.repository.edition || null;
            this.version = new VersionModel(obj.entry.repository.version);
            this.license = new LicenseModel(obj.entry.repository.license);
            this.status = new VersionStatusModel(obj.entry.repository.status);
            if (obj.entry.repository.modules) {
                obj.entry.repository.modules.forEach((module) => {
                    this.modules.push(new VersionModuleModel(module));
                });
            }
        }
    }
}

class DiscoveryApiService {
    constructor(apiService) {
        this.apiService = apiService;
    }
    getEcmProductInfo() {
        return Observable.fromPromise(this.apiService.getInstance().discovery.discoveryApi.getRepositoryInformation())
            .map(res => new EcmProductVersionModel(res))
            .catch(this.handleError);
    }
    getBpmProductInfo() {
        return Observable.fromPromise(this.apiService.getInstance().activiti.aboutApi.getAppVersion())
            .map(res => new BpmProductVersionModel(res))
            .catch(this.handleError);
    }
    handleError(error) {
        return Observable.throw(error);
    }
}
DiscoveryApiService.decorators = [
    { type: Injectable },
];
DiscoveryApiService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class EcmCompanyModel {
}

class RedirectionModel {
    constructor(obj) {
        if (obj) {
            this.provider = obj.provider;
            this.url = obj.url || null;
        }
    }
}

class CommentProcessModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id;
            this.message = obj.message;
            this.created = obj.created;
            this.createdBy = obj.createdBy;
            this.isSelected = obj.isSelected ? obj.isSelected : false;
        }
    }
}

class AlfrescoApiMock {
    login(username, password) {
        return new Promise((resolve) => {
            resolve('TICKET_4479f4d3bb155195879bfbb8d5206f433488a1b1');
        });
    }
    logout() {
        return new Promise((resolve) => {
            resolve('logout');
        });
    }
    changeConfig() {
    }
}

class AppConfigServiceMock extends AppConfigService {
    constructor(http) {
        super(http);
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent'
        };
    }
    load() {
        return new Promise(resolve => {
            resolve(this.config);
        });
    }
}
AppConfigServiceMock.decorators = [
    { type: Injectable },
];
AppConfigServiceMock.ctorParameters = () => [
    { type: HttpClient, },
];

let fakeApps = {
    size: 2, total: 2, start: 0,
    data: [
        {
            id: 1, defaultAppId: null, name: 'Sales-Fakes-App', description: 'desc-fake1', modelId: 22,
            theme: 'theme-1-fake', icon: 'glyphicon-asterisk', 'deploymentId': '111', 'tenantId': null
        },
        {
            id: 2, defaultAppId: null, name: 'health-care-Fake', description: 'desc-fake2', modelId: 33,
            theme: 'theme-2-fake', icon: 'glyphicon-asterisk', 'deploymentId': '444', 'tenantId': null
        }
    ]
};

class AuthenticationMock {
    constructor() {
        this.redirectUrl = '';
    }
    setRedirectUrl(url) {
        this.redirectUrl = url;
    }
    getRedirectUrl() {
        return this.redirectUrl;
    }
    login(username, password) {
        if (username === 'fake-username' && password === 'fake-password') {
            return Observable.of({ type: 'type', ticket: 'ticket' });
        }
        if (username === 'fake-username-CORS-error' && password === 'fake-password') {
            return Observable.throw({
                error: {
                    crossDomain: true,
                    message: 'ERROR: the network is offline, Origin is not allowed by Access-Control-Allow-Origin'
                }
            });
        }
        if (username === 'fake-username-CSRF-error' && password === 'fake-password') {
            return Observable.throw({ message: 'ERROR: Invalid CSRF-token', status: 403 });
        }
        if (username === 'fake-username-ECM-access-error' && password === 'fake-password') {
            return Observable.throw({ message: 'ERROR: 00170728 Access Denied.  The system is currently in read-only mode', status: 403 });
        }
        return Observable.throw('Fake server error');
    }
}

let fakeBpmUserNoImage = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    fullname: 'fake-full-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: undefined,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};
let fakeBpmUser = {
    apps: [],
    capabilities: null,
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-bpm-first-name',
    lastName: 'fake-bpm-last-name',
    fullname: 'fake-bpm-full-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 12,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};
let fakeBpmEditedUser = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    fullname: 'fake-full-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 'src/assets/images/bpmImg.gif',
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};

let fakeUser1 = { id: 1, email: 'fake-email@dom.com', firstName: 'firstName', lastName: 'lastName' };
let fakeUser2 = { id: 1001, email: 'some-one@somegroup.com', firstName: 'some', lastName: 'one' };
let fakeTasksComment = {
    size: 2, total: 2, start: 0,
    data: [
        {
            id: 1, message: 'fake-message-1', created: '', createdBy: fakeUser1
        },
        {
            id: 2, message: 'fake-message-2', created: '', createdBy: fakeUser1
        }
    ]
};
let fakeProcessComment = new CommentModel({ id: 1, message: 'Test', created: new Date('2016-11-10T03:37:30.010+0000'), createdBy: new UserProcessModel({
        id: 13,
        firstName: 'Wilbur',
        lastName: 'Adams',
        email: 'wilbur@app.com'
    }) });

class CookieServiceMock extends CookieService {
    getItem(key) {
        return this[key] && this[key].data || null;
    }
    setItem(key, data, expiration, path) {
        this[key] = { data, expiration, path };
    }
}

let fakeEcmCompany = {
    organization: 'company-fake-name',
    address1: 'fake-address-1',
    address2: 'fake-address-2',
    address3: 'fake-address-3',
    postcode: 'fAk1',
    telephone: '00000000',
    fax: '11111111',
    email: 'fakeCompany@fake.com'
};
let fakeEcmUser = {
    id: 'fake-id',
    firstName: 'fake-ecm-first-name',
    lastName: 'fake-ecm-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'job-ecm-test',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
let fakeEcmUserNoImage = {
    id: 'fake-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: null,
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: null,
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
let fakeEcmEditedUser = {
    id: 'fake-id',
    firstName: null,
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'test job',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};

class EventMock {
    static keyDown(key) {
        let                  event = document.createEvent('Event');
        event.keyCode = key;
        event.initEvent('keydown');
        document.dispatchEvent(event);
    }
    static keyUp(key) {
        let                  event = document.createEvent('Event');
        event.keyCode = key;
        event.initEvent('keyup');
        document.dispatchEvent(event);
    }
    static resizeMobileView() {
        window.dispatchEvent(new Event('resize'));
    }
}

let fakeRedition = {
    'entry': {
        'id': 'pdf',
        'content': { 'mimeType': 'application/pdf', 'mimeTypeName': 'Adobe PDF Document' },
        'status': 'NOT_CREATED'
    }
};
let fakeReditionCreated = {
    'entry': {
        'id': 'pdf',
        'content': { 'mimeType': 'application/pdf', 'mimeTypeName': 'Adobe PDF Document' },
        'status': 'CREATED'
    }
};
let fakeReditionsList = {
    'list': {
        'pagination': {
            'count': 6,
            'hasMoreItems': false,
            'totalItems': 6,
            'skipCount': 0,
            'maxItems': 100
        },
        'entries': [{
                'entry': {
                    'id': 'avatar',
                    'content': { 'mimeType': 'image/png', 'mimeTypeName': 'PNG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'avatar32',
                    'content': { 'mimeType': 'image/png', 'mimeTypeName': 'PNG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'doclib',
                    'content': { 'mimeType': 'image/png', 'mimeTypeName': 'PNG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'imgpreview',
                    'content': { 'mimeType': 'image/jpeg', 'mimeTypeName': 'JPEG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'medium',
                    'content': { 'mimeType': 'image/jpeg', 'mimeTypeName': 'JPEG Image' },
                    'status': 'NOT_CREATED'
                }
            }, {
                'entry': {
                    'id': 'pdf',
                    'content': { 'mimeType': 'application/pdf', 'mimeTypeName': 'Adobe PDF Document' },
                    'status': 'NOT_CREATED'
                }
            }]
    }
};

let fakeSearch = {
    list: {
        pagination: {
            count: 1,
            hasMoreItems: false,
            totalItems: 1,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: '123',
                    name: 'MyDoc',
                    content: {
                        mimetype: 'text/plain'
                    },
                    createdByUser: {
                        displayName: 'John Doe'
                    },
                    modifiedByUser: {
                        displayName: 'John Doe'
                    }
                }
            }
        ]
    }
};
let mockError = {
    error: {
        errorKey: 'Search failed',
        statusCode: 400,
        briefSummary: '08220082 search failed',
        stackTrace: 'For security reasons the stack trace is no longer displayed, but the property is kept for previous versions.',
        descriptionURL: 'https://api-explorer.alfresco.com'
    }
};
let searchMockApi = {
    core: {
        queriesApi: {
            findNodes: (term, opts) => Promise.resolve(fakeSearch)
        }
    }
};

class TranslationMock {
    constructor() {
        this.defaultLang = 'en';
        this.onLangChange = new EventEmitter();
    }
    addTranslationFolder() {
    }
    onTranslationChanged() {
    }
    use() {
    }
    get(key, interpolateParams) {
        return Observable.of(key);
    }
    instant(key, interpolateParams) {
        return key;
    }
}

class AlfrescoApiServiceMock extends AlfrescoApiService {
    constructor(appConfig, storage) {
        super(appConfig, storage);
        this.appConfig = appConfig;
        this.storage = storage;
        this.initAlfrescoApi();
    }
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initAlfrescoApi();
        });
    }
    initAlfrescoApi() {
        this.alfrescoApi =                  (new alfrescoApi({
            provider: this.storage.getItem('AUTH_TYPE'),
            ticketEcm: this.storage.getItem('ticket-ECM'),
            ticketBpm: this.storage.getItem('ticket-BPM'),
            hostEcm: this.appConfig.get('ecmHost'),
            hostBpm: this.appConfig.get('bpmHost'),
            contextRoot: 'alfresco',
            disableCsrf: this.storage.getItem('DISABLE_CSRF') === 'true',
            oauth2: this.appConfig.get('oauth2')
        }));
    }
}
AlfrescoApiServiceMock.decorators = [
    { type: Injectable },
];
AlfrescoApiServiceMock.ctorParameters = () => [
    { type: AppConfigService, },
    { type: StorageService, },
];

let fakeForm = {
    id: 1001,
    name: 'ISSUE_FORM',
    processDefinitionId: 'ISSUE_APP:1:2504',
    processDefinitionName: 'ISSUE_APP',
    processDefinitionKey: 'ISSUE_APP',
    taskId: '7506',
    taskDefinitionKey: 'sid-F67A2996-1684-4774-855A-4591490081FD',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212398417',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'label',
                        name: 'Label',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'test1'
                            },
                            {
                                id: 'option_2',
                                name: 'test2'
                            },
                            {
                                id: 'option_3',
                                name: 'test3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'raduio',
                        name: 'raduio',
                        type: 'radio-buttons',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: [
                            {
                                id: 'option_1',
                                name: 'Option 1'
                            },
                            {
                                id: 'option_2',
                                name: 'Option 2'
                            },
                            {
                                id: 'option_3',
                                name: 'Option 3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 2,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212413062',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

let formDefinitionTwoTextFields = {
    id: 20,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:1:153',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '159',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
let formDefinitionDropdownField = {
    id: 21,
    name: 'dropdownDefinition',
    processDefinitionId: 'textDefinition:2:163',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '169',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507046026940',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'united kingdom'
                            },
                            {
                                id: 'option_2',
                                name: 'italy'
                            },
                            {
                                id: 'option_3',
                                name: 'france'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

let formReadonlyTwoTextFields = {
    id: 22,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:3:182',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '188',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'readonly',
                        value: 'fakeFirstName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2,
                            field: {
                                id: 'firstname',
                                name: 'firstName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'readonly',
                        value: 'fakeLastName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1,
                            field: {
                                id: 'lastname',
                                name: 'lastName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

let formDefVisibilitiFieldDependsOnNextOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftFormFieldId: 'name',
                            leftRestResponseId: null,
                            operator: '==',
                            rightValue: 'italy',
                            rightType: null,
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
let formDefVisibilitiFieldDependsOnPreviousOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftFormFieldId: 'name',
                            leftRestResponseId: null,
                            operator: '==',
                            rightValue: 'italy',
                            rightType: null,
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

let startFormDateWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null
                    }]
            }
        }
    ]
};
let startFormNumberWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'number',
                        name: 'number widget',
                        type: 'integer',
                        value: null
                    }]
            }
        }
    ]
};
let startFormAmountWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'amount',
                        name: 'amount widget',
                        type: 'amount',
                        value: null
                    }]
            }
        }
    ]
};
let startFormRadioButtonWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'radio-but',
                        name: 'radio-buttons',
                        type: 'radio-buttons',
                        value: null
                    }]
            }
        }
    ]
};
let startFormTextDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'mocktext',
                        name: 'mockText',
                        type: 'text',
                        value: null
                    }]
            }
        }
    ]
};
let startFormDropdownDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'mockTypeDropDown',
                        name: 'mock DropDown',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'opt1',
                                name: 'Option-1'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-2'
                            },
                            {
                                id: 'opt3',
                                name: 'Option-3'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-3'
                            }
                        ]
                    }]
            }
        }
    ]
};
let startMockForm = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billamount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalname',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        },
        {
            id: 'start_process',
            name: 'Start Process'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};
let startMockFormWithTab = {
    id: 4,
    taskName: 'Mock Title',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [
        {
            id: 'form1',
            name: 'Tab 1'
        },
        {
            id: 'form2',
            name: 'Tab 2'
        }
    ],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billamount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalname',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};

let formModelTabs = {
    id: 16,
    name: 'start event',
    description: '',
    version: 2,
    lastUpdatedBy: 4,
    lastUpdatedByFullName: 'User Test',
    lastUpdated: '2017-10-04T13:00:03.030+0000',
    stencilSetId: null,
    referenceId: null,
    formDefinition: {
        tabs: [],
        fields: [
            {
                fieldType: 'ContainerRepresentation',
                id: '1507037668653',
                name: 'Label',
                type: 'container',
                value: null,
                required: false,
                readOnly: false,
                overrideId: false,
                colspan: 1,
                placeholder: null,
                minLength: 0,
                maxLength: 0,
                minValue: null,
                maxValue: null,
                regexPattern: null,
                optionType: null,
                hasEmptyValue: null,
                options: null,
                restUrl: null,
                restResponsePath: null,
                restIdProperty: null,
                restLabelProperty: null,
                tab: null,
                className: null,
                dateDisplayFormat: null,
                layout: null,
                sizeX: 2,
                sizeY: 1,
                row: -1,
                col: -1,
                visibilityCondition: null,
                numberOfColumns: 2,
                fields: {
                    '1': [
                        {
                            fieldType: 'AmountFieldRepresentation',
                            id: 'label',
                            name: 'Label',
                            type: 'amount',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 2
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null,
                            enableFractions: false,
                            currency: null
                        }
                    ],
                    '2': [
                        {
                            fieldType: 'FormFieldRepresentation',
                            id: 'label1',
                            name: 'Label1',
                            type: 'date',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 1
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null
                        }
                    ]
                }
            },
            {
                fieldType: 'ContainerRepresentation',
                id: '1507037670167',
                name: 'Label',
                type: 'container',
                value: null,
                required: false,
                readOnly: false,
                overrideId: false,
                colspan: 1,
                placeholder: null,
                minLength: 0,
                maxLength: 0,
                minValue: null,
                maxValue: null,
                regexPattern: null,
                optionType: null,
                hasEmptyValue: null,
                options: null,
                restUrl: null,
                restResponsePath: null,
                restIdProperty: null,
                restLabelProperty: null,
                tab: null,
                className: null,
                dateDisplayFormat: null,
                layout: null,
                sizeX: 2,
                sizeY: 1,
                row: -1,
                col: -1,
                visibilityCondition: null,
                numberOfColumns: 2,
                fields: {
                    '1': [
                        {
                            fieldType: 'FormFieldRepresentation',
                            id: 'label2',
                            name: 'Label2',
                            type: 'boolean',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 2
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null
                        }
                    ],
                    '2': []
                }
            }
        ],
        outcomes: [],
        javascriptEvents: [],
        className: '',
        style: '',
        customFieldTemplates: {},
        metadata: {},
        variables: [],
        customFieldsValueInfo: {},
        gridsterForm: false
    }
};

let formTest = new FormModel({});
let fakeTaskProcessVariableModels = [
    { id: 'TEST_VAR_1', type: 'string', value: 'test_value_1' },
    { id: 'TEST_VAR_2', type: 'string', value: 'test_value_2' },
    { id: 'TEST_VAR_3', type: 'string', value: 'test_value_3' }
];
let formValues = {
    'test_1': 'value_1',
    'test_2': 'value_2',
    'test_3': 'value_1',
    'test_4': 'dropdown_id',
    'test_5': 'dropdown_label',
    'dropdown': { 'id': 'dropdown_id', 'name': 'dropdown_label' }
};
let fakeFormJson = {
    id: '9999',
    name: 'FORM_VISIBILITY',
    processDefinitionId: 'PROCESS_TEST:9:9999',
    processDefinitionName: 'PROCESS_TEST',
    processDefinitionKey: 'PROCESS_TEST',
    taskId: '999',
    taskName: 'TEST',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '000000000000000000',
            name: 'Label',
            type: 'container',
            value: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_TEST',
                        name: 'FIELD_TEST',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_WITH_CONDITION',
                        name: 'FIELD_WITH_CONDITION',
                        type: 'text',
                        value: 'field_with_condition_value',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'LEFT_FORM_FIELD_ID',
                        name: 'LEFT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'LEFT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'RIGHT_FORM_FIELD_ID',
                        name: 'RIGHT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ]
            }
        }
    ]
};

function declarations$1() {
    return [
        SidebarActionMenuComponent,
        SidebarMenuDirective,
        SidebarMenuExpandIconDirective,
        SidebarMenuTitleIconDirective
    ];
}
class SideBarActionModule {
}
SideBarActionModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule
                ],
                declarations: declarations$1(),
                exports: declarations$1()
            },] },
];
SideBarActionModule.ctorParameters = () => [];

function startupServiceFactory(alfrescoApiService) {
    return () => alfrescoApiService.load();
}

function createTranslateLoader(http, logService) {
    return new TranslateLoaderService(http, logService);
}
function providers() {
    return [
        AuthenticationService,
        AlfrescoApiService,
        SettingsService,
        ContentService,
        AuthGuard,
        AuthGuardEcm,
        AuthGuardBpm,
        AppsProcessService,
        PageTitleService,
        StorageService,
        CookieService,
        RenditionsService,
        NotificationService,
        LogService,
        TranslationService,
        TranslateLoaderService,
        ThumbnailService,
        UploadService,
        CardItemTypeService,
        CardViewUpdateService,
        UserPreferencesService,
        HighlightTransformService,
        DeletedNodesApiService,
        FavoritesApiService,
        NodesApiService,
        PeopleContentService,
        PeopleProcessService,
        SearchService,
        SharedLinksApiService,
        SitesService,
        DiscoveryApiService,
        CommentProcessService,
        CommentContentService,
        SearchConfigurationService,
        DatePipe
    ];
}
const ɵ0$4 = (createTranslateLoader);
class CoreModuleLazy {
}
CoreModuleLazy.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ViewerModule,
                    SidenavLayoutModule,
                    SideBarActionModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    CollapsableModule,
                    FormModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    TranslateModule.forChild({
                        loader: {
                            provide: TranslateLoader,
                            useFactory: ɵ0$4,
                            deps: [HttpClient, LogService]
                        }
                    })
                ],
                exports: [
                    ViewerModule,
                    SideBarActionModule,
                    SidenavLayoutModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    CollapsableModule,
                    FormModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    TranslateModule
                ]
            },] },
];
CoreModuleLazy.ctorParameters = () => [];
const ɵ1$2 = (createTranslateLoader);
const ɵ2 = startupServiceFactory;
class CoreModule {
    constructor(translation) {
        translation.addTranslationFolder('adf-core', 'assets/adf-core');
    }
    static forRoot() {
        return {
            ngModule: CoreModule,
            providers: [
                ...providers(),
                {
                    provide: APP_INITIALIZER,
                    useFactory: startupServiceFactory,
                    deps: [
                        AlfrescoApiService
                    ],
                    multi: true
                }
            ]
        };
    }
    static forChild() {
        return {
            ngModule: CoreModuleLazy
        };
    }
}
CoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ViewerModule,
                    SideBarActionModule,
                    SidenavLayoutModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    CollapsableModule,
                    FormModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    TranslateModule.forRoot({
                        loader: {
                            provide: TranslateLoader,
                            useFactory: ɵ1$2,
                            deps: [HttpClient, LogService]
                        }
                    })
                ],
                exports: [
                    ViewerModule,
                    SideBarActionModule,
                    SidenavLayoutModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    CollapsableModule,
                    FormModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    TranslateModule
                ],
                providers: [
                    ...providers(),
                    {
                        provide: APP_INITIALIZER,
                        useFactory: ɵ2,
                        deps: [
                            AlfrescoApiService
                        ],
                        multi: true
                    }
                ]
            },] },
];
CoreModule.ctorParameters = () => [
    { type: TranslationService, },
];

export { ViewerComponent, ImgViewerComponent, MediaPlayerComponent, PdfViewerComponent, PdfThumbListComponent, PdfThumbComponent, TxtViewerComponent, UnknownFormatComponent, ViewerMoreActionsComponent, ViewerOpenWithComponent, ViewerSidebarComponent, ViewerToolbarComponent, ViewerToolbarActionsComponent, ViewerExtensionDirective, ViewerModule, UserInfoComponent, BpmUserService, EcmUserService, UserInfoModule, ToolbarDividerComponent, ToolbarTitleComponent, ToolbarComponent, ToolbarModule, HostSettingsComponent, HostSettingsModule, PaginationComponent, InfinitePaginationComponent, PaginationModule, LoginHeaderDirective, LoginFooterDirective, LoginComponent, LoginErrorEvent, LoginSubmitEvent, LoginSuccessEvent, LoginModule, LanguageMenuComponent, LanguageMenuModule, InfoDrawerLayoutComponent, InfoDrawerTitleDirective, InfoDrawerButtonsDirective, InfoDrawerContentDirective, InfoDrawerTabComponent, InfoDrawerComponent, declarations, InfoDrawerModule, SidebarActionMenuComponent, SidebarMenuDirective, SidebarMenuTitleIconDirective, SidebarMenuExpandIconDirective, DataColumnListComponent, DataColumnComponent, DataColumnModule, DataRowEvent, DataSorting, ObjectDataRow, ObjectDataTableAdapter, ObjectDataColumn, DataCellEventModel, DataCellEvent, DataRowActionModel, DataRowActionEvent, DataTableCellComponent, DisplayMode, DataTableComponent, DateCellComponent, EmptyListComponent, EmptyListHeaderDirective, EmptyListBodyDirective, EmptyListFooterDirective, FileSizeCellComponent, LocationCellComponent, LoadingContentTemplateDirective, NoContentTemplateDirective, NoPermissionTemplateDirective, DataTableModule, ContextMenuHolderComponent, ContextMenuDirective, ContextMenuService, ContextMenuModule, AccordionGroupComponent, AccordionComponent, CollapsableModule, CardViewComponent, CardViewBoolItemComponent, CardViewDateItemComponent, CardViewMapItemComponent, CardViewTextItemComponent, CardViewItemIntValidator, CardViewItemFloatValidator, CardViewBaseItemModel, CardViewBoolItemModel, CardViewDateItemModel, CardViewDatetimeItemModel, CardViewFloatItemModel, CardViewIntItemModel, CardViewMapItemModel, CardViewTextItemModel, CardItemTypeService, transformKeyToObject, CardViewUpdateService, CardViewContentProxyDirective, CardViewModule, AppConfigService, AppConfigModule, FormComponent, FormListComponent, ContentWidgetComponent, StartFormComponent, WIDGET_DIRECTIVES, MASK_DIRECTIVE, baseHost, WidgetComponent, FormFieldTypes, FormWidgetModel, FormFieldModel, FormModel, ContainerModel, ContainerColumnModel, TabModel, FormOutcomeModel, FormOutcomeEvent, RequiredFieldValidator, NumberFieldValidator, DateFieldValidator, MinDateFieldValidator, MaxDateFieldValidator, MinDateTimeFieldValidator, MaxDateTimeFieldValidator, MinLengthFieldValidator, MaxLengthFieldValidator, MinValueFieldValidator, MaxValueFieldValidator, RegExFieldValidator, FixedValueFieldValidator, FORM_FIELD_VALIDATORS, ContentLinkModel, ErrorMessageModel, TabsWidgetComponent, ContainerWidgetComponent, UnknownWidgetComponent, TextWidgetComponent, NumberWidgetComponent, CheckboxWidgetComponent, MultilineTextWidgetComponentComponent, DropdownWidgetComponent, HyperlinkWidgetComponent, RadioButtonsWidgetComponent, DisplayTextWidgetComponentComponent, UploadWidgetComponent, TypeaheadWidgetComponent, FunctionalGroupWidgetComponent, PeopleWidgetComponent, DateWidgetComponent, AmountWidgetComponent, DynamicTableWidgetComponent, ErrorWidgetComponent, DocumentWidgetComponent, DateTimeWidgetComponent, DynamicTableModel, RowEditorComponent, DateEditorComponent, DropdownEditorComponent, BooleanEditorComponent, TextEditorComponent, CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR, InputMaskDirective, FormService, EcmModelService, NodeService, FormRenderingService, ProcessContentService, ActivitiContentService, FormEvent, FormErrorEvent, FormFieldEvent, ValidateFormFieldEvent, ValidateFormEvent, ValidateDynamicTableRowEvent, FormModule, SidenavLayoutComponent, SidenavLayoutModule, CommentListComponent, CommentsComponent, CommentsModule, FileSizePipe, MimeTypeIconPipe, NodeNameTooltipPipe, HighlightPipe, TimeAgoPipe, InitialUsernamePipe, PipeModule, AuthenticationService, AlfrescoApiService, SettingsService, ContentService, AuthGuard, AuthGuardEcm, AuthGuardBpm, AppsProcessService, PageTitleService, StorageService, CookieService, RenditionsService, NotificationService, LogService, TRANSLATION_PROVIDER, TranslationService, TranslateLoaderService, ThumbnailService, UploadService, DynamicComponentResolver, DynamicComponentMapper, UserPreferenceValues, UserPreferencesService, HighlightTransformService, DeletedNodesApiService, FavoritesApiService, NodesApiService, PeopleContentService, PeopleProcessService, SearchService, SharedLinksApiService, SitesService, DiscoveryApiService, CommentProcessService, SearchConfigurationService, CommentContentService, HighlightDirective, LogoutDirective, NodeDeleteDirective, NodeFavoriteDirective, NodePermissionDirective, NodeRestoreDirective, UploadDirective, DirectiveModule, ObjectUtils, FileUtils, MOMENT_DATE_FORMATS, MomentDateAdapter, EXTENDIBLE_COMPONENT, FileUploadStatus, FileModel, PermissionsEnum, BpmProductVersionModel, VersionModel, LicenseModel, VersionStatusModel, VersionModuleModel, EcmProductVersionModel, UserProcessModel, CommentModel, EcmCompanyModel, RedirectionModel, CommentProcessModel, PaginationModel, BaseEvent, BaseUIEvent, FileUploadEvent, FileUploadCompleteEvent, FileUploadDeleteEvent, FileUploadErrorEvent, AlfrescoApiMock, AppConfigServiceMock, fakeApps, AuthenticationMock, fakeBpmUserNoImage, fakeBpmUser, fakeBpmEditedUser, fakeUser1, fakeUser2, fakeTasksComment, fakeProcessComment, CookieServiceMock, fakeEcmCompany, fakeEcmUser, fakeEcmUserNoImage, fakeEcmEditedUser, EventMock, fakeRedition, fakeReditionCreated, fakeReditionsList, fakeSearch, mockError, searchMockApi, TranslationMock, AlfrescoApiServiceMock, fakeForm, formDefinitionTwoTextFields, formDefinitionDropdownField, formReadonlyTwoTextFields, formDefVisibilitiFieldDependsOnNextOne, formDefVisibilitiFieldDependsOnPreviousOne, startFormDateWidgetMock, startFormNumberWidgetMock, startFormAmountWidgetMock, startFormRadioButtonWidgetMock, startFormTextDefinitionMock, startFormDropdownDefinitionMock, startMockForm, startMockFormWithTab, formModelTabs, formTest, fakeTaskProcessVariableModels, formValues, fakeFormJson, createTranslateLoader, providers, CoreModuleLazy, CoreModule, CardViewItemDispatcherComponent as ɵa, BaseEvent as ɵg, BaseUIEvent as ɵf, StartFormCustomButtonDirective as ɵk, FormFieldComponent as ɵj, DynamicRowValidationSummary as ɵi, WidgetVisibilityService as ɵh, MaterialModule as ɵd, modules as ɵc, getType as ɵr, startupServiceFactory as ɵu, SideBarActionModule as ɵt, declarations$1 as ɵs, LayoutContainerComponent as ɵo, SidenavLayoutContentDirective as ɵn, SidenavLayoutHeaderDirective as ɵl, SidenavLayoutNavigationDirective as ɵm, contentAnimation as ɵq, sidenavAnimation as ɵp, PdfPasswordDialogComponent as ɵe, RenderingQueueServices as ɵb };
//# sourceMappingURL=adf-core.js.map
