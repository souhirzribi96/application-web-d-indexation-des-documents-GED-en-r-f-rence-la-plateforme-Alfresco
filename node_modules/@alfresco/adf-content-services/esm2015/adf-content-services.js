/**
 * @license
 * Copyright 2018 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Component, Inject, ViewEncapsulation, Directive, Input, HostListener, ElementRef, NgModule, Injectable, Optional, EventEmitter, Output, Renderer2, ContentChild, NgZone, ViewChild, TemplateRef, ChangeDetectorRef, forwardRef, ViewChildren, ViewContainerRef, Compiler, ChangeDetectionStrategy } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogRef, MatDialog, MatButtonModule, MatChipsModule, MatDialogModule, MatIconModule, MatCardModule, MatInputModule, MatListModule, MatMenuModule, MatOptionModule, MatProgressBarModule, MatProgressSpinnerModule, MatRippleModule, MatExpansionModule, MatSelectModule, MatCheckboxModule, MatDatepickerModule, MatSlideToggleModule, MatListItem, MatRadioModule } from '@angular/material';
import { LogService, AlfrescoApiService, SharedLinksApiService, AuthenticationService, ContentService, ThumbnailService, SitesService, TranslationService, PermissionsEnum, ObjectDataTableAdapter, DataTableModule, PipeModule, ObjectUtils, DataSorting, TimeAgoPipe, BaseEvent, DisplayMode, ObjectDataColumn, AppConfigService, DataColumnListComponent, UserPreferencesService, FileUploadStatus, NodesApiService, UploadService, FileModel, EXTENDIBLE_COMPONENT, FileUtils, NotificationService, PaginationModule, ToolbarModule, SearchService, HighlightDirective, DirectiveModule, DataColumnModule, FormModule, CardViewDateItemModel, CardViewTextItemModel, FileSizePipe, CardViewBoolItemModel, CardViewDatetimeItemModel, CardViewIntItemModel, CardViewFloatItemModel, CardViewUpdateService, CardViewModule, CoreModule, TRANSLATION_PROVIDER } from '@alfresco/adf-core';
import 'alfresco-js-api';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/throw';
import moment from 'moment-es6';
import { FormBuilder, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR, FormControl, Validators } from '@angular/forms';
import { Subject } from 'rxjs/Subject';
import 'rxjs/operator/switchMap';
import { CommonModule, DatePipe } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/observable/merge';
import { FlexLayoutModule } from '@angular/flex-layout';
import { __awaiter } from 'tslib';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { debounceTime } from 'rxjs/operators';
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { DOCUMENT } from '@angular/platform-browser';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { merge } from 'rxjs/observable/merge';
import { MatDatetimepickerModule } from '@mat-datetimepicker/core';
import { MatMomentDatetimeModule } from '@mat-datetimepicker/moment';
import { forkJoin } from 'rxjs/observable/forkJoin';
import { defer } from 'rxjs/observable/defer';
import 'rxjs/add/operator/switchMap';

class DownloadZipDialogComponent {
    constructor(apiService, dialogRef, data, logService) {
        this.apiService = apiService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.logService = logService;
        this.cancelled = false;
    }
    ngOnInit() {
        if (this.data && this.data.nodeIds && this.data.nodeIds.length > 0) {
            if (!this.cancelled) {
                this.downloadZip(this.data.nodeIds);
            }
            else {
                this.logService.log('Cancelled');
            }
        }
    }
    cancelDownload() {
        this.cancelled = true;
        this.dialogRef.close(false);
    }
    downloadZip(nodeIds) {
        if (nodeIds && nodeIds.length > 0) {
            const                  promise = this.apiService.getInstance().core.downloadsApi.createDownload({ nodeIds });
            promise.on('progress', progress => this.logService.log('Progress', progress));
            promise.on('error', error => this.logService.error('Error', error));
            promise.on('abort', data => this.logService.log('Abort', data));
            promise.on('success', (data) => {
                if (data && data.entry && data.entry.id) {
                    const                  url = this.apiService.getInstance().content.getContentUrl(data.entry.id, true);
                    this.apiService.getInstance().core.nodesApi.getNode(data.entry.id).then((downloadNode) => {
                        this.logService.log(downloadNode);
                        const                  fileName = downloadNode.entry.name;
                        this.waitAndDownload(data.entry.id, url, fileName);
                    });
                }
            });
        }
    }
    waitAndDownload(downloadId, url, fileName) {
        if (this.cancelled) {
            return;
        }
        this.apiService.getInstance().core.downloadsApi.getDownload(downloadId).then((downloadEntry) => {
            if (downloadEntry.entry) {
                if (downloadEntry.entry.status === 'DONE') {
                    this.download(url, fileName);
                }
                else {
                    setTimeout(() => {
                        this.waitAndDownload(downloadId, url, fileName);
                    }, 1000);
                }
            }
        });
    }
    download(url, fileName) {
        if (url && fileName) {
            const                  link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        this.dialogRef.close(true);
    }
}
DownloadZipDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-download-zip-dialog',
                template: `<h1 matDialogTitle>{{ 'CORE.DIALOG.DOWNLOAD_ZIP.TITLE' | translate }}</h1>
<div mat-dialog-content>
    <mat-progress-bar color="primary" mode="indeterminate"></mat-progress-bar>
</div>
<div mat-dialog-actions>
    <span class="spacer"></span>
    <button mat-button color="primary" (click)="cancelDownload()">
        {{ 'CORE.DIALOG.DOWNLOAD_ZIP.ACTIONS.CANCEL' | translate }}
    </button>
</div>
`,
                styles: [`.spacer{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-download-zip-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}`],
                host: { 'class': 'adf-download-zip-dialog' },
                encapsulation: ViewEncapsulation.None
            },] },
];
DownloadZipDialogComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: MatDialogRef, },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] },] },
    { type: LogService, },
];

class NodeDownloadDirective {
    constructor(apiService, dialog) {
        this.apiService = apiService;
        this.dialog = dialog;
    }
    onClick() {
        this.downloadNodes(this.nodes);
    }
    downloadNodes(selection) {
        if (!selection || selection.length === 0) {
            return;
        }
        if (selection.length === 1) {
            this.downloadNode(selection[0]);
        }
        else {
            this.downloadZip(selection);
        }
    }
    downloadNode(node) {
        if (node && node.entry) {
            const                  entry = node.entry;
            if (entry.isFile) {
                this.downloadFile(node);
            }
            if (entry.isFolder) {
                this.downloadZip([node]);
            }
            if (!entry.isFile && !entry.isFolder && (                 (entry)).nodeId) {
                this.downloadFile(node);
            }
        }
    }
    downloadFile(node) {
        if (node && node.entry) {
            const                  contentApi = this.apiService.getInstance().content;
            const                  url = contentApi.getContentUrl(node.entry.id, true);
            const                  fileName = node.entry.name;
            this.download(url, fileName);
        }
    }
    downloadZip(selection) {
        if (selection && selection.length > 0) {
            const                  nodeIds = selection.map((node) => (node.entry.nodeId || node.entry.id));
            this.dialog.open(DownloadZipDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    nodeIds
                }
            });
        }
    }
    download(url, fileName) {
        if (url && fileName) {
            const                  link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
NodeDownloadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adfNodeDownload]'
            },] },
];
NodeDownloadDirective.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: MatDialog, },
];
NodeDownloadDirective.propDecorators = {
    "nodes": [{ type: Input, args: ['adfNodeDownload',] },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};

class ShareDialogComponent {
    constructor(sharedLinksApiService, dialogRef, data) {
        this.sharedLinksApiService = sharedLinksApiService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.isFileShared = false;
        this.isDisabled = false;
    }
    ngOnInit() {
        if (this.data.node && this.data.node.entry) {
            this.fileName = this.data.node.entry.name;
            this.baseShareUrl = this.data.baseShareUrl;
            if (this.data.node.entry.properties && this.data.node.entry.properties['qshare:sharedId']) {
                this.sharedId = this.data.node.entry.properties['qshare:sharedId'];
                this.isFileShared = true;
            }
            else {
                this.createSharedLinks(this.data.node.entry.id);
            }
        }
    }
    cancelShare() {
        this.dialogRef.close(false);
    }
    onSlideShareChange(event) {
        this.isDisabled = true;
        if (event.checked) {
            this.createSharedLinks(this.data.node.entry.id);
        }
        else {
            this.deleteSharedLink(this.sharedId);
        }
    }
    createSharedLinks(nodeId) {
        this.sharedLinksApiService.createSharedLinks(nodeId).subscribe((sharedLink) => {
            if (sharedLink.entry) {
                this.sharedId = sharedLink.entry.id;
                this.isFileShared = true;
                this.isDisabled = false;
            }
        }, () => {
            this.isFileShared = false;
            this.isDisabled = false;
        });
    }
    deleteSharedLink(sharedId) {
        this.sharedLinksApiService.deleteSharedLink(sharedId).subscribe(() => {
            this.isFileShared = false;
            this.isDisabled = false;
        }, () => {
            this.isFileShared = true;
            this.isDisabled = false;
        });
    }
}
ShareDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-share-dialog',
                template: `<h1 mat-dialog-title id="adf-share-title" >{{ 'SHARE.TITLE' | translate }} {{fileName}}</h1>

<mat-dialog-content>
    <span class="spacer"></span>

    <mat-slide-toggle [checked]="isFileShared" [disabled]="isDisabled" (change)="onSlideShareChange($event)">
        {{ 'SHARE.ACTIONS.SHARE' | translate }}
    </mat-slide-toggle>

    <span class="spacer"></span>

    .

    <h2 *ngIf="isFileShared">{{ 'SHARE.DESCRIPTION' | translate }}</h2>
    <div *ngIf="isFileShared">{{ 'SHARE.ALERT' | translate }}</div>

    <form *ngIf="isFileShared">
        <mat-form-field class="full-width">
            <input class="adf-share-link" matInput placeholder="{{ 'SHARE.PUBLIC-LINK' | translate }}" [value]="baseShareUrl + sharedId">
            <mat-icon matPrefix>link</mat-icon>
        </mat-form-field>
    </form>

    <h2 *ngIf="!isFileShared">{{ 'SHARE.UNSHARED' | translate }}</h2>

</mat-dialog-content>

<mat-dialog-actions>
    <button mat-button color="primary" (click)="cancelShare()">
        {{ 'SHARE.ACTIONS.CLOSE' | translate }}
    </button>
</mat-dialog-actions>
`,
                styles: [`.spacer{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-share-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}.full-width{width:100%}.adf-share-link{margin-left:10px;font-size:18px!important}`],
                host: { 'class': 'adf-share-dialog' },
                encapsulation: ViewEncapsulation.None
            },] },
];
ShareDialogComponent.ctorParameters = () => [
    { type: SharedLinksApiService, },
    { type: MatDialogRef, },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] },] },
];

class NodeSharedDirective {
    constructor(dialog, elementRef) {
        this.dialog = dialog;
        this.elementRef = elementRef;
    }
    onClick() {
        this.shareNode(this.node);
    }
    shareNode(node) {
        if (node.entry && node.entry.isFile) {
            this.setDisableAttribute(true);
            this.dialog.open(ShareDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    node: node,
                    baseShareUrl: this.baseShareUrl
                }
            });
        }
        else {
            this.setDisableAttribute(true);
        }
    }
    ngOnChanges() {
        if (!this.node || this.node.entry.isFolder) {
            this.setDisableAttribute(true);
        }
        else {
            this.setDisableAttribute(false);
        }
    }
    setDisableAttribute(disable) {
        this.elementRef.nativeElement.disabled = disable;
    }
}
NodeSharedDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-share]'
            },] },
];
NodeSharedDirective.ctorParameters = () => [
    { type: MatDialog, },
    { type: ElementRef, },
];
NodeSharedDirective.propDecorators = {
    "node": [{ type: Input, args: ['adf-share',] },],
    "baseShareUrl": [{ type: Input },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};

function modules() {
    return [
        MatButtonModule,
        MatChipsModule,
        MatDialogModule,
        MatIconModule,
        MatCardModule,
        MatInputModule,
        MatListModule,
        MatProgressSpinnerModule,
        MatProgressBarModule,
        MatRippleModule,
        MatMenuModule,
        MatOptionModule,
        MatExpansionModule,
        MatSelectModule,
        MatCheckboxModule,
        MatDatepickerModule,
        MatSlideToggleModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] },
];
MaterialModule.ctorParameters = () => [];

class DocumentListService {
    constructor(authService, contentService, apiService, logService, thumbnailService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
    }
    getNodesPromise(folder, opts, includeFields = []) {
        let                  rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        let                  includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        let                  params = {
            includeSource: true,
            include: includeFieldsRequest
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
        }
        return this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params);
    }
    deleteNode(nodeId) {
        return Observable.fromPromise(this.apiService.getInstance().nodes.deleteNode(nodeId));
    }
    copyNode(nodeId, targetParentId) {
        return Observable.fromPromise(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId }))
            .catch(err => this.handleError(err));
    }
    moveNode(nodeId, targetParentId) {
        return Observable.fromPromise(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId }))
            .catch(err => this.handleError(err));
    }
    createFolder(name, parentId) {
        let                  observable = Observable.fromPromise(this.apiService.getInstance().nodes.createFolder(name, '/', parentId));
        observable.catch(err => this.handleError(err));
        return observable;
    }
    getFolder(folder, opts, includeFields = []) {
        return Observable.fromPromise(this.getNodesPromise(folder, opts, includeFields))
            .map(res =>                  (res))
            .catch(err => this.handleError(err));
    }
    getNode(nodeId, includeFields = []) {
        let                  includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        let                  opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return this.contentService.getNode(nodeId, opts);
    }
    getFolderNode(nodeId, includeFields = []) {
        let                  includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        let                  opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return Observable.fromPromise(this.apiService.getInstance().nodes.getNodeInfo(nodeId, opts));
    }
    getDocumentThumbnailUrl(node) {
        return this.thumbnailService.getDocumentThumbnailUrl(node);
    }
    getMimeTypeIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    getDefaultMimeTypeIcon() {
        return this.thumbnailService.getDefaultMimeTypeIcon();
    }
    hasPermission(node, permission) {
        return this.contentService.hasPermission(node, permission);
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
DocumentListService.ROOT_ID = '-root-';
DocumentListService.decorators = [
    { type: Injectable },
];
DocumentListService.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: ContentService, },
    { type: AlfrescoApiService, },
    { type: LogService, },
    { type: ThumbnailService, },
];

class ContentNodeSelectorComponent {
    constructor(data) {
        this.data = data;
        this.title = null;
        this.currentFolderId = null;
        this.dropdownHideMyFiles = false;
        this.dropdownSiteList = null;
        this.rowFilter = null;
        this.imageResolver = null;
        this.buttonActionName = data.actionName ? `NODE_SELECTOR.${data.actionName.toUpperCase()}` : 'NODE_SELECTOR.CHOOSE';
    }
    close() {
        this.data.select.complete();
    }
    onSelect(nodeList) {
        this.chosenNode = nodeList;
    }
    onClick() {
        this.data.select.next(this.chosenNode);
        this.data.select.complete();
    }
}
ContentNodeSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-node-selector',
                template: `<header
    mat-dialog-title
    data-automation-id="content-node-selector-title">{{title || data?.title}}
</header>

<mat-dialog-content>
    <adf-content-node-selector-panel
        [currentFolderId]="currentFolderId || data?.currentFolderId"
        [dropdownHideMyFiles]="dropdownHideMyFiles || data?.dropdownHideMyFiles"
        [dropdownSiteList]="dropdownSiteList || data?.dropdownSiteList"
        [rowFilter]="rowFilter || data?.rowFilter"
        [imageResolver]="imageResolver || data?.imageResolver"
        [isSelectionValid]="data?.isSelectionValid"
        [breadcrumbTransform]="data?.breadcrumbTransform"
        (select)="onSelect($event)">
    </adf-content-node-selector-panel>
</mat-dialog-content>

<mat-dialog-actions align="end">
    <button
        mat-button
        (click)="close()"
        data-automation-id="content-node-selector-actions-cancel">{{ 'NODE_SELECTOR.CANCEL' | translate }}
    </button>

    <button mat-button
        [disabled]="!chosenNode"
        class="choose-action"
        (click)="onClick()"
        data-automation-id="content-node-selector-actions-choose">{{ buttonActionName | translate }}
    </button>
</mat-dialog-actions>

`,
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
ContentNodeSelectorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] },] },
];
ContentNodeSelectorComponent.propDecorators = {
    "title": [{ type: Input },],
    "currentFolderId": [{ type: Input },],
    "dropdownHideMyFiles": [{ type: Input },],
    "dropdownSiteList": [{ type: Input },],
    "rowFilter": [{ type: Input },],
    "imageResolver": [{ type: Input },],
    "pageSize": [{ type: Input },],
};

class NodeLockDialogComponent {
    constructor(formBuilder, dialog, alfrescoApi, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.alfrescoApi = alfrescoApi;
        this.data = data;
        this.node = null;
    }
    ngOnInit() {
        const { node } = this.data;
        this.nodeName = node.name;
        this.form = this.formBuilder.group({
            isLocked: node.isLocked || false,
            allowOwner: node.properties['cm:lockType'] === 'WRITE_LOCK',
            isTimeLock: !!node.properties['cm:expiryDate'],
            time: !!node.properties['cm:expiryDate'] ? moment(node.properties['cm:expiryDate']) : moment()
        });
    }
    get lockTimeInSeconds() {
        if (this.form.value.isTimeLock) {
            let                  duration = moment.duration(moment(this.form.value.time).diff(moment()));
            return duration.asSeconds();
        }
        return 0;
    }
    get nodeBodyLock() {
        return {
            'timeToExpire': this.lockTimeInSeconds,
            'type': this.form.value.allowOwner ? 'ALLOW_OWNER_CHANGES' : 'FULL',
            'lifetime': 'PERSISTENT'
        };
    }
    toggleLock() {
        const { alfrescoApi: { nodesApi }, data: { node } } = this;
        if (this.form.value.isLocked) {
            return nodesApi.lockNode(node.id, this.nodeBodyLock);
        }
        return nodesApi.unlockNode(node.id);
    }
    submit() {
        this.toggleLock()
            .then(node => {
            this.data.node.isLocked = this.form.value.isLocked;
            this.dialog.close(node.entry);
        })
            .catch(error => this.data.onError(error));
    }
}
NodeLockDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-node-lock',
                styles: [`.adf-fill-remaining-space{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-full-width{width:100%}`],
                template: `<h2 mat-dialog-title>
    {{ 'CORE.FILE_DIALOG.FILE_LOCK' | translate }}
</h2>

<mat-dialog-content>
    <br />
    <form [formGroup]="form" (submit)="submit()">
        <mat-checkbox [formControl]="form.controls['isLocked']" ngDefaultControl>
            {{ 'CORE.FILE_DIALOG.FILE_LOCK_CHECKBOX' | translate }} <strong>"{{ nodeName }}"</strong>
        </mat-checkbox>

        <br />

        <div *ngIf="form.value.isLocked">
            <mat-checkbox [formControl]="form.controls['allowOwner']" ngDefaultControl>
                {{ 'CORE.FILE_DIALOG.ALLOW_OTHERS_CHECKBOX' | translate }}
            </mat-checkbox>

            <br />

            <mat-checkbox [formControl]="form.controls['isTimeLock']" ngDefaultControl>
                {{ 'CORE.FILE_DIALOG.TIME_LOCK_CHECKBOX' | translate }}
            </mat-checkbox>

            <br />

            <mat-form-field *ngIf="form.value.isTimeLock">
                <mat-datetimepicker-toggle [for]="datetimePicker" matSuffix></mat-datetimepicker-toggle>
                <mat-datetimepicker #datetimePicker type="datetime" openOnFocus="true" timeInterval="1"></mat-datetimepicker>
                <input matInput [formControl]="form.controls['time']" [matDatetimepicker]="datetimePicker" required autocomplete="false">
            </mat-form-field>
        </div>
    </form>
    <br />
</mat-dialog-content>

<mat-dialog-actions class="adf-dialog-buttons">
    <span class="adf-fill-remaining-space"></span>

    <button mat-button mat-dialog-close>
        {{ 'CORE.FILE_DIALOG.CANCEL_BUTTON.LABEL' | translate }}
    </button>

    <button class="adf-dialog-action-button" mat-button (click)="submit()">
        {{ 'CORE.FILE_DIALOG.SAVE_BUTTON.LABEL' | translate }}
    </button>
</mat-dialog-actions>
`
            },] },
];
NodeLockDialogComponent.ctorParameters = () => [
    { type: FormBuilder, },
    { type: MatDialogRef, },
    { type: AlfrescoApiService, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] },] },
];

class ContentNodeDialogService {
    constructor(dialog, contentService, documentListService, siteService, translation) {
        this.dialog = dialog;
        this.contentService = contentService;
        this.documentListService = documentListService;
        this.siteService = siteService;
        this.translation = translation;
        this.error = new EventEmitter();
    }
    openFileBrowseDialogByFolderId(folderNodeId) {
        return this.documentListService.getFolderNode(folderNodeId).switchMap((node) => {
            return this.openUploadFileDialog('Choose', node);
        });
    }
    openLockNodeDialog(contentEntry) {
        const                  observable = new Subject();
        if (this.contentService.hasPermission(contentEntry, PermissionsEnum.LOCK)) {
            this.dialog.open(NodeLockDialogComponent, {
                data: {
                    node: contentEntry,
                    onError: (error) => {
                        this.error.emit(error);
                        observable.error(error);
                    }
                },
                width: '400px'
            });
        }
        else {
            observable.error('OPERATION.FAIL.NODE.NO_PERMISSION');
        }
        return observable;
    }
    openFileBrowseDialogBySite() {
        return this.siteService.getSites().switchMap((response) => {
            return this.openFileBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        });
    }
    openFolderBrowseDialogBySite() {
        return this.siteService.getSites().switchMap((response) => {
            return this.openFolderBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        });
    }
    openFolderBrowseDialogByFolderId(folderNodeId) {
        return this.documentListService.getFolderNode(folderNodeId).switchMap((node) => {
            return this.openUploadFolderDialog('Choose', node);
        });
    }
    openCopyMoveDialog(action, contentEntry, permission) {
        if (this.contentService.hasPermission(contentEntry, permission)) {
            const                  select = new Subject();
            select.subscribe({
                complete: this.close.bind(this)
            });
            const                  title = this.getTitleTranslation(action, contentEntry.name);
            const                  data = {
                title: title,
                actionName: action,
                currentFolderId: contentEntry.parentId,
                imageResolver: this.imageResolver.bind(this),
                rowFilter: this.rowFilter.bind(this, contentEntry.id),
                isSelectionValid: this.isCopyMoveSelectionValid.bind(this),
                select: select
            };
            this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
            return select;
        }
        else {
            let                  errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            return Observable.throw(errors);
        }
    }
    getTitleTranslation(action, name) {
        return this.translation.instant(`NODE_SELECTOR.${action.toUpperCase()}_ITEM`, { name });
    }
    openUploadFolderDialog(action, contentEntry) {
        const                  select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        const                  data = {
            title: `${action} '${contentEntry.name}' to ...`,
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.hasPermissionOnNodeFolder.bind(this),
            rowFilter: this.rowFilter.bind(this, contentEntry.id),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    }
    openUploadFileDialog(action, contentEntry) {
        const                  select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        const                  data = {
            title: `${action} '${contentEntry.name}' to ...`,
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.isNodeFile.bind(this),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    }
    openContentNodeDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(ContentNodeSelectorComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    imageResolver(row, col) {
        const                  entry = row.node.entry;
        if (!this.contentService.hasPermission(entry, 'create')) {
            return this.documentListService.getMimeTypeIcon('disable/folder');
        }
        return null;
    }
    rowFilter(currentNodeId, row) {
        const                  node = row.node.entry;
        if (node.id === currentNodeId || node.isFile) {
            return false;
        }
        else {
            return true;
        }
    }
    isNodeFile(entry) {
        return entry.isFile;
    }
    hasPermissionOnNodeFolder(entry) {
        return this.isNodeFolder(entry) && this.contentService.hasPermission(entry, 'create');
    }
    isNodeFolder(entry) {
        return entry.isFolder;
    }
    isCopyMoveSelectionValid(entry) {
        return this.hasEntityCreatePermission(entry) && !this.isSite(entry);
    }
    hasEntityCreatePermission(entry) {
        return this.contentService.hasPermission(entry, 'create');
    }
    isSite(entry) {
        return !!entry.guid || entry.nodeType === 'st:site' || entry.nodeType === 'st:sites';
    }
    close() {
        this.dialog.closeAll();
    }
}
ContentNodeDialogService.decorators = [
    { type: Injectable },
];
ContentNodeDialogService.ctorParameters = () => [
    { type: MatDialog, },
    { type: ContentService, },
    { type: DocumentListService, },
    { type: SitesService, },
    { type: TranslationService, },
];
ContentNodeDialogService.propDecorators = {
    "error": [{ type: Output },],
};

class NodeLockDirective {
    constructor(element, renderer, contentService, contentNodeDialogService) {
        this.element = element;
        this.renderer = renderer;
        this.contentService = contentService;
        this.contentNodeDialogService = contentNodeDialogService;
    }
    onClick(event) {
        event.preventDefault();
        this.contentNodeDialogService.openLockNodeDialog(this.node);
    }
    ngAfterViewInit() {
        const                  hasPermission = this.contentService.hasPermission(this.node, PermissionsEnum.LOCK);
        this.renderer.setProperty(this.element.nativeElement, 'disabled', !hasPermission);
    }
}
NodeLockDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-lock]'
            },] },
];
NodeLockDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ContentService, },
    { type: ContentNodeDialogService, },
];
NodeLockDirective.propDecorators = {
    "node": [{ type: Input, args: ['adf-node-lock',] },],
    "onClick": [{ type: HostListener, args: ['click', ['$event'],] },],
};

class ContentDirectiveModule {
}
ContentDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    NodeDownloadDirective,
                    NodeSharedDirective,
                    NodeLockDirective
                ],
                exports: [
                    NodeDownloadDirective,
                    NodeSharedDirective,
                    NodeLockDirective
                ]
            },] },
];
ContentDirectiveModule.ctorParameters = () => [];

class RatingService {
    constructor(apiService) {
        this.apiService = apiService;
    }
    getRating(nodeId, ratingType) {
        return Observable.fromPromise(this.apiService.getInstance().core.ratingsApi.getRating(nodeId, ratingType))
            .map(res => res)
            .catch(this.handleError);
    }
    postRating(nodeId, ratingType, vote) {
        let                  ratingBody = {
            'id': ratingType,
            'myRating': vote
        };
        return Observable.fromPromise(this.apiService.getInstance().core.ratingsApi.rate(nodeId, ratingBody))
            .map(res => res)
            .catch(this.handleError);
    }
    deleteRating(nodeId, ratingType) {
        return Observable.fromPromise(this.apiService.getInstance().core.ratingsApi.removeRating(nodeId, ratingType))
            .map(res => res)
            .catch(this.handleError);
    }
    handleError(error) {
        console.error(error);
        return Observable.throw(error || 'Server error');
    }
}
RatingService.decorators = [
    { type: Injectable },
];
RatingService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class RatingComponent {
    constructor(ratingService) {
        this.ratingService = ratingService;
        this.average = 0;
        this.ratingType = 'fiveStar';
        this.changeVote = new EventEmitter();
        this.stars = [];
    }
    ngOnChanges() {
        let                  ratingObserver = this.ratingService.getRating(this.nodeId, this.ratingType);
        ratingObserver.subscribe((data) => {
            if (data.entry.aggregate) {
                this.average = data.entry.aggregate.average;
                this.calculateStars();
            }
        });
        return ratingObserver;
    }
    calculateStars() {
        this.stars = [];
        for (let                  i = 0; i < 5; i++) {
            if (i < this.average) {
                this.stars.push({ fill: true });
            }
            else {
                this.stars.push({ fill: false });
            }
        }
        this.changeVote.emit(this.average);
    }
    updateVote(vote) {
        this.ratingService.postRating(this.nodeId, this.ratingType, vote).subscribe((data) => {
            if (data.entry.aggregate) {
                if (this.average !== data.entry.aggregate.average) {
                    this.average = data.entry.aggregate.average;
                    this.calculateStars();
                }
            }
        });
    }
}
RatingComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-rating',
                styles: [`.adf-rating-container{overflow:hidden;width:100%}.adf-rating-container .adf-rating-star{float:left;-webkit-transition:all .3s;transition:all .3s;padding:1px;cursor:pointer}.adf-rating-container .adf-rating-star .mat-list-item-content{padding:0 2px!important}.adf-rating-container .adf-colored-star{color:#ffe944}.adf-rating-container .adf-grey-star{color:grey}.adf-rating-container .adf-stars-container{padding:0!important;margin:0!important;display:inline-block}.adf-rating-container .adf-rating-star:hover{-webkit-transform:rotate(13deg) scale(1.2);transform:rotate(13deg) scale(1.2)}`],
                template: `<mat-list id="adf-rating-container" class="adf-rating-container">
    <mat-list-item class="adf-rating-star" *ngFor="let currentRate of stars; let idx = index">
            <span id="adf-rate-{{idx}}">
                <mat-icon id="adf-grey-star-{{idx}}" *ngIf="currentRate.fill" class="adf-colored-star"
                         (click)="updateVote(idx + 1)">star_rate
                </mat-icon>
                <mat-icon id="adf-colored-star-{{idx}}" *ngIf="!currentRate.fill" class="adf-grey-star"
                         (click)="updateVote(idx + 1)">star_border
                </mat-icon>
            </span>
    </mat-list-item>
</mat-list>
`,
                encapsulation: ViewEncapsulation.None
            },] },
];
RatingComponent.ctorParameters = () => [
    { type: RatingService, },
];
RatingComponent.propDecorators = {
    "nodeId": [{ type: Input },],
    "changeVote": [{ type: Output },],
};

class LikeComponent {
    constructor(ratingService) {
        this.ratingService = ratingService;
        this.changeVote = new EventEmitter();
        this.likesCounter = 0;
        this.ratingType = 'likes';
        this.isLike = false;
    }
    ngOnChanges() {
        this.clean();
        this.ratingService.getRating(this.nodeId, this.ratingType).subscribe((data) => {
            if (data.entry.aggregate) {
                this.likesCounter = data.entry.aggregate.numberOfRatings;
                if (data.entry.ratedAt) {
                    this.isLike = true;
                }
            }
        });
    }
    likeClick() {
        if (this.isLike) {
            this.ratingService.deleteRating(this.nodeId, this.ratingType).subscribe(() => {
                this.likesCounter -= 1;
                this.isLike = false;
                this.changeVote.emit(this.likesCounter);
            });
        }
        else {
            this.ratingService.postRating(this.nodeId, this.ratingType, true).subscribe((data) => {
                this.likesCounter = data.entry.aggregate.numberOfRatings;
                this.isLike = true;
                this.changeVote.emit(this.likesCounter);
            });
        }
    }
    clean() {
        this.isLike = false;
        this.likesCounter = 0;
    }
}
LikeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-like',
                styles: [`.adf-like-container{overflow:hidden;width:100%}.adf-like-container .adf-like{padding:5px;cursor:pointer;float:left;margin:5px 0 5px 5px}.adf-like-container .adf-like-select{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-grey,.adf-like-container .adf-like-select:hover{cursor:pointer;color:grey}.adf-like-container .adf-like-grey:hover{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-counter{float:left;padding:13px 0 0}.adf-like-container .adf-left{float:left;padding:13px 0 0 4px}`],
                template: `<div id="adf-like-container" class="adf-like-container">
    <div class="adf-like">
        <span id="adf-like-{{nodeId}}" [ngClass]="{'adf-like-select': isLike ,'adf-like-grey': !isLike  }"
              (click)="likeClick()">
            <mat-icon>thumb_up</mat-icon>
        </span>
    </div>
    <div id="adf-like-counter" class="adf-like-counter">{{likesCounter}}</div>
    <div class="adf-left" *ngIf="likesCounter<=1">Like</div>
    <div class="adf-left" *ngIf="likesCounter>1">Likes</div>
</div>
`,
                encapsulation: ViewEncapsulation.None
            },] },
];
LikeComponent.ctorParameters = () => [
    { type: RatingService, },
];
LikeComponent.propDecorators = {
    "nodeId": [{ type: Input },],
    "changeVote": [{ type: Output },],
};

class SocialModule {
}
SocialModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                exports: [
                    RatingComponent,
                    LikeComponent
                ],
                declarations: [
                    RatingComponent,
                    LikeComponent
                ]
            },] },
];
SocialModule.ctorParameters = () => [];

class TagService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.refresh = new EventEmitter();
    }
    getTagsByNodeId(nodeId) {
        return Observable.fromPromise(this.apiService.getInstance().core.tagsApi.getNodeTags(nodeId))
            .catch(err => this.handleError(err));
    }
    getAllTheTags() {
        return Observable.fromPromise(this.apiService.getInstance().core.tagsApi.getTags())
            .catch(err => this.handleError(err));
    }
    addTag(nodeId, tagName) {
        let                  alfrescoApi = this.apiService.getInstance();
        let                  tagBody = new alfrescoApi.core.TagBody();
        tagBody.tag = tagName;
        let                  promiseAdd = Observable.fromPromise(this.apiService.getInstance().core.tagsApi.addTag(nodeId, tagBody));
        promiseAdd.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseAdd;
    }
    removeTag(nodeId, tag) {
        let                  promiseRemove = Observable.fromPromise(this.apiService.getInstance().core.tagsApi.removeTag(nodeId, tag));
        promiseRemove.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseRemove;
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
TagService.decorators = [
    { type: Injectable },
];
TagService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];
TagService.propDecorators = {
    "refresh": [{ type: Output },],
};

class TagActionsComponent {
    constructor(tagService, translateService) {
        this.tagService = tagService;
        this.translateService = translateService;
        this.successAdd = new EventEmitter();
        this.error = new EventEmitter();
        this.result = new EventEmitter();
        this.disableAddTag = true;
        this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        });
    }
    ngOnChanges() {
        return this.refreshTag();
    }
    refreshTag() {
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((data) => {
                this.tagsEntries = data.list.entries;
                this.disableAddTag = false;
                this.result.emit(this.tagsEntries);
            }, () => {
                this.tagsEntries = null;
                this.disableAddTag = true;
                this.result.emit(this.tagsEntries);
            });
        }
    }
    addTag() {
        if (this.searchTag(this.newTagName)) {
            this.translateService.get('TAG.MESSAGES.EXIST').subscribe((error) => {
                this.errorMsg = error;
            });
            this.error.emit(this.errorMsg);
        }
        else {
            this.tagService.addTag(this.nodeId, this.newTagName).subscribe(() => {
                this.newTagName = '';
                this.successAdd.emit(this.nodeId);
            });
        }
    }
    searchTag(searchTagName) {
        if (this.tagsEntries) {
            return this.tagsEntries.find((currentTag) => {
                return (searchTagName === currentTag.entry.tag);
            });
        }
    }
    cleanErrorMsg() {
        this.errorMsg = '';
    }
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag);
    }
}
TagActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-actions-list',
                template: `<mat-list>
    <mat-list-item *ngFor="let currentEntry of tagsEntries; let idx = index">
        <div class="adf-tag-actions-container" id="tag_delete_{{idx}}" (click)="removeTag(currentEntry.entry.id)">
            <div class="adf-tag-actions-delete-text" id="tag_name_{{idx}}">
                {{currentEntry.entry.tag}}
            </div>
            <mat-icon class="adf-tag-actions-delete-icon">delete</mat-icon>
        </div>
    </mat-list-item>
</mat-list>
<table class="adf-full-width" cellspacing="0">
    <tr>
        <td>
            <mat-form-field class="adf-full-width">
                <input matInput placeholder="{{'TAG.LABEL.NEWTAG' | translate }}"
                       type="text"
                       (keypress)="cleanErrorMsg()"
                       [(ngModel)]="newTagName"
                       id="new-tag-text"/>
                <mat-hint data-automation-id="errorMessage" *ngIf="error" [ngStyle]="{'color': 'red'}" align="start">{{errorMsg}}</mat-hint>
            </mat-form-field>
        </td>
        <td>
            <button class="adf-full-width" color="primary" id="add-tag" (click)="addTag()" [disabled]="disableAddTag"
                    mat-raised-button>
                {{'TAG.BUTTON.ADD' | translate }}
            </button>
        </td>
    </tr>
</table>
`,
                styles: [`.adf-full-width{width:100%}.adf-tag-actions-delete-icon{float:right;cursor:pointer}.adf-tag-actions-delete-text{font-size:16px;float:left}.adf-tag-actions-container{padding:8px 0;height:20px}`],
                encapsulation: ViewEncapsulation.None
            },] },
];
TagActionsComponent.ctorParameters = () => [
    { type: TagService, },
    { type: TranslationService, },
];
TagActionsComponent.propDecorators = {
    "nodeId": [{ type: Input },],
    "successAdd": [{ type: Output },],
    "error": [{ type: Output },],
    "result": [{ type: Output },],
};

class TagListComponent {
    constructor(tagService) {
        this.tagService = tagService;
        this.result = new EventEmitter();
        this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        });
    }
    ngOnInit() {
        return this.refreshTag();
    }
    refreshTag() {
        this.tagService.getAllTheTags().subscribe((data) => {
            this.tagsEntries = data.list.entries;
            this.result.emit(this.tagsEntries);
        });
    }
}
TagListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-list',
                template: `<mat-list>
    <mat-list-item *ngFor="let currentEntry of tagsEntries; let idx = index">
        <div class="adf-list-tag" id="tag_name_{{idx}}">{{currentEntry.entry.tag}}</div>
    </mat-list-item>
</mat-list>
`,
                styles: [`.adf-list-tag{padding:16px;font-size:16px}`],
                encapsulation: ViewEncapsulation.None
            },] },
];
TagListComponent.ctorParameters = () => [
    { type: TagService, },
];
TagListComponent.propDecorators = {
    "result": [{ type: Output },],
};

class TagNodeListComponent {
    constructor(tagService) {
        this.tagService = tagService;
        this.results = new EventEmitter();
        this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        });
    }
    ngOnChanges() {
        return this.refreshTag();
    }
    refreshTag() {
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((data) => {
                this.tagsEntries = data.list.entries;
                this.results.emit(this.tagsEntries);
            });
        }
    }
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag).subscribe(() => {
            this.refreshTag();
        });
    }
}
TagNodeListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-list',
                template: `<mat-chip-list>
    <mat-chip class="adf-tag-chips adf-primary-background-color" *ngFor="let currentEntry of tagsEntries; let idx = index">
        <span id="tag_name_{{idx}}">{{currentEntry.entry.tag}}</span>
        <button class="adf-tag-chips-delete" id="tag_delete_{{idx}}" type="button" (click)="removeTag(currentEntry.entry.id)">
            <mat-icon class="adf-tag-chips-delete-icon adf-primary-contrast-text-color" matChipRemove>cancel</mat-icon>
        </button>
    </mat-chip>
</mat-chip-list>
`,
                styles: [`.adf-tag-chips-delete{overflow:visible;cursor:pointer;height:17px;width:20px;float:right;border:0;background:0 0;padding:0;margin:-1px 0 0 10px}.adf-tag-chips-delete-icon{font-size:20px;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:20px;width:20px}`],
                encapsulation: ViewEncapsulation.None
            },] },
];
TagNodeListComponent.ctorParameters = () => [
    { type: TagService, },
];
TagNodeListComponent.propDecorators = {
    "nodeId": [{ type: Input },],
    "results": [{ type: Output },],
};

class TagModule {
}
TagModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                exports: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                declarations: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                providers: [
                    TagService
                ]
            },] },
];
TagModule.ctorParameters = () => [];

class WebscriptComponent {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.showData = true;
        this.contextRoot = 'alfresco';
        this.servicePath = 'service';
        this.contentType = 'TEXT';
        this.success = new EventEmitter();
        this.data = undefined;
        this.showError = false;
    }
    ngOnChanges(changes) {
        if (this.showData) {
            this.clean();
        }
        return new Promise((resolve, reject) => {
            this.apiService.getInstance().webScript.executeWebScript('GET', this.scriptPath, this.scriptArgs, this.contextRoot, this.servicePath).then((webScriptdata) => {
                this.data = webScriptdata;
                if (this.showData) {
                    if (this.contentType === 'DATATABLE') {
                        this.data = this.showDataAsDataTable(webScriptdata);
                    }
                }
                this.success.emit(this.data);
                resolve();
            }, (error) => {
                this.logService.log('Error' + error);
                reject();
            });
        });
    }
    showDataAsDataTable(data) {
        let                  datatableData = null;
        try {
            if (!data.schema) {
                data.schema = ObjectDataTableAdapter.generateSchema(data.data);
            }
            if (data.schema && data.schema.length > 0) {
                this.data = new ObjectDataTableAdapter(data.data, data.schema);
            }
        }
        catch (                 e) {
            this.logService.error('error during the cast as datatable');
        }
        return datatableData;
    }
    clean() {
        this.data = undefined;
    }
    isDataTableContent() {
        return this.contentType === 'DATATABLE';
    }
}
WebscriptComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-webscript-get',
                template: `<div *ngIf="showData">
    <div *ngIf="contentType === 'JSON'" id="webscript-data-JSON">{{data | json}}</div>
    <div *ngIf="contentType === 'HTML'" id="webscript-data-HTML" [innerHTML]="data"></div>
    <div *ngIf="contentType === 'TEXT'" id="webscript-data-TEXT">{{data}}</div>
    <div *ngIf="isDataTableContent()">
        <adf-datatable id="webscript-datatable-wrapper" [data]="data"></adf-datatable>
        <div>
            <div *ngIf="showError" id="error">{{'WEBSCRIPT.ERROR' | translate: {
                data: data,
                contentType: contentType
                }
                }}
            </div>
        </div>
    </div>
</div>
`
            },] },
];
WebscriptComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];
WebscriptComponent.propDecorators = {
    "scriptPath": [{ type: Input },],
    "scriptArgs": [{ type: Input },],
    "showData": [{ type: Input },],
    "contextRoot": [{ type: Input },],
    "servicePath": [{ type: Input },],
    "contentType": [{ type: Input },],
    "success": [{ type: Output },],
};

class WebScriptModule {
}
WebScriptModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PipeModule,
                    MaterialModule,
                    DataTableModule,
                    TranslateModule
                ],
                exports: [
                    WebscriptComponent
                ],
                declarations: [
                    WebscriptComponent
                ]
            },] },
];
WebScriptModule.ctorParameters = () => [];

class ShareDataRow {
    constructor(obj, documentListService, permissionsStyle) {
        this.obj = obj;
        this.documentListService = documentListService;
        this.permissionsStyle = permissionsStyle;
        this.cache = {};
        this.isSelected = false;
        this.cssClass = '';
        if (!obj) {
            throw new Error(ShareDataRow.ERR_OBJECT_NOT_FOUND);
        }
        this.isDropTarget = this.isFolderAndHasPermissionToUpload(obj);
        if (permissionsStyle) {
            this.cssClass = this.getPermissionClass(obj);
        }
    }
    get node() {
        return this.obj;
    }
    getPermissionClass(nodeEntity) {
        let                  permissionsClasses = '';
        this.permissionsStyle.forEach((currentPermissionsStyle) => {
            if (this.applyPermissionStyleToFolder(nodeEntity.entry, currentPermissionsStyle) || this.applyPermissionStyleToFile(nodeEntity.entry, currentPermissionsStyle)) {
                if (this.documentListService.hasPermission(nodeEntity.entry, currentPermissionsStyle.permission)) {
                    permissionsClasses += ` ${currentPermissionsStyle.css}`;
                }
            }
        });
        return permissionsClasses;
    }
    applyPermissionStyleToFile(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFile && node.isFile);
    }
    applyPermissionStyleToFolder(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFolder && node.isFolder);
    }
    isFolderAndHasPermissionToUpload(obj) {
        return this.isFolder(obj) && this.documentListService.hasPermission(obj.entry, 'create');
    }
    isFolder(obj) {
        return obj.entry && obj.entry.isFolder;
    }
    cacheValue(key, value) {
        this.cache[key] = value;
        return value;
    }
    getValue(key) {
        if (this.cache[key] !== undefined) {
            return this.cache[key];
        }
        return ObjectUtils.getValue(this.obj.entry, key);
    }
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
}
ShareDataRow.ERR_OBJECT_NOT_FOUND = 'Object source not found';

class ShareDataTableAdapter {
    constructor(documentListService, schema = [], sorting) {
        this.documentListService = documentListService;
        this.ERR_ROW_NOT_FOUND = 'Row not found';
        this.ERR_COL_NOT_FOUND = 'Column not found';
        this.thumbnails = false;
        this.rows = [];
        this.columns = schema || [];
        this.sorting = sorting;
    }
    getRows() {
        return this.rows;
    }
    setRows(rows) {
        this.rows = rows || [];
        this.sort();
    }
    getColumns() {
        return this.columns;
    }
    setColumns(columns) {
        this.columns = columns || [];
    }
    getValue(row, col) {
        if (!row) {
            throw new Error(this.ERR_ROW_NOT_FOUND);
        }
        if (!col) {
            throw new Error(this.ERR_COL_NOT_FOUND);
        }
        let                  dataRow =                  (row);
        let                  value = row.getValue(col.key);
        if (dataRow.cache[col.key] !== undefined) {
            return dataRow.cache[col.key];
        }
        if (col.type === 'date') {
            try {
                const                  result = this.formatDate(col, value);
                return dataRow.cacheValue(col.key, result);
            }
            catch (                 err) {
                console.error(`Error parsing date ${value} to format ${col.format}`);
                return 'Error';
            }
        }
        if (col.key === '$thumbnail') {
            if (this.imageResolver) {
                let                  resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
            const                  node = (                 (row)).node;
            if (node.entry.isFolder) {
                return this.documentListService.getMimeTypeIcon('folder');
            }
            if (node.entry.isFile) {
                if (this.thumbnails) {
                    return this.documentListService.getDocumentThumbnailUrl(node);
                }
            }
            if (node.entry.content) {
                const                  mimeType = node.entry.content.mimeType;
                if (mimeType) {
                    return this.documentListService.getMimeTypeIcon(mimeType);
                }
            }
            return this.documentListService.getDefaultMimeTypeIcon();
        }
        if (col.type === 'image') {
            if (this.imageResolver) {
                let                  resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
        }
        return dataRow.cacheValue(col.key, value);
    }
    formatDate(col, value) {
        if (col.type === 'date') {
            const                  format = col.format || 'medium';
            if (format === 'timeAgo') {
                const                  timeAgoPipe = new TimeAgoPipe();
                return timeAgoPipe.transform(value);
            }
            else {
                const                  datePipe = new DatePipe('en-US');
                return datePipe.transform(value, format);
            }
        }
        return value;
    }
    getSorting() {
        return this.sorting;
    }
    setSorting(sorting) {
        this.sorting = sorting;
        this.sortRows(this.rows, this.sorting);
    }
    sort(key, direction) {
        let                  sorting = this.sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
    setFilter(filter) {
        this.filter = filter;
    }
    setImageResolver(resolver) {
        this.imageResolver = resolver;
    }
    sortRows(rows, sorting) {
        const                  options = {};
        if (sorting && sorting.key && rows && rows.length > 0) {
            if (sorting.key.includes('sizeInBytes') || sorting.key === 'name') {
                options.numeric = true;
            }
            rows.sort((a, b) => {
                if (a.node.entry.isFolder !== b.node.entry.isFolder) {
                    return a.node.entry.isFolder ? -1 : 1;
                }
                let                  left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                let                  right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right, undefined, options)
                    : right.localeCompare(left, undefined, options);
            });
        }
    }
    loadPage(page, merge$$1 = false) {
        let                  rows = [];
        if (page && page.list) {
            let                  data = page.list.entries;
            if (data && data.length > 0) {
                rows = data.map(item => new ShareDataRow(item, this.documentListService, this.permissionsStyle));
                if (this.filter) {
                    rows = rows.filter(this.filter);
                }
                if (this.columns && this.columns.length > 0) {
                    let                  sorting = this.getSorting();
                    if (sorting) {
                        this.sortRows(rows, sorting);
                    }
                    else {
                        let                  sortable = this.columns.filter(c => c.sortable);
                        if (sortable.length > 0) {
                            this.sort(sortable[0].key, 'asc');
                        }
                        else {
                            this.sort(this.columns[0].key, 'asc');
                        }
                    }
                }
            }
        }
        if (merge$$1) {
            this.rows = this.rows.concat(rows);
        }
        else {
            this.rows = rows;
        }
    }
}

let presetsDefaultModel = {
    '-trashcan-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'archivedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'archivedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_BY',
            sortable: true
        }
    ],
    '-sites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-mysites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-favorites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ],
    '-recent-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        }
    ],
    '-sharedlinks-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        },
        {
            key: 'sharedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SHARED_BY',
            sortable: true
        }
    ],
    'default': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ]
};

class ContentActionModel {
    constructor(obj) {
        this.disableWithNoPermission = false;
        this.disabled = false;
        if (obj) {
            this.icon = obj.icon;
            this.title = obj.title;
            this.handler = obj.handler;
            this.execute = obj.execute;
            this.target = obj.target;
            this.permission = obj.permission;
            this.disableWithNoPermission = obj.disableWithNoPermission;
            this.disabled = obj.disabled;
        }
    }
}
const ContentActionTarget = {
    Document: 'document',
    Folder: 'folder',
    All: 'all',
};
class DocumentActionModel extends ContentActionModel {
    constructor(json) {
        super(json);
        this.target = 'document';
    }
}
class FolderActionModel extends ContentActionModel {
    constructor(json) {
        super(json);
        this.target = 'folder';
    }
}

class NodeEntityEvent extends BaseEvent {
    constructor(entity) {
        super();
        this.value = entity;
    }
}
class NodeEntryEvent extends BaseEvent {
    constructor(entity) {
        super();
        this.value = entity;
    }
}

class CustomResourcesService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.CREATE_PERMISSION = 'create';
    }
    getRecentFiles(personId, pagination) {
        return new Observable(observer => {
            this.apiService.peopleApi.getPerson(personId)
                .then((person) => {
                const                  username = person.entry.id;
                const                  query = {
                    query: {
                        query: '*',
                        language: 'afts'
                    },
                    filterQueries: [
                        { query: `cm:modified:[NOW/DAY-30DAYS TO NOW/DAY+1DAY]` },
                        { query: `cm:modifier:${username} OR cm:creator:${username}` },
                        { query: `TYPE:"content" AND -TYPE:"app:filelink" AND -TYPE:"fm:post"` }
                    ],
                    include: ['path', 'properties', 'allowableOperations'],
                    sort: [{
                            type: 'FIELD',
                            field: 'cm:modified',
                            ascending: false
                        }],
                    paging: {
                        maxItems: pagination.maxItems,
                        skipCount: pagination.skipCount
                    }
                };
                return this.apiService.searchApi.search(query)
                    .then((serachResult) => {
                    observer.next(serachResult);
                    observer.complete();
                }, (err) => {
                    observer.error(err);
                    observer.complete();
                });
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).catch(err => this.handleError(err));
    }
    loadFavorites(pagination, includeFields = []) {
        let                  includeFieldsRequest = this.getIncludesFields(includeFields);
        const                  options = {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: includeFieldsRequest
        };
        return new Observable(observer => {
            this.apiService.favoritesApi.getFavorites('-me-', options)
                .then((result) => {
                let                  page = {
                    list: {
                        entries: result.list.entries
                            .map(({ entry: { target } }) => ({
                            entry: target.file || target.folder
                        }))
                            .map(({ entry }) => {
                            entry.properties = {
                                'cm:title': entry.title,
                                'cm:description': entry.description
                            };
                            return { entry };
                        }),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).catch(err => this.handleError(err));
    }
    loadMemberSites(pagination) {
        const                  options = {
            include: ['properties'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable(observer => {
            this.apiService.peopleApi.getSiteMembership('-me-', options)
                .then((result) => {
                let                  page = {
                    list: {
                        entries: result.list.entries
                            .map(({ entry: { site } }) => {
                            site.allowableOperations = site.allowableOperations ? site.allowableOperations : [this.CREATE_PERMISSION];
                            site.name = site.name || site.title;
                            return {
                                entry: site
                            };
                        }),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).catch(err => this.handleError(err));
    }
    loadSites(pagination) {
        const                  options = {
            include: ['properties'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable(observer => {
            this.apiService.sitesApi.getSites(options)
                .then((page) => {
                page.list.entries.map(({ entry }) => {
                    entry.name = entry.name || entry.title;
                    return { entry };
                });
                observer.next(page);
                observer.complete();
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).catch(err => this.handleError(err));
    }
    loadTrashcan(pagination, includeFields = []) {
        let                  includeFieldsRequest = this.getIncludesFields(includeFields);
        const                  options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return Observable.fromPromise(this.apiService.nodesApi.getDeletedNodes(options)).catch(err => this.handleError(err));
    }
    loadSharedLinks(pagination, includeFields = []) {
        let                  includeFieldsRequest = this.getIncludesFields(includeFields);
        const                  options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return Observable.fromPromise(this.apiService.sharedLinksApi.findSharedLinks(options)).catch(err => this.handleError(err));
    }
    isCustomSource(folderId) {
        let                  isCustomSources = false;
        const                  sources = ['-trashcan-', '-sharedlinks-', '-sites-', '-mysites-', '-favorites-', '-recent-'];
        if (sources.indexOf(folderId) > -1) {
            isCustomSources = true;
        }
        return isCustomSources;
    }
    loadFolderByNodeId(nodeId, pagination, includeFields) {
        if (nodeId === '-trashcan-') {
            return this.loadTrashcan(pagination, includeFields);
        }
        else if (nodeId === '-sharedlinks-') {
            return this.loadSharedLinks(pagination, includeFields);
        }
        else if (nodeId === '-sites-') {
            return this.loadSites(pagination);
        }
        else if (nodeId === '-mysites-') {
            return this.loadMemberSites(pagination);
        }
        else if (nodeId === '-favorites-') {
            return this.loadFavorites(pagination, includeFields);
        }
        else if (nodeId === '-recent-') {
            return this.getRecentFiles('-me-', pagination);
        }
    }
    getCorrespondingNodeIds(nodeId, pagination) {
        if (nodeId === '-trashcan-') {
            return Observable.fromPromise(this.apiService.nodesApi.getDeletedNodes()
                .then(result => result.list.entries.map(node => node.entry.id)));
        }
        else if (nodeId === '-sharedlinks-') {
            return Observable.fromPromise(this.apiService.sharedLinksApi.findSharedLinks()
                .then(result => result.list.entries.map(node => node.entry.nodeId)));
        }
        else if (nodeId === '-sites-') {
            return Observable.fromPromise(this.apiService.sitesApi.getSites()
                .then(result => result.list.entries.map(node => node.entry.guid)));
        }
        else if (nodeId === '-mysites-') {
            return Observable.fromPromise(this.apiService.peopleApi.getSiteMembership('-me-')
                .then(result => result.list.entries.map(node => node.entry.guid)));
        }
        else if (nodeId === '-favorites-') {
            return Observable.fromPromise(this.apiService.favoritesApi.getFavorites('-me-')
                .then(result => result.list.entries.map(node => node.entry.targetGuid)));
        }
        else if (nodeId === '-recent-') {
            return new Observable(observer => {
                this.getRecentFiles('-me-', pagination)
                    .subscribe((recentFiles) => {
                    let                  recentFilesIdS = recentFiles.list.entries.map(node => node.entry.id);
                    observer.next(recentFilesIdS);
                    observer.complete();
                });
            });
        }
        return Observable.of([]);
    }
    getIncludesFields(includeFields) {
        return ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
    }
    handleError(error) {
        this.logService.error(error);
        return Observable.throw(error || 'Server error');
    }
}
CustomResourcesService.decorators = [
    { type: Injectable },
];
CustomResourcesService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: LogService, },
];

const PaginationStrategy = {
    Finite: 0,
    Infinite: 1,
};
PaginationStrategy[PaginationStrategy.Finite] = "Finite";
PaginationStrategy[PaginationStrategy.Infinite] = "Infinite";
class DocumentListComponent {
    constructor(documentListService, ngZone, elementRef, appConfig, preferences, customResourcesService, contentService) {
        this.documentListService = documentListService;
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.appConfig = appConfig;
        this.preferences = preferences;
        this.customResourcesService = customResourcesService;
        this.contentService = contentService;
        this.display = DisplayMode.List;
        this.permissionsStyle = [];
        this.locationFormat = '/';
        this.navigate = true;
        this.showHeader = true;
        this.navigationMode = DocumentListComponent.DOUBLE_CLICK_NAVIGATION;
        this.thumbnails = false;
        this.selectionMode = 'single';
        this.multiselect = false;
        this.contentActions = false;
        this.contentActionsPosition = 'right';
        this.contextMenuActions = false;
        this.emptyFolderImageUrl = './assets/images/empty_doc_lib.svg';
        this.allowDropFiles = false;
        this.loading = false;
        this.rowFilter = null;
        this.imageResolver = null;
        this.currentFolderId = null;
        this.folderNode = null;
        this.node = null;
        this.skipCount = 0;
        this.enableInfiniteScrolling = false;
        this.nodeClick = new EventEmitter();
        this.nodeDblClick = new EventEmitter();
        this.folderChange = new EventEmitter();
        this.preview = new EventEmitter();
        this.ready = new EventEmitter();
        this.error = new EventEmitter();
        this.actions = [];
        this.contextActionHandler = new Subject();
        this.noPermission = false;
        this.selection = new Array();
        this.layoutPresets = {};
    }
    getContextActions(node) {
        if (node && node.entry) {
            let                  actions = this.getNodeActions(node);
            if (actions && actions.length > 0) {
                return actions.map((currentAction) => {
                    return {
                        model: currentAction,
                        node: node,
                        subject: this.contextActionHandler
                    };
                });
            }
        }
        return null;
    }
    get supportedPageSizes() {
        return this.preferences.getDefaultPageSizes();
    }
    get hasCustomLayout() {
        return this.columnList && this.columnList.columns && this.columnList.columns.length > 0;
    }
    getDefaultSorting() {
        let                  defaultSorting;
        if (this.sorting) {
            const [key, direction] = this.sorting;
            defaultSorting = new DataSorting(key, direction);
        }
        return defaultSorting;
    }
    getLayoutPreset(name = 'default') {
        return (this.layoutPresets[name] || this.layoutPresets['default']).map(col => new ObjectDataColumn(col));
    }
    get pagination() {
        let                  maxItems = this.preferences.paginationSize;
        if (!this._pagination) {
            if (this.maxItems) {
                maxItems = this.maxItems;
            }
            let                  defaultPagination =                  ({
                maxItems: maxItems,
                skipCount: 0,
                totalItems: 0,
                hasMoreItems: false
            });
            this._pagination = new BehaviorSubject(defaultPagination);
        }
        return this._pagination;
    }
    isEmptyTemplateDefined() {
        if (this.dataTable) {
            if (this.emptyFolderTemplate) {
                return true;
            }
        }
        return false;
    }
    isNoPermissionTemplateDefined() {
        if (this.dataTable) {
            if (this.noPermissionTemplate) {
                return true;
            }
        }
        return false;
    }
    isMobile() {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    isEmpty() {
        return !this.data || this.data.getRows().length === 0;
    }
    ngOnInit() {
        this.loadLayoutPresets();
        this.data = new ShareDataTableAdapter(this.documentListService, null, this.getDefaultSorting());
        this.data.thumbnails = this.thumbnails;
        this.data.permissionsStyle = this.permissionsStyle;
        if (this.rowFilter) {
            this.data.setFilter(this.rowFilter);
        }
        if (this.imageResolver) {
            this.data.setImageResolver(this.imageResolver);
        }
        this.contextActionHandlerSubscription = this.contextActionHandler.subscribe(val => this.contextActionCallback(val));
        this.enforceSingleClickNavigationForMobile();
    }
    ngAfterContentInit() {
        let                  schema = [];
        if (this.hasCustomLayout) {
            schema = this.columnList.columns.map(c =>                  (c));
        }
        if (!this.data) {
            this.data = new ShareDataTableAdapter(this.documentListService, schema, this.getDefaultSorting());
        }
        else if (schema && schema.length > 0) {
            this.data.setColumns(schema);
        }
        let                  columns = this.data.getColumns();
        if (!columns || columns.length === 0) {
            this.setupDefaultColumns(this.currentFolderId);
        }
    }
    ngOnChanges(changes) {
        this.resetSelection();
        if (changes["folderNode"] && changes["folderNode"].currentValue) {
            this.currentFolderId = changes["folderNode"].currentValue.id;
            this.resetNewFolderPagination();
            this.loadFolder();
        }
        else if (changes["currentFolderId"] &&
            changes["currentFolderId"].currentValue &&
            changes["currentFolderId"].currentValue !== changes["currentFolderId"].previousValue) {
            this.resetNewFolderPagination();
            this.loadFolder();
        }
        else if (this.data) {
            if (changes["node"] && changes["node"].currentValue) {
                if (changes["node"].currentValue.list.pagination) {
                    changes["node"].currentValue.list.pagination.skipCount = 0;
                }
                this.data.loadPage(changes["node"].currentValue);
                this.onDataReady(changes["node"].currentValue);
            }
            else if (changes["rowFilter"]) {
                this.data.setFilter(changes["rowFilter"].currentValue);
                if (this.currentFolderId) {
                    this.loadFolderNodesByFolderNodeId(this.currentFolderId, this.pagination.getValue()).catch(err => this.error.emit(err));
                }
            }
            else if (changes["imageResolver"]) {
                this.data.setImageResolver(changes["imageResolver"].currentValue);
            }
        }
    }
    reload() {
        this.ngZone.run(() => {
            this.resetSelection();
            if (this.node) {
                this.data.loadPage(this.node);
                this.onDataReady(this.node);
            }
            else {
                this.loadFolder();
            }
        });
    }
    contextActionCallback(action) {
        if (action) {
            this.executeContentAction(action.node, action.model);
        }
    }
    getNodeActions(node) {
        let                  target = null;
        if (node && node.entry) {
            if (node.entry.isFile) {
                target = 'document';
            }
            else if (node.entry.isFolder) {
                target = 'folder';
            }
            if (target) {
                let                  actionsByTarget = this.actions.filter(entry => {
                    return entry.target.toLowerCase() === target;
                }).map(action => new ContentActionModel(action));
                actionsByTarget.forEach((action) => {
                    this.disableActionsWithNoPermissions(node, action);
                });
                return actionsByTarget;
            }
        }
        return [];
    }
    disableActionsWithNoPermissions(node, action) {
        if (action.permission && node.entry.allowableOperations && !this.contentService.hasPermission(node.entry, action.permission)) {
            action.disabled = true;
        }
    }
    onShowContextMenu(e) {
        if (e && this.contextMenuActions) {
            e.preventDefault();
        }
    }
    performNavigation(node) {
        if (this.canNavigateFolder(node)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    }
    performCustomSourceNavigation(node) {
        if (this.customResourcesService.isCustomSource(this.currentFolderId)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    }
    updateFolderData(node) {
        this.resetNewFolderPagination();
        this.currentFolderId = node.entry.id;
        this.reload();
        this.folderChange.emit(new NodeEntryEvent(node.entry));
    }
    updateCustomSourceData(nodeId) {
        this.folderNode = null;
        this.currentFolderId = nodeId;
    }
    executeContentAction(node, action) {
        if (node && node.entry && action) {
            let                  handlerSub;
            if (typeof action.handler === 'function') {
                handlerSub = action.handler(node, this, action.permission);
            }
            else {
                handlerSub = Observable.of(true);
            }
            if (typeof action.execute === 'function') {
                handlerSub.subscribe(() => {
                    action.execute(node);
                });
            }
        }
    }
    loadFolder() {
        if (!this.pagination.getValue().merge) {
            this.loading = true;
        }
        if (!this.hasCustomLayout) {
            this.setupDefaultColumns(this.currentFolderId);
        }
        if (this.folderNode) {
            return this.loadFolderNodesByFolderNodeId(this.folderNode.id, this.pagination.getValue())
                .catch(err => this.handleError(err));
        }
        else {
            this.loadFolderByNodeId(this.currentFolderId);
        }
    }
    loadFolderByNodeId(nodeId) {
        if (this.customResourcesService.isCustomSource(nodeId)) {
            this.updateCustomSourceData(nodeId);
            this.customResourcesService.loadFolderByNodeId(nodeId, this.pagination.getValue(), this.includeFields)
                .subscribe((page) => {
                this.onPageLoaded(page);
            }, err => {
                this.error.emit(err);
            });
        }
        else {
            this.documentListService
                .getFolderNode(nodeId, this.includeFields)
                .subscribe((node) => {
                this.folderNode = node;
                return this.loadFolderNodesByFolderNodeId(node.id, this.pagination.getValue())
                    .catch(err => this.handleError(err));
            }, err => {
                this.handleError(err);
            });
        }
    }
    loadFolderNodesByFolderNodeId(id, pagination) {
        return new Promise((resolve, reject) => {
            this.documentListService
                .getFolder(null, {
                maxItems: pagination.maxItems,
                skipCount: pagination.skipCount,
                rootFolderId: id
            }, this.includeFields)
                .subscribe(nodePaging => {
                this.data.loadPage(                 (nodePaging), this.pagination.getValue().merge);
                this.loading = false;
                this.onDataReady(nodePaging);
                resolve(true);
            }, err => {
                this.handleError(err);
            });
        });
    }
    resetSelection() {
        this.dataTable.resetSelection();
        this.selection = [];
        this.noPermission = false;
    }
    onPageLoaded(nodePaging) {
        if (nodePaging) {
            this.data.loadPage(nodePaging, this.pagination.getValue().merge);
            this.loading = false;
            this.onDataReady(nodePaging);
        }
    }
    setupDefaultColumns(preset = 'default') {
        if (this.data) {
            const                  columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    }
    onPreviewFile(node) {
        if (node) {
            this.preview.emit(new NodeEntityEvent(node));
        }
    }
    onNodeClick(node) {
        const                  domEvent = new CustomEvent('node-click', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        const                  event = new NodeEntityEvent(node);
        this.nodeClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.SINGLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    }
    onNodeDblClick(node) {
        const                  domEvent = new CustomEvent('node-dblclick', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        const                  event = new NodeEntityEvent(node);
        this.nodeDblClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.DOUBLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    }
    onNodeSelect(event) {
        this.selection = event.selection.map(entry => entry.node);
        const                  domEvent = new CustomEvent('node-select', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    onNodeUnselect(event) {
        this.selection = event.selection.map(entry => entry.node);
        const                  domEvent = new CustomEvent('node-unselect', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    onShowRowContextMenu(event) {
        if (this.contextMenuActions) {
            let                  args = event.value;
            let                  node = (                 (args.row)).node;
            if (node) {
                args.actions = this.getContextActions(node) || [];
            }
        }
    }
    onShowRowActionsMenu(event) {
        if (this.contentActions) {
            let                  args = event.value;
            let                  node = (                 (args.row)).node;
            if (node) {
                args.actions = this.getNodeActions(node) || [];
            }
        }
    }
    onExecuteRowAction(event) {
        if (this.contentActions) {
            let                  args = event.value;
            let                  node = (                 (args.row)).node;
            let                  action = (                 (args.action));
            this.executeContentAction(node, action);
        }
    }
    enforceSingleClickNavigationForMobile() {
        if (this.isMobile()) {
            this.navigationMode = DocumentListComponent.SINGLE_CLICK_NAVIGATION;
        }
    }
    canNavigateFolder(node) {
        let                  canNavigateFolder = false;
        if (this.customResourcesService.isCustomSource(this.currentFolderId)) {
            canNavigateFolder = false;
        }
        else if (node && node.entry && node.entry.isFolder) {
            canNavigateFolder = true;
        }
        return canNavigateFolder;
    }
    loadLayoutPresets() {
        const                  externalSettings = this.appConfig.get('document-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, presetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = presetsDefaultModel;
        }
    }
    onDataReady(nodePaging) {
        this.ready.emit(nodePaging);
        this.pagination.next(nodePaging.list.pagination);
    }
    updatePagination(pagination) {
        this.reload();
    }
    navigateTo(nodeId) {
        this.currentFolderId = nodeId;
        this.resetNewFolderPagination();
        this.loadFolder();
        this.folderChange.emit(new NodeEntryEvent({ id: nodeId }));
    }
    resetNewFolderPagination() {
        this.folderNode = null;
        this.pagination.value.skipCount = 0;
    }
    getCorrespondingNodeIds(nodeId) {
        if (this.customResourcesService.isCustomSource(nodeId)) {
            return this.customResourcesService.getCorrespondingNodeIds(nodeId, this.pagination.getValue());
        }
        else if (nodeId) {
            return new Observable(observer => {
                this.documentListService.getFolderNode(nodeId, this.includeFields)
                    .subscribe((node) => {
                    observer.next([node.id]);
                    observer.complete();
                });
            });
        }
    }
    ngOnDestroy() {
        if (this.contextActionHandlerSubscription) {
            this.contextActionHandlerSubscription.unsubscribe();
            this.contextActionHandlerSubscription = null;
        }
    }
    handleError(err) {
        if (err.message) {
            if (JSON.parse(err.message).error.statusCode === 403) {
                this.loading = false;
                this.noPermission = true;
            }
        }
        this.error.emit(err);
    }
}
DocumentListComponent.SINGLE_CLICK_NAVIGATION = 'click';
DocumentListComponent.DOUBLE_CLICK_NAVIGATION = 'dblclick';
DocumentListComponent.DEFAULT_PAGE_SIZE = 20;
DocumentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-document-list',
                styles: [``],
                template: `<adf-datatable
    #dataTable
    [selectionMode]="selectionMode"
    [data]="data"
    [actions]="contentActions"
    [actionsPosition]="contentActionsPosition"
    [multiselect]="multiselect"
    [allowDropFiles]="allowDropFiles"
    [contextMenu]="contextMenuActions"
    [rowStyle]="rowStyle"
    [rowStyleClass]="rowStyleClass"
    [loading]="loading"
    [display]="display"
    [noPermission]="noPermission"
    [showHeader]="!isEmpty() && showHeader"
    (showRowContextMenu)="onShowRowContextMenu($event)"
    (showRowActionsMenu)="onShowRowActionsMenu($event)"
    (executeRowAction)="onExecuteRowAction($event)"
    (rowClick)="onNodeClick($event.value?.node)"
    (rowDblClick)="onNodeDblClick($event.value?.node)"
    (row-select)="onNodeSelect($event.detail)"
    (row-unselect)="onNodeUnselect($event.detail)">

    <div *ngIf="!isEmptyTemplateDefined()">
        <no-content-template>
            <ng-template>
                <adf-empty-list>
                    <div class="adf-empty-list_template adf-empty-folder">
                        <div class="adf-empty-folder-this-space-is-empty">{{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}}</div>
                        <div fxHide.lt-md="true" class="adf-empty-folder-drag-drop">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate }}</div>
                        <div fxHide.lt-md="true" class="adf-empty-folder-any-files-here-to-add">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.SUBTITLE' | translate }}</div>
                        <img class="adf-empty-folder-image" [src]="emptyFolderImageUrl">
                    </div>
                    <!-- <div adf-empty-list-header class="adf-empty-list-header"> {{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}} </div> -->
                </adf-empty-list>
            </ng-template>
        </no-content-template>
    </div>

    <div *ngIf="!isNoPermissionTemplateDefined()">
        <no-permission-template>
            <ng-template>
                <div class="adf-no-permission__template">
                    <mat-icon>ic_error</mat-icon>
                    <p class="adf-no-permission__template--text">{{ 'ADF-DOCUMENT-LIST.NO_PERMISSION' | translate }}</p>
                </div>
            </ng-template>
        </no-permission-template>
    </div>

    <div>
        <loading-content-template>
            <ng-template>
                <div class="adf-document-list-loading-container">
                    <mat-progress-spinner
                        id="adf-document-list-loading"
                        class="adf-document-list-loading-margin"
                        [color]="'primary'"
                        [mode]="'indeterminate'">
                    </mat-progress-spinner>
                </div>
            </ng-template>
        </loading-content-template>
    </div>
</adf-datatable>
`,
                encapsulation: ViewEncapsulation.None
            },] },
];
DocumentListComponent.ctorParameters = () => [
    { type: DocumentListService, },
    { type: NgZone, },
    { type: ElementRef, },
    { type: AppConfigService, },
    { type: UserPreferencesService, },
    { type: CustomResourcesService, },
    { type: ContentService, },
];
DocumentListComponent.propDecorators = {
    "columnList": [{ type: ContentChild, args: [DataColumnListComponent,] },],
    "includeFields": [{ type: Input },],
    "display": [{ type: Input },],
    "permissionsStyle": [{ type: Input },],
    "locationFormat": [{ type: Input },],
    "navigate": [{ type: Input },],
    "showHeader": [{ type: Input },],
    "navigationMode": [{ type: Input },],
    "thumbnails": [{ type: Input },],
    "selectionMode": [{ type: Input },],
    "multiselect": [{ type: Input },],
    "contentActions": [{ type: Input },],
    "contentActionsPosition": [{ type: Input },],
    "contextMenuActions": [{ type: Input },],
    "emptyFolderImageUrl": [{ type: Input },],
    "allowDropFiles": [{ type: Input },],
    "sorting": [{ type: Input },],
    "rowStyle": [{ type: Input },],
    "rowStyleClass": [{ type: Input },],
    "loading": [{ type: Input },],
    "rowFilter": [{ type: Input },],
    "imageResolver": [{ type: Input },],
    "currentFolderId": [{ type: Input },],
    "folderNode": [{ type: Input },],
    "node": [{ type: Input },],
    "maxItems": [{ type: Input },],
    "skipCount": [{ type: Input },],
    "enableInfiniteScrolling": [{ type: Input },],
    "nodeClick": [{ type: Output },],
    "nodeDblClick": [{ type: Output },],
    "folderChange": [{ type: Output },],
    "preview": [{ type: Output },],
    "ready": [{ type: Output },],
    "error": [{ type: Output },],
    "dataTable": [{ type: ViewChild, args: ['dataTable',] },],
    "onShowContextMenu": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],
};

class ContentColumnListComponent {
    constructor(documentList, logService) {
        this.documentList = documentList;
        this.logService = logService;
        this.logService.log('ContentColumnListComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnListComponent instead.');
    }
    registerColumn(column) {
        if (this.documentList && column) {
            let                  columns = this.documentList.data.getColumns();
            columns.push(column);
            return true;
        }
        return false;
    }
}
ContentColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-columns',
                template: ''
            },] },
];
ContentColumnListComponent.ctorParameters = () => [
    { type: DocumentListComponent, },
    { type: LogService, },
];

class ContentColumnComponent {
    constructor(list, logService) {
        this.list = list;
        this.logService = logService;
        this.type = 'text';
        this.sortable = false;
        this.title = '';
        this.logService.log('ContentColumnComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnComponent instead.');
    }
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
    ngAfterContentInit() {
        this.register();
    }
    register() {
        if (this.list) {
            return this.list.registerColumn(this);
        }
        return false;
    }
}
ContentColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-column',
                template: ''
            },] },
];
ContentColumnComponent.ctorParameters = () => [
    { type: ContentColumnListComponent, },
    { type: LogService, },
];
ContentColumnComponent.propDecorators = {
    "key": [{ type: Input },],
    "type": [{ type: Input },],
    "format": [{ type: Input },],
    "sortable": [{ type: Input },],
    "title": [{ type: Input },],
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
    "srTitle": [{ type: Input, args: ['sr-title',] },],
    "cssClass": [{ type: Input, args: ['class',] },],
};

class PermissionModel {
    constructor(obj) {
        if (obj) {
            this.type = obj.type || null;
            this.action = obj.action || null;
            this.permission = obj.permission || null;
        }
    }
}

class NodeActionsService {
    constructor(contentDialogService, dialogRef, content, documentListService, apiService, dialog) {
        this.contentDialogService = contentDialogService;
        this.dialogRef = dialogRef;
        this.content = content;
        this.documentListService = documentListService;
        this.apiService = apiService;
        this.dialog = dialog;
        this.error = new EventEmitter();
    }
    downloadNode(node) {
        new NodeDownloadDirective(this.apiService, this.dialog)
            .downloadNode(node);
    }
    copyContent(contentEntry, permission) {
        return this.doFileOperation('copy', 'content', contentEntry, permission);
    }
    copyFolder(contentEntry, permission) {
        return this.doFileOperation('copy', 'folder', contentEntry, permission);
    }
    moveContent(contentEntry, permission) {
        return this.doFileOperation('move', 'content', contentEntry, permission);
    }
    moveFolder(contentEntry, permission) {
        return this.doFileOperation('move', 'folder', contentEntry, permission);
    }
    doFileOperation(action, type, contentEntry, permission) {
        const                  observable = new Subject();
        this.contentDialogService
            .openCopyMoveDialog(action, contentEntry, permission)
            .subscribe((selections) => {
            const                  selection = selections[0];
            this.documentListService[`${action}Node`].call(this.documentListService, contentEntry.id, selection.id)
                .subscribe(observable.next.bind(observable, `OPERATION.SUCCES.${type.toUpperCase()}.${action.toUpperCase()}`), observable.error.bind(observable));
        }, (error) => {
            observable.error(error);
            return observable;
        });
        return observable;
    }
}
NodeActionsService.decorators = [
    { type: Injectable },
];
NodeActionsService.ctorParameters = () => [
    { type: ContentNodeDialogService, },
    { type: MatDialog, },
    { type: ContentService, },
    { type: DocumentListService, },
    { type: AlfrescoApiService, },
    { type: MatDialog, },
];
NodeActionsService.propDecorators = {
    "error": [{ type: Output },],
};

class DocumentActionsService {
    constructor(nodeActionsService, contentNodeDialogService, translation, documentListService, contentService) {
        this.nodeActionsService = nodeActionsService;
        this.contentNodeDialogService = contentNodeDialogService;
        this.translation = translation;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    getHandler(key) {
        if (key) {
            let                  lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    }
    setHandler(key, handler) {
        if (key) {
            let                  lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    }
    canExecuteAction(obj) {
        return this.documentListService && obj && obj.entry.isFile === true;
    }
    setupActionHandlers() {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
        this.handlers['lock'] = this.lockNode.bind(this);
    }
    lockNode(node, target, permission) {
        return this.contentNodeDialogService.openLockNodeDialog(node.entry);
    }
    downloadNode(obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    }
    copyNode(node, target, permission) {
        const                  actionObservable = this.nodeActionsService.copyContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'copy', target, permission);
        return actionObservable;
    }
    moveNode(node, target, permission) {
        const                  actionObservable = this.nodeActionsService.moveContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'move', target, permission);
        return actionObservable;
    }
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((fileOperationMessage) => {
            this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    }
    deleteNode(node, target, permission) {
        let                  handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasPermission(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe(() => {
                    let                  message = this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    this.success.next(message);
                }, () => {
                    let                  message = this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    this.error.next(message);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({
                    type: 'content',
                    action: 'delete',
                    permission: permission
                }));
                return Observable.throw(new Error('No permission to delete'));
            }
        }
    }
}
DocumentActionsService.decorators = [
    { type: Injectable },
];
DocumentActionsService.ctorParameters = () => [
    { type: NodeActionsService, },
    { type: ContentNodeDialogService, },
    { type: TranslationService, },
    { type: DocumentListService, },
    { type: ContentService, },
];

class FolderActionsService {
    constructor(nodeActionsService, documentListService, contentService, translation) {
        this.nodeActionsService = nodeActionsService;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.translation = translation;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    getHandler(key) {
        if (key) {
            let                  lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    }
    setHandler(key, handler) {
        if (key) {
            let                  lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    }
    canExecuteAction(obj) {
        return this.documentListService && obj && obj.entry.isFolder === true;
    }
    setupActionHandlers() {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
    }
    downloadNode(obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    }
    copyNode(obj, target, permission) {
        const                  actionObservable = this.nodeActionsService.copyFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'copy', target, permission);
        return actionObservable;
    }
    moveNode(obj, target, permission) {
        const                  actionObservable = this.nodeActionsService.moveFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'move', target, permission);
        return actionObservable;
    }
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((fileOperationMessage) => {
            if (target && typeof target.reload === 'function') {
                target.reload();
            }
            this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    }
    deleteNode(node, target, permission) {
        let                  handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasPermission(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe(() => {
                    if (target && typeof target.reload === 'function') {
                        target.reload();
                    }
                    let                  message = this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    this.success.next(message);
                }, () => {
                    let                  message = this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    this.error.next(message);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({ type: 'folder', action: 'delete', permission: permission }));
                return Observable.throw(new Error('No permission to delete'));
            }
        }
    }
}
FolderActionsService.decorators = [
    { type: Injectable },
];
FolderActionsService.ctorParameters = () => [
    { type: NodeActionsService, },
    { type: DocumentListService, },
    { type: ContentService, },
    { type: TranslationService, },
];

class ContentActionListComponent {
    constructor(documentList) {
        this.documentList = documentList;
    }
    registerAction(action) {
        if (this.documentList && action) {
            this.documentList.actions.push(action);
            return true;
        }
        return false;
    }
}
ContentActionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-actions',
                template: ''
            },] },
];
ContentActionListComponent.ctorParameters = () => [
    { type: DocumentListComponent, },
];

class ContentActionComponent {
    constructor(list, documentActions, folderActions) {
        this.list = list;
        this.documentActions = documentActions;
        this.folderActions = folderActions;
        this.title = 'Action';
        this.target = ContentActionTarget.All;
        this.disabled = false;
        this.execute = new EventEmitter();
        this.permissionEvent = new EventEmitter();
        this.error = new EventEmitter();
        this.success = new EventEmitter();
    }
    ngOnInit() {
        if (this.target === ContentActionTarget.All) {
            this.generateAction(ContentActionTarget.Folder);
            this.generateAction(ContentActionTarget.Document);
        }
        else {
            this.generateAction(this.target);
        }
    }
    register(model) {
        if (this.list) {
            return this.list.registerAction(model);
        }
        return false;
    }
    generateAction(target) {
        let                  model = new ContentActionModel({
            title: this.title,
            icon: this.icon,
            permission: this.permission,
            disableWithNoPermission: this.disableWithNoPermission,
            target: target,
            disabled: this.disabled
        });
        if (this.handler) {
            model.handler = this.getSystemHandler(target, this.handler);
        }
        if (this.execute) {
            model.execute = (value) => {
                this.execute.emit({ value });
            };
        }
        this.register(model);
    }
    getSystemHandler(target, name) {
        if (target) {
            let                  ltarget = target.toLowerCase();
            if (ltarget === ContentActionTarget.Document) {
                if (this.documentActions) {
                    this.documentActions.permissionEvent.subscribe((permission) => {
                        this.permissionEvent.emit(permission);
                    });
                    this.documentActions.error.subscribe((errors) => {
                        this.error.emit(errors);
                    });
                    this.documentActions.success.subscribe((message) => {
                        this.success.emit(message);
                    });
                    return this.documentActions.getHandler(name);
                }
                return null;
            }
            if (ltarget === ContentActionTarget.Folder) {
                if (this.folderActions) {
                    this.folderActions.permissionEvent.subscribe((permission) => {
                        this.permissionEvent.emit(permission);
                    });
                    this.folderActions.error.subscribe((errors) => {
                        this.error.emit(errors);
                    });
                    this.folderActions.success.subscribe((message) => {
                        this.success.emit(message);
                    });
                    return this.folderActions.getHandler(name);
                }
                return null;
            }
        }
        return null;
    }
}
ContentActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-action',
                template: '',
                providers: [
                    DocumentActionsService,
                    FolderActionsService
                ]
            },] },
];
ContentActionComponent.ctorParameters = () => [
    { type: ContentActionListComponent, },
    { type: DocumentActionsService, },
    { type: FolderActionsService, },
];
ContentActionComponent.propDecorators = {
    "title": [{ type: Input },],
    "icon": [{ type: Input },],
    "handler": [{ type: Input },],
    "target": [{ type: Input },],
    "permission": [{ type: Input },],
    "disableWithNoPermission": [{ type: Input },],
    "disabled": [{ type: Input },],
    "execute": [{ type: Output },],
    "permissionEvent": [{ type: Output },],
    "error": [{ type: Output },],
    "success": [{ type: Output },],
};

class EmptyFolderContentDirective {
    constructor(documentList) {
        this.documentList = documentList;
    }
    ngAfterContentInit() {
        this.documentList.emptyFolderTemplate = this.template;
        this.documentList.dataTable.noContentTemplate = this.template;
    }
}
EmptyFolderContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'empty-folder-content'
            },] },
];
EmptyFolderContentDirective.ctorParameters = () => [
    { type: DocumentListComponent, },
];
EmptyFolderContentDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class NoPermissionContentDirective {
    constructor(documentList) {
        this.documentList = documentList;
    }
    ngAfterContentInit() {
        this.documentList.noPermissionTemplate = this.template;
        this.documentList.dataTable.noPermissionTemplate = this.template;
    }
}
NoPermissionContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-permission-content'
            },] },
];
NoPermissionContentDirective.ctorParameters = () => [
    { type: DocumentListComponent, },
];
NoPermissionContentDirective.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};

class NodePaging {
}
class NodePagingList {
}
class NodeMinimalEntry {
}
class Pagination {
}
class NodeMinimal {
    constructor() {
        this.properties = {};
    }
}
class UserInfo {
}
class ContentInfo {
}
class PathInfoEntity {
}
class PathElementEntity {
}

class PermissionStyleModel {
    constructor(css, permission, isFile = true, isFolder = true) {
        this.isFolder = true;
        this.isFile = true;
        this.css = css;
        this.permission = permission;
        this.isFile = isFile;
        this.isFolder = isFolder;
    }
}

class FileUploadingListComponent {
    constructor(uploadService, nodesApi, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.translateService = translateService;
        this.FileUploadStatus = FileUploadStatus;
        this.files = [];
        this.error = new EventEmitter();
    }
    cancelFile(file) {
        this.uploadService.cancelUpload(file);
    }
    removeFile(file) {
        this.deleteNode(file)
            .subscribe(() => {
            if (file.status === FileUploadStatus.Error) {
                this.notifyError(file);
            }
            this.uploadService.cancelUpload(file);
        });
    }
    cancelAllFiles() {
        this.getUploadingFiles()
            .forEach((file) => this.uploadService.cancelUpload(file));
        const                  deletedFiles = this.files
            .filter((file) => file.status === FileUploadStatus.Complete)
            .map((file) => this.deleteNode(file));
        Observable.forkJoin(...deletedFiles)
            .subscribe((files) => {
            const                  errors = files
                .filter((file) => file.status === FileUploadStatus.Error);
            if (errors.length) {
                this.notifyError(...errors);
            }
            this.uploadService.cancelUpload(...files);
        });
    }
    isUploadCompleted() {
        return !this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files
                .some(({ status }) => status === FileUploadStatus.Starting ||
                status === FileUploadStatus.Progress ||
                status === FileUploadStatus.Pending);
    }
    isUploadCancelled() {
        return !!this.files.length &&
            this.files
                .every(({ status }) => status === FileUploadStatus.Aborted ||
                status === FileUploadStatus.Cancelled ||
                status === FileUploadStatus.Deleted);
    }
    deleteNode(file) {
        const { id } = file.data.entry;
        return this.nodesApi
            .deleteNode(id, { permanent: true })
            .map(() => {
            file.status = FileUploadStatus.Deleted;
            return file;
        })
            .catch((error) => {
            file.status = FileUploadStatus.Error;
            return Observable.of(file);
        });
    }
    notifyError(...files) {
        let                  messageError = null;
        if (files.length === 1) {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        this.error.emit(messageError);
    }
    getUploadingFiles() {
        return this.files.filter((item) => {
            if (item.status === FileUploadStatus.Pending ||
                item.status === FileUploadStatus.Progress ||
                item.status === FileUploadStatus.Starting) {
                return item;
            }
        });
    }
}
FileUploadingListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list',
                template: `<div class="upload-list">
    <ng-template
        ngFor
        [ngForOf]="files"
        [ngForTemplate]="template">
    </ng-template>
</div>
`,
                styles: [`:host{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}`]
            },] },
];
FileUploadingListComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: NodesApiService, },
    { type: TranslationService, },
];
FileUploadingListComponent.propDecorators = {
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
    "files": [{ type: Input },],
    "error": [{ type: Output },],
};

class FileUploadingDialogComponent {
    constructor(uploadService, changeDetecor) {
        this.uploadService = uploadService;
        this.changeDetecor = changeDetecor;
        this.position = 'right';
        this.error = new EventEmitter();
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.isDialogMinimized = false;
        this.isConfirmation = false;
    }
    ngOnInit() {
        this.listSubscription = this.uploadService
            .queueChanged.subscribe((fileList) => {
            this.filesUploadingList = fileList;
            if (this.filesUploadingList.length) {
                this.isDialogActive = true;
            }
        });
        this.counterSubscription = Observable
            .merge(this.uploadService.fileUploadComplete, this.uploadService.fileUploadDeleted)
            .subscribe((event) => {
            this.totalCompleted = event.totalComplete;
            this.changeDetecor.detectChanges();
        });
        this.errorSubscription = this.uploadService.fileUploadError
            .subscribe((event) => {
            this.totalErrors = event.totalError;
            this.changeDetecor.detectChanges();
        });
        this.fileUploadSubscription = this.uploadService
            .fileUpload.subscribe(() => {
            this.changeDetecor.detectChanges();
        });
        this.uploadService.fileDeleted.subscribe((objId) => {
            if (this.filesUploadingList) {
                let                  file = this.filesUploadingList.find((item) => {
                    return item.data.entry.id === objId;
                });
                if (file) {
                    file.status = FileUploadStatus.Cancelled;
                    this.changeDetecor.detectChanges();
                }
            }
        });
    }
    toggleConfirmation() {
        this.isConfirmation = !this.isConfirmation;
        if (this.isDialogMinimized) {
            this.isDialogMinimized = false;
        }
    }
    cancelAllUploads() {
        this.toggleConfirmation();
        this.uploadList.cancelAllFiles();
    }
    toggleMinimized() {
        this.isDialogMinimized = !this.isDialogMinimized;
        this.changeDetecor.detectChanges();
    }
    close() {
        this.isConfirmation = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.isDialogMinimized = false;
        this.uploadService.clearQueue();
        this.changeDetecor.detectChanges();
    }
    ngOnDestroy() {
        this.uploadService.clearQueue();
        this.listSubscription.unsubscribe();
        this.counterSubscription.unsubscribe();
        this.fileUploadSubscription.unsubscribe();
        this.errorSubscription.unsubscribe();
    }
}
FileUploadingDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-dialog, file-uploading-dialog',
                template: `<div *ngIf="isDialogActive"
     class="upload-dialog"
     [class.upload-dialog--minimized]="isDialogMinimized"
     [class.upload-dialog--position-left]="position === 'left'"
     [class.upload-dialog--position-right]="position === 'right'">
    <header class="upload-dialog__header">
        <button
            mat-button
            color="secondary"
            [disabled]="isConfirmation"
            (click)="toggleMinimized()">
            <mat-icon
                mat-list-icon
                title="{{ (isDialogMinimized ? 'ADF_FILE_UPLOAD.BUTTON.MAXIMIZE': 'ADF_FILE_UPLOAD.BUTTON.MINIMIZE') | translate }}">
                    {{ isDialogMinimized ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}
            </mat-icon>
        </button>

        <span
            class="upload-dialog__title"
            *ngIf="!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()">
            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_PROGRESS'
                | translate: {
                    completed: totalCompleted,
                    total: filesUploadingList.length
                }
            }}
        </span>

        <span
            class="upload-dialog__title"
            *ngIf="uploadList.isUploadCompleted()">
            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_COMPLETED'
                | translate: {
                    completed: totalCompleted,
                    total: filesUploadingList.length
                }
            }}
        </span>

        <span
            class="upload-dialog__title"
            *ngIf="uploadList.isUploadCancelled()">
            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_CANCELED' | translate }}
        </span>
    </header>

    <section
        class="upload-dialog__info"
        *ngIf="totalErrors">
        {{
            (totalErrors > 1
                 ? 'FILE_UPLOAD.MESSAGES.UPLOAD_ERRORS'
                 : 'FILE_UPLOAD.MESSAGES.UPLOAD_ERROR')
                 | translate: { total: totalErrors }
        }}
    </section>

    <section
        class="upload-dialog__content"
        [class.upload-dialog--padding]="isConfirmation">
        <adf-file-uploading-list
            (error)="onError($event)"
            [class.upload-dialog--hide]="isConfirmation"
            #uploadList
            [files]="filesUploadingList">
                <ng-template let-file="$implicit">
                     <adf-file-uploading-list-row
                        [file]="file"
                        (remove)="uploadList.removeFile(file)"
                        (cancel)="uploadList.cancelFile(file)">
                    </adf-file-uploading-list-row>
                </ng-template>
        </adf-file-uploading-list>

        <div
            class="upload-dialog__confirmation"
            [class.upload-dialog--hide]="!isConfirmation">
                <p class="upload-dialog__confirmation--title">
                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TITLE' | translate }}
                </p>

                <p class="upload-dialog__confirmation--text">
                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TEXT' | translate }}
                </p>
        </div>
    </section>

    <footer
        class="upload-dialog__actions"
        [class.upload-dialog--hide]="isConfirmation">
        <button
            color="primary"
            mat-button
            *ngIf="!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()"
            (click)="toggleConfirmation()">
            {{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_ALL' | translate }}
        </button>

        <button
            *ngIf="uploadList.isUploadCompleted() || uploadList.isUploadCancelled()"
            mat-button
            color="primary"
            (click)="close($event)">
            {{ 'ADF_FILE_UPLOAD.BUTTON.CLOSE' | translate }}
        </button>
    </footer>

    <footer
        class="upload-dialog__actions"
        [class.upload-dialog--hide]="!isConfirmation">
        <button
            color="secondary"
            mat-button
            (click)="cancelAllUploads()">
            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CANCEL' | translate }}
        </button>

        <button
            mat-button
            color="primary"
            (click)="toggleConfirmation()">
            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CONTINUE' | translate }}
        </button>
    </footer>
</div>
`,
                styles: [``]
            },] },
];
FileUploadingDialogComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: ChangeDetectorRef, },
];
FileUploadingDialogComponent.propDecorators = {
    "uploadList": [{ type: ViewChild, args: ['uploadList',] },],
    "position": [{ type: Input },],
    "error": [{ type: Output },],
};

class FileUploadingListRowComponent {
    constructor() {
        this.cancel = new EventEmitter();
        this.remove = new EventEmitter();
        this.FileUploadStatus = FileUploadStatus;
    }
    onCancel(file) {
        this.cancel.emit(file);
    }
    onRemove(file) {
        this.remove.emit(file);
    }
}
FileUploadingListRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list-row',
                template: `<div class="adf-file-uploading-row">
    <mat-icon
        mat-list-icon
        class="adf-file-uploading-row__type">
        insert_drive_file
    </mat-icon>

    <span
        class="adf-file-uploading-row__name"
        title="{{ file.name }}">
        {{ file.name }}
    </span>

    <div
        *ngIf="file.status === FileUploadStatus.Progress || file.status === FileUploadStatus.Starting"
        (click)="onCancel(file)"
        class="adf-file-uploading-row__group adf-file-uploading-row__group--toggle"
        title="{{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_FILE' | translate }}">
        <span class="adf-file-uploading-row__status">
            {{ file.progress.loaded | adfFileSize }} / {{ file.progress.total | adfFileSize }}
        </span>

        <mat-icon
            mat-list-icon
            class="adf-file-uploading-row__action adf-file-uploading-row__action--cancel">
            clear
        </mat-icon>
    </div>

    <div
        *ngIf="file.status === FileUploadStatus.Complete"
        (click)="onRemove(file)"
        class="adf-file-uploading-row__group adf-file-uploading-row__group--toggle"
        title="{{ 'ADF_FILE_UPLOAD.BUTTON.REMOVE_FILE' | translate }}">
        <mat-icon
            mat-list-icon
            class="adf-file-uploading-row__status adf-file-uploading-row__status--done">
            check_circle
        </mat-icon>

        <mat-icon
            mat-list-icon
            class="adf-file-uploading-row__action adf-file-uploading-row__action--remove">
            remove_circle
        </mat-icon>
    </div>

    <div
        *ngIf="file.status === FileUploadStatus.Pending"
        (click)="onCancel(file)"
        class="adf-file-uploading-row__group adf-file-uploading-row__group--toggle">
        <mat-icon
            mat-list-icon
            class="adf-file-uploading-row__status adf-file-uploading-row__status--pending">
            schedule
        </mat-icon>

        <mat-icon
            mat-list-icon
            class="adf-file-uploading-row__action adf-file-uploading-row__action--remove">
            remove_circle
        </mat-icon>
    </div>

    <div
        *ngIf="file.status === FileUploadStatus.Error"
        class="adf-file-uploading-row__block adf-file-uploading-row__status--error"
        title="{{ file.response }}">
        <mat-icon mat-list-icon>
            report_problem
        </mat-icon>
    </div>

    <div
        *ngIf="file.status === FileUploadStatus.Cancelled  ||
            file.status === FileUploadStatus.Aborted ||
            file.status === FileUploadStatus.Deleted"
        class="adf-file-uploading-row__block adf-file-uploading-row__status--cancelled">
        {{ 'ADF_FILE_UPLOAD.STATUS.FILE_CANCELED_STATUS' | translate }}
    </div>
<div>`,
                styles: [``]
            },] },
];
FileUploadingListRowComponent.ctorParameters = () => [];
FileUploadingListRowComponent.propDecorators = {
    "file": [{ type: Input },],
    "cancel": [{ type: Output },],
    "remove": [{ type: Output },],
};

class UploadBase {
    constructor() {
        this.acceptedFilesType = '*';
    }
    isFileAcceptable(file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        const                  allowedExtensions = this.acceptedFilesType
            .split(',')
            .map(ext => ext.replace(/^\./, ''));
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    }
}
UploadBase.propDecorators = {
    "acceptedFilesType": [{ type: Input },],
};

class UploadButtonComponent extends UploadBase {
    constructor(uploadService, contentService, translateService, logService) {
        super();
        this.uploadService = uploadService;
        this.contentService = contentService;
        this.translateService = translateService;
        this.logService = logService;
        this.disabled = false;
        this.uploadFolders = false;
        this.multipleFiles = false;
        this.versioning = false;
        this.tooltip = null;
        this.rootFolderId = '-root-';
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.createFolder = new EventEmitter();
        this.permissionEvent = new EventEmitter();
        this.hasPermission = false;
        this.permissionValue = new Subject();
    }
    ngOnInit() {
        this.permissionValue.subscribe((permission) => {
            this.hasPermission = permission;
        });
    }
    ngOnChanges(changes) {
        let                  rootFolderId = changes['rootFolderId'];
        if (rootFolderId && rootFolderId.currentValue) {
            this.checkPermission();
        }
    }
    isButtonDisabled() {
        return this.disabled ? true : undefined;
    }
    onFilesAdded($event) {
        let                  files = FileUtils.toFileArray($event.currentTarget.files);
        if (this.hasPermission) {
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        $event.target.value = '';
    }
    onDirectoryAdded($event) {
        if (this.hasPermission) {
            let                  files = FileUtils.toFileArray($event.currentTarget.files);
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        $event.target.value = '';
    }
    uploadFiles(files) {
        const                  latestFilesAdded = files
            .map(this.createFileModel.bind(this))
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        if (latestFilesAdded.length > 0) {
            this.uploadService.addToQueue(...latestFilesAdded);
            this.uploadService.uploadFilesInTheQueue(this.success);
        }
    }
    createFileModel(file) {
        return new FileModel(file, {
            newVersion: this.versioning,
            parentId: this.rootFolderId,
            path: (file.webkitRelativePath || '').replace(/\/[^\/]*$/, '')
        });
    }
    isFileSizeAcceptable(file) {
        let                  acceptableSize = true;
        if (this.isFileSizeAllowed(file)) {
            acceptableSize = false;
            this.translateService.get('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name }).subscribe((message) => {
                this.error.emit(message);
            });
        }
        return acceptableSize;
    }
    isFileSizeAllowed(file) {
        return this.isMaxFileSizeDefined() && this.isFileSizeCorrect(file);
    }
    isMaxFileSizeDefined() {
        return this.maxFilesSize !== undefined && this.maxFilesSize !== null;
    }
    isFileSizeCorrect(file) {
        return this.maxFilesSize < 0 || file.size > this.maxFilesSize;
    }
    checkPermission() {
        if (this.rootFolderId) {
            let                  opts = {
                includeSource: true,
                include: ['allowableOperations']
            };
            this.contentService.getNode(this.rootFolderId, opts).subscribe(res => this.permissionValue.next(this.hasCreatePermission(res.entry)), error => this.error.emit(error));
        }
    }
    hasCreatePermission(node) {
        if (node && node.allowableOperations) {
            return node.allowableOperations.find(permission => permission === 'create') ? true : false;
        }
        return false;
    }
}
UploadButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-button',
                template: `<form class="adf-upload-button-file-container">
    <!--Files Upload-->
    <a *ngIf="!uploadFolders"
        [disabled]="isButtonDisabled()"
        mat-raised-button color="primary">
        <mat-icon>file_upload</mat-icon>

        <!--Multiple Files Upload-->
        <span *ngIf="multipleFiles">
            <label
                id="upload-multiple-file-label"
                *ngIf="!staticTitle"
                for="upload-multiple-files">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>
            <label
                id="upload-multiple-file-label-static"
                *ngIf="staticTitle"
                for="upload-multiple-files">{{ staticTitle }}</label>
            <input #uploadFiles
                id="upload-multiple-files"
                data-automation-id="upload-multiple-files"
                type="file"
                name="uploadFiles"
                multiple="multiple"
                accept="{{acceptedFilesType}}"
                [attr.disabled]="isButtonDisabled()"
                [title]="tooltip"
                (change)="onFilesAdded($event)">
        </span>

        <!--Single Files Upload-->
        <span *ngIf="!multipleFiles">
            <label
                id="upload-single-file-label"
                *ngIf="!staticTitle"
                for="upload-single-file">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>
            <label
                id="upload-single-file-label-static"
                *ngIf="staticTitle"
                for="upload-single-file">{{ staticTitle }}</label>
            <input #uploadFiles
                id="upload-single-file"
                data-automation-id="upload-single-file"
                type="file"
                name="uploadFiles"
                accept="{{acceptedFilesType}}"
                [attr.disabled]="isButtonDisabled()"
                [title]="tooltip"
                (change)="onFilesAdded($event)">
        </span>
    </a>

    <!--Folders Upload-->
    <a *ngIf="uploadFolders"
        [disabled]="isButtonDisabled()" mat-raised-button color="primary">
        <mat-icon>file_upload</mat-icon>
        <label
            id="uploadFolder-label"
            *ngIf="!staticTitle"
            for="uploadFolder">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>
        <label
            id="uploadFolder-label-static"
            *ngIf="staticTitle"
            for="uploadFolder">{{ staticTitle }}</label>
        <input #uploadFolders
            id="uploadFolder"
            data-automation-id="uploadFolder"
            type="file"
            name="uploadFiles"
            multiple="multiple"
            accept="{{acceptedFilesType}}"
            webkitdirectory directory
            [attr.disabled]="isButtonDisabled()"
            [title]="tooltip"
            (change)="onDirectoryAdded($event)">
    </a>
</form>
`,
                styles: [`.adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}`],
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadButtonComponent) }
                ],
                encapsulation: ViewEncapsulation.None
            },] },
];
UploadButtonComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: ContentService, },
    { type: TranslationService, },
    { type: LogService, },
];
UploadButtonComponent.propDecorators = {
    "disabled": [{ type: Input },],
    "uploadFolders": [{ type: Input },],
    "multipleFiles": [{ type: Input },],
    "versioning": [{ type: Input },],
    "maxFilesSize": [{ type: Input },],
    "staticTitle": [{ type: Input },],
    "tooltip": [{ type: Input },],
    "rootFolderId": [{ type: Input },],
    "success": [{ type: Output },],
    "error": [{ type: Output },],
    "createFolder": [{ type: Output },],
    "permissionEvent": [{ type: Output },],
};

class UploadVersionButtonComponent extends UploadButtonComponent {
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes['acceptedFilesType']) {
            const                  message = this.translateService.instant('FILE_UPLOAD.VERSION.MESSAGES.NO_ACCEPTED_FILE_TYPES');
            this.logService.error(message);
        }
        this.acceptedFilesType = '.' + this.node.name.split('.').pop();
    }
    createFileModel(file) {
        const                  fileModel = super.createFileModel(file);
        fileModel.options.newVersionBaseName = this.node.name;
        if (!this.isFileAcceptable(fileModel)) {
            const                  message = this.translateService.instant('FILE_UPLOAD.VERSION.MESSAGES.INCOMPATIBLE_VERSION');
            this.error.emit(message);
        }
        return fileModel;
    }
}
UploadVersionButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-version-button',
                template: `<form class="adf-upload-button-file-container">
    <!--Files Upload-->
    <a *ngIf="!uploadFolders"
        [disabled]="isButtonDisabled()"
        mat-raised-button color="primary">
        <mat-icon>file_upload</mat-icon>

        <!--Multiple Files Upload-->
        <span *ngIf="multipleFiles">
            <label
                id="upload-multiple-file-label"
                *ngIf="!staticTitle"
                for="upload-multiple-files">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>
            <label
                id="upload-multiple-file-label-static"
                *ngIf="staticTitle"
                for="upload-multiple-files">{{ staticTitle }}</label>
            <input #uploadFiles
                id="upload-multiple-files"
                data-automation-id="upload-multiple-files"
                type="file"
                name="uploadFiles"
                multiple="multiple"
                accept="{{acceptedFilesType}}"
                [attr.disabled]="isButtonDisabled()"
                [title]="tooltip"
                (change)="onFilesAdded($event)">
        </span>

        <!--Single Files Upload-->
        <span *ngIf="!multipleFiles">
            <label
                id="upload-single-file-label"
                *ngIf="!staticTitle"
                for="upload-single-file">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>
            <label
                id="upload-single-file-label-static"
                *ngIf="staticTitle"
                for="upload-single-file">{{ staticTitle }}</label>
            <input #uploadFiles
                id="upload-single-file"
                data-automation-id="upload-single-file"
                type="file"
                name="uploadFiles"
                accept="{{acceptedFilesType}}"
                [attr.disabled]="isButtonDisabled()"
                [title]="tooltip"
                (change)="onFilesAdded($event)">
        </span>
    </a>

    <!--Folders Upload-->
    <a *ngIf="uploadFolders"
        [disabled]="isButtonDisabled()" mat-raised-button color="primary">
        <mat-icon>file_upload</mat-icon>
        <label
            id="uploadFolder-label"
            *ngIf="!staticTitle"
            for="uploadFolder">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>
        <label
            id="uploadFolder-label-static"
            *ngIf="staticTitle"
            for="uploadFolder">{{ staticTitle }}</label>
        <input #uploadFolders
            id="uploadFolder"
            data-automation-id="uploadFolder"
            type="file"
            name="uploadFiles"
            multiple="multiple"
            accept="{{acceptedFilesType}}"
            webkitdirectory directory
            [attr.disabled]="isButtonDisabled()"
            [title]="tooltip"
            (change)="onDirectoryAdded($event)">
    </a>
</form>
`,
                styles: [`.adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}`],
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadVersionButtonComponent) }
                ],
                encapsulation: ViewEncapsulation.None
            },] },
];
UploadVersionButtonComponent.ctorParameters = () => [];
UploadVersionButtonComponent.propDecorators = {
    "node": [{ type: Input },],
};

class UploadDragAreaComponent extends UploadBase {
    constructor(uploadService, translateService, notificationService) {
        super();
        this.uploadService = uploadService;
        this.translateService = translateService;
        this.notificationService = notificationService;
        this.disabled = false;
        this.versioning = false;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
    }
    onFilesDropped(files) {
        if (!this.disabled && files.length) {
            const                  fileModels = files.map(file => new FileModel(file, {
                newVersion: this.versioning,
                path: '/',
                parentId: this.parentId
            })).filter(this.isFileAcceptable.bind(this));
            this.addNodeInUploadQueue(fileModels);
        }
    }
    onFilesEntityDropped(item) {
        if (!this.disabled) {
            item.file((file) => {
                const                  fileModel = new FileModel(file, {
                    newVersion: this.versioning,
                    parentId: this.parentId,
                    path: item.fullPath.replace(item.name, '')
                });
                if (this.isFileAcceptable(fileModel)) {
                    this.addNodeInUploadQueue([fileModel]);
                }
            });
        }
    }
    onFolderEntityDropped(folder) {
        if (!this.disabled && folder.isDirectory) {
            FileUtils.flattern(folder).then(entries => {
                let                  files = entries.map(entry => {
                    return new FileModel(entry.file, {
                        newVersion: this.versioning,
                        parentId: this.parentId,
                        path: entry.relativeFolder
                    });
                }).filter(this.isFileAcceptable.bind(this));
                this.addNodeInUploadQueue(files);
            });
        }
    }
    addNodeInUploadQueue(files) {
        if (files.length) {
            this.uploadService.addToQueue(...files);
            this.uploadService.uploadFilesInTheQueue(this.success);
            this.uploadService.fileUploadError.subscribe((error) => {
                this.error.emit(error);
            });
        }
    }
    showUndoNotificationBar(latestFilesAdded) {
        let                  messageTranslate,                  actionTranslate;
        messageTranslate = this.translateService.get('FILE_UPLOAD.MESSAGES.PROGRESS');
        actionTranslate = this.translateService.get('FILE_UPLOAD.ACTION.UNDO');
        this.notificationService.openSnackMessageAction(messageTranslate.value, actionTranslate.value, 3000).onAction().subscribe(() => {
            this.uploadService.cancelUpload(...latestFilesAdded);
        });
    }
    isDroppable() {
        return !this.disabled;
    }
    onUploadFiles(event) {
        event.stopPropagation();
        event.preventDefault();
        let                  isAllowed = this.hasCreatePermission(event.detail.data.obj.entry);
        if (isAllowed) {
            let                  files = event.detail.files;
            if (files && files.length > 0) {
                let                  parentId = this.parentId;
                if (event.detail.data && event.detail.data.obj.entry.isFolder) {
                    parentId = event.detail.data.obj.entry.id || this.parentId;
                }
                const                  fileModels = files.map(fileInfo => new FileModel(fileInfo.file, {
                    newVersion: this.versioning,
                    path: fileInfo.relativeFolder,
                    parentId: parentId
                })).filter(this.isFileAcceptable.bind(this));
                this.addNodeInUploadQueue(fileModels);
            }
        }
    }
    hasCreatePermission(node) {
        let                  isPermitted = false;
        if (node && node['allowableOperations']) {
            let                  permFound = node['allowableOperations'].find(element => element === 'create');
            isPermitted = permFound ? true : false;
        }
        return isPermitted;
    }
}
UploadDragAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-drag-area',
                template: `<div [file-draggable]="isDroppable()" id="UploadBorder" class="upload-border"
     (filesDropped)="onFilesDropped($event)"
     (filesEntityDropped)="onFilesEntityDropped($event)"
     (folderEntityDropped)="onFolderEntityDropped($event)"
     (upload-files)="onUploadFiles($event)"
     dropzone="" webkitdropzone="*" #droparea>
    <ng-content></ng-content>
</div>
`,
                styles: [`adf-upload-drag-area{overflow:hidden}.upload-border{vertical-align:middle;text-align:center;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.file-draggable__input-focus{color:#2196f3;border:1px dashed #2196f3}`],
                host: { 'class': 'adf-upload-drag-area' },
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadDragAreaComponent) }
                ],
                encapsulation: ViewEncapsulation.None
            },] },
];
UploadDragAreaComponent.ctorParameters = () => [
    { type: UploadService, },
    { type: TranslationService, },
    { type: NotificationService, },
];
UploadDragAreaComponent.propDecorators = {
    "disabled": [{ type: Input },],
    "versioning": [{ type: Input },],
    "parentId": [{ type: Input },],
    "success": [{ type: Output },],
    "error": [{ type: Output },],
};

class FileDraggableDirective {
    constructor(el, ngZone) {
        this.ngZone = ngZone;
        this.enabled = true;
        this.filesDropped = new EventEmitter();
        this.filesEntityDropped = new EventEmitter();
        this.folderEntityDropped = new EventEmitter();
        this.cssClassName = 'file-draggable__input-focus';
        this.element = el.nativeElement;
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
            this.element.addEventListener('dragover', this.onDragOver.bind(this));
            this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
            this.element.addEventListener('drop', this.onDropFiles.bind(this));
        });
    }
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDropFiles);
    }
    onDropFiles(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            let                  items = event.dataTransfer.items;
            if (items) {
                for (let                  i = 0; i < items.length; i++) {
                    if (typeof items[i].webkitGetAsEntry !== 'undefined') {
                        let                  item = items[i].webkitGetAsEntry();
                        if (item) {
                            if (item.isFile) {
                                this.filesEntityDropped.emit(item);
                            }
                            else if (item.isDirectory) {
                                this.folderEntityDropped.emit(item);
                            }
                        }
                    }
                    else {
                        let                  files = FileUtils.toFileArray(event.dataTransfer.files);
                        this.filesDropped.emit(files);
                    }
                }
            }
            else {
                let                  files = FileUtils.toFileArray(event.dataTransfer.files);
                this.filesDropped.emit(files);
            }
            this.element.classList.remove(this.cssClassName);
        }
    }
    onDragEnter(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    onDragLeave(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.remove(this.cssClassName);
        }
    }
    onDragOver(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    preventDefault(event) {
        event.stopPropagation();
        event.preventDefault();
    }
}
FileDraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[file-draggable]'
            },] },
];
FileDraggableDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
];
FileDraggableDirective.propDecorators = {
    "enabled": [{ type: Input, args: ['file-draggable',] },],
    "filesDropped": [{ type: Output },],
    "filesEntityDropped": [{ type: Output },],
    "folderEntityDropped": [{ type: Output },],
};

class UploadModule {
}
UploadModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    PipeModule
                ],
                declarations: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ],
                exports: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ]
            },] },
];
UploadModule.ctorParameters = () => [];

class DocumentListModule {
}
DocumentListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ToolbarModule,
                    CommonModule,
                    DataTableModule,
                    FlexLayoutModule,
                    MaterialModule,
                    UploadModule,
                    TranslateModule,
                    PaginationModule
                ],
                declarations: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ],
                providers: [
                    DocumentListService,
                    FolderActionsService,
                    DocumentActionsService,
                    NodeActionsService,
                    CustomResourcesService
                ],
                exports: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ]
            },] },
];
DocumentListModule.ctorParameters = () => [];

class SearchQueryBuilderService {
    constructor(appConfig, api) {
        this.api = api;
        this.updated = new Subject();
        this.executed = new Subject();
        this.categories = [];
        this.queryFragments = {};
        this.fields = {};
        this.filterQueries = [];
        this.ranges = {};
        this.paging = null;
        this.config = appConfig.get('search');
        if (!this.config) {
            throw new Error('Search configuration not found.');
        }
        if (this.config.query && this.config.query.categories) {
            this.categories = this.config.query.categories.filter(f => f.enabled);
        }
        this.filterQueries = this.config.filterQueries || [];
        this.scope = {
            locations: null
        };
    }
    addFilterQuery(query) {
        if (query) {
            const                  existing = this.filterQueries.find(q => q.query === query);
            if (!existing) {
                this.filterQueries.push({ query: query });
            }
        }
    }
    removeFilterQuery(query) {
        if (query) {
            this.filterQueries = this.filterQueries.filter(f => f.query !== query);
        }
    }
    getFacetQuery(label) {
        if (label) {
            const                  queries = this.config.facetQueries || [];
            return queries.find(q => q.label === label);
        }
        return null;
    }
    update() {
        const                  query = this.buildQuery();
        this.updated.next(query);
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const                  query = this.buildQuery();
            const                  data = yield this.api.searchApi.search(query);
            this.executed.next(data);
        });
    }
    buildQuery() {
        let                  query = '';
        const                  fields = [];
        this.categories.forEach(facet => {
            const                  customQuery = this.queryFragments[facet.id];
            if (customQuery) {
                if (query.length > 0) {
                    query += ' AND ';
                }
                query += `(${customQuery})`;
            }
            const                  customFields = this.fields[facet.id];
            if (customFields && customFields.length > 0) {
                for (const                  field of customFields) {
                    if (!fields.includes(field)) {
                        fields.push(field);
                    }
                }
            }
        });
        if (query) {
            const                  result = {
                query: {
                    query: query,
                    language: 'afts'
                },
                include: ['path', 'allowableOperations'],
                fields: fields,
                paging: this.paging,
                filterQueries: this.filterQueries,
                facetQueries: this.config.facetQueries,
                facetFields: this.config.facetFields,
                limits: this.config.limits,
                scope: this.scope
            };
            return result;
        }
        return null;
    }
}
SearchQueryBuilderService.decorators = [
    { type: Injectable },
];
SearchQueryBuilderService.ctorParameters = () => [
    { type: AppConfigService, },
    { type: AlfrescoApiService, },
];

class SearchComponent {
    constructor(searchService, _elementRef) {
        this.searchService = searchService;
        this._elementRef = _elementRef;
        this.displayWith = null;
        this.maxResults = 20;
        this.skipResults = 0;
        this.searchTerm = '';
        this.resultLoaded = new EventEmitter();
        this.error = new EventEmitter();
        this.showPanel = false;
        this._isOpen = false;
        this.keyPressedStream = new Subject();
        this._classList = {};
        this.keyPressedStream.asObservable()
            .debounceTime(200)
            .subscribe((searchedWord) => {
            this.loadSearchResults(searchedWord);
        });
        searchService.dataLoaded.subscribe(data => this.onSearchDataLoaded(data), error => this.onSearchDataError(error));
    }
    set classList(classList) {
        if (classList && classList.length) {
            classList.split(' ').forEach(className => this._classList[className.trim()] = true);
            this._elementRef.nativeElement.className = '';
        }
    }
    get isOpen() {
        return this._isOpen && this.showPanel;
    }
    set isOpen(value) {
        this._isOpen = value;
    }
    ngAfterContentInit() {
        this.setVisibility();
    }
    ngOnChanges(changes) {
        if (changes.queryBody &&
            this.hasDifferentQueryBody(changes.queryBody.previousValue, changes.queryBody.currentValue)) {
            this.loadSearchResults();
        }
        if (changes.searchTerm && changes.searchTerm.currentValue) {
            this.loadSearchResults(changes.searchTerm.currentValue);
        }
    }
    resetResults() {
        this.cleanResults();
        this.setVisibility();
    }
    reload() {
        this.loadSearchResults(this.searchTerm);
    }
    hasDifferentQueryBody(previousQueryBody, currentQueryBody) {
        return JSON.stringify(previousQueryBody) !== JSON.stringify(currentQueryBody);
    }
    cleanResults() {
        if (this.results) {
            this.results = {};
        }
    }
    loadSearchResults(searchTerm) {
        this.resetResults();
        if (searchTerm) {
            if (this.queryBody) {
                this.searchService.searchByQueryBody(this.queryBody).subscribe(result => this.onSearchDataLoaded(result), err => this.onSearchDataError(err));
            }
            else {
                this.searchService.search(searchTerm, this.maxResults, this.skipResults).subscribe(result => this.onSearchDataLoaded(result), err => this.onSearchDataError(err));
            }
        }
        else {
            this.cleanResults();
        }
    }
    onSearchDataLoaded(data) {
        if (data) {
            this.results = data;
            this.resultLoaded.emit(this.results);
            this.isOpen = true;
            this.setVisibility();
        }
    }
    onSearchDataError(error) {
        if (error && error.status !== 400) {
            this.results = null;
            this.error.emit(error);
        }
    }
    hidePanel() {
        if (this.isOpen) {
            this._classList['adf-search-show'] = false;
            this._classList['adf-search-hide'] = true;
            this.isOpen = false;
        }
    }
    setVisibility() {
        this.showPanel = !!this.results && !!this.results.list;
        this._classList['adf-search-show'] = this.showPanel;
        this._classList['adf-search-hide'] = !this.showPanel;
    }
}
SearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search',
                template: `<div role="listbox" id="adf-search-results-content" [ngClass]="_classList" #panel>
    <ng-template
        [ngTemplateOutlet]="template"
        [ngTemplateOutletContext]="{ $implicit: results }">
    </ng-template>
</div>


`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                exportAs: 'searchAutocomplete',
                host: {
                    'class': 'adf-search'
                }
            },] },
];
SearchComponent.ctorParameters = () => [
    { type: SearchService, },
    { type: ElementRef, },
];
SearchComponent.propDecorators = {
    "panel": [{ type: ViewChild, args: ['panel',] },],
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
    "displayWith": [{ type: Input },],
    "maxResults": [{ type: Input },],
    "skipResults": [{ type: Input },],
    "queryBody": [{ type: Input },],
    "searchTerm": [{ type: Input },],
    "classList": [{ type: Input, args: ['class',] },],
    "resultLoaded": [{ type: Output },],
    "error": [{ type: Output },],
};

class EmptySearchResultComponent {
}
EmptySearchResultComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-search-result',
                template: `<div class="adf-empty-search-result">
    <ng-content></ng-content>
</div>
`,
                encapsulation: ViewEncapsulation.None
            },] },
];
EmptySearchResultComponent.ctorParameters = () => [];

class SearchControlComponent {
    constructor(authService, thumbnailService) {
        this.authService = authService;
        this.thumbnailService = thumbnailService;
        this.expandable = true;
        this.highlight = false;
        this.inputType = 'text';
        this.autocomplete = false;
        this.liveSearchEnabled = true;
        this.liveSearchMaxResults = 5;
        this.submit = new EventEmitter();
        this.searchChange = new EventEmitter();
        this.optionClicked = new EventEmitter();
        this.searchTerm = '';
        this.noSearchResultTemplate = null;
        this.toggleSearch = new Subject();
        this.focusSubject = new Subject();
        this.toggleSearch.asObservable().pipe(debounceTime(200)).subscribe(() => {
            if (this.expandable) {
                this.subscriptAnimationState = this.subscriptAnimationState === 'inactive' ? 'active' : 'inactive';
                if (this.subscriptAnimationState === 'inactive') {
                    this.searchTerm = '';
                    this.searchAutocomplete.resetResults();
                    if (document.activeElement.id === this.searchInput.nativeElement.id) {
                        this.searchInput.nativeElement.blur();
                    }
                }
            }
        });
    }
    applySearchFocus(animationDoneEvent) {
        if (animationDoneEvent.toState === 'active') {
            this.searchInput.nativeElement.focus();
        }
    }
    ngOnInit() {
        this.subscriptAnimationState = this.expandable ? 'inactive' : 'no-animation';
        this.setupFocusEventHandlers();
    }
    isNoSearchTemplatePresent() {
        return this.emptySearchTemplate ? true : false;
    }
    ngOnDestroy() {
        if (this.focusSubject) {
            this.focusSubject.unsubscribe();
            this.focusSubject = null;
        }
        if (this.toggleSearch) {
            this.toggleSearch.unsubscribe();
            this.toggleSearch = null;
        }
    }
    isLoggedIn() {
        return this.authService.isEcmLoggedIn();
    }
    searchSubmit(event) {
        this.submit.emit(event);
        this.toggleSearchBar();
    }
    inputChange(event) {
        this.searchChange.emit(event);
    }
    getAutoComplete() {
        return this.autocomplete ? 'on' : 'off';
    }
    getMimeTypeIcon(node) {
        let                  mimeType;
        if (node.entry.content && node.entry.content.mimeType) {
            mimeType = node.entry.content.mimeType;
        }
        if (node.entry.isFolder) {
            mimeType = 'folder';
        }
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    isSearchBarActive() {
        return this.subscriptAnimationState === 'active' && this.liveSearchEnabled;
    }
    toggleSearchBar() {
        if (this.toggleSearch) {
            this.toggleSearch.next();
        }
    }
    elementClicked(item) {
        if (item.entry) {
            this.optionClicked.next(item);
            this.toggleSearchBar();
        }
    }
    onFocus($event) {
        this.focusSubject.next($event);
    }
    onBlur($event) {
        this.focusSubject.next($event);
    }
    activateToolbar() {
        if (!this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
    }
    selectFirstResult() {
        if (this.listResultElement && this.listResultElement.length > 0) {
            let                  firstElement =                  (this.listResultElement.first);
            firstElement._getHostElement().focus();
        }
    }
    onRowArrowDown($event) {
        let                  nextElement = this.getNextElementSibling(                 ($event.target));
        if (nextElement) {
            nextElement.focus();
        }
    }
    onRowArrowUp($event) {
        let                  previousElement = this.getPreviousElementSibling(                 ($event.target));
        if (previousElement) {
            previousElement.focus();
        }
        else {
            this.searchInput.nativeElement.focus();
            this.focusSubject.next(new FocusEvent('focus'));
        }
    }
    setupFocusEventHandlers() {
        let                  focusEvents = this.focusSubject.asObservable()
            .debounceTime(50);
        focusEvents.filter(($event) => {
            return this.isSearchBarActive() && ($event.type === 'blur' || $event.type === 'focusout');
        }).subscribe(() => {
            this.toggleSearchBar();
        });
    }
    getNextElementSibling(node) {
        return node.nextElementSibling;
    }
    getPreviousElementSibling(node) {
        return node.previousElementSibling;
    }
}
SearchControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-control',
                template: `<div class="adf-search-container">
    <div *ngIf="isLoggedIn()" [@transitionMessages]="subscriptAnimationState" (@transitionMessages.done)="applySearchFocus($event)">
        <a mat-icon-button
            *ngIf="expandable"
            id="adf-search-button"
            class="adf-search-button"
            (click)="toggleSearchBar($event)"
            (keyup.enter)="toggleSearchBar($event)">
            <mat-icon aria-label="search button">search</mat-icon>
        </a>
        <mat-form-field class="adf-input-form-field-divider">
            <input matInput #searchInput
                [type]="inputType"
                [autocomplete]="getAutoComplete()"
                id="adf-control-input"
                [(ngModel)]="searchTerm"
                (focus)="activateToolbar($event)"
                (blur)="onBlur($event)"
                (keyup.escape)="toggleSearchBar()"
                (keyup.arrowdown)="selectFirstResult()"
                (ngModelChange)="inputChange($event)"
                [searchAutocomplete]="auto"
                (keyup.enter)="searchSubmit($event)">
        </mat-form-field>
    </div>
</div>

<adf-search #search
            #auto="searchAutocomplete"
            class="adf-search-result-autocomplete"
            [maxResults]="liveSearchMaxResults"
            [queryBody]="customQueryBody">
    <ng-template let-data>
        <mat-list *ngIf="isSearchBarActive()" id="autocomplete-search-result-list">
            <mat-list-item
                *ngFor="let item of data?.list?.entries; let idx = index"
                id="result_option_{{idx}}"
                [attr.data-automation-id]="'autocomplete_for_' + item.entry.name"
                [tabindex]="0"
                (focus)="onFocus($event)"
                (blur)="onBlur($event)"
                (keyup.arrowdown)="onRowArrowDown($event)"
                (keyup.arrowup)="onRowArrowUp($event)"
                class="adf-search-autocomplete-item"
                (click)="elementClicked(item)"
                (keyup.enter)="elementClicked(item)">
                <mat-icon mat-list-icon>
                    <img [src]="getMimeTypeIcon(item)" />
                </mat-icon>
                <h4 mat-line id="result_name_{{idx}}"
                    *ngIf="highlight; else elseBlock"
                    class="adf-search-fixed-text"
                    [innerHtml]="item.entry.name | highlight: searchTerm">
                    {{ item?.entry.name }}
                </h4>
                <ng-template #elseBlock>
                    <h4 class="adf-search-fixed-text" mat-line id="result_name_{{idx}}" [innerHtml]="item.entry.name"></h4>
                </ng-template>
                <p mat-line class="adf-search-fixed-text"> {{item?.entry.createdByUser.displayName}} </p>
            </mat-list-item>
            <mat-list-item id="search_no_result"
                data-automation-id="search_no_result_found"
                *ngIf="data?.list?.entries.length === 0">
                <ng-content
                    selector="adf-empty-search-result"
                    *ngIf="isNoSearchTemplatePresent() else defaultNoResult">
                </ng-content>
                <ng-template #defaultNoResult>
                    <p mat-line class="adf-search-fixed-text">{{ 'SEARCH.RESULTS.NONE' | translate:{searchTerm: searchTerm} }}</p>
                </ng-template>
            </mat-list-item>
        </mat-list>
    </ng-template>
</adf-search>
`,
                styles: [``],
                animations: [
                    trigger('transitionMessages', [
                        state('active', style({ transform: 'translateX(0%)', 'margin-left': '13px' })),
                        state('inactive', style({ transform: 'translateX(81%)' })),
                        state('no-animation', style({ transform: 'translateX(0%)', width: '100%' })),
                        transition('inactive => active', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')),
                        transition('active => inactive', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                    ])
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-control' }
            },] },
];
SearchControlComponent.ctorParameters = () => [
    { type: AuthenticationService, },
    { type: ThumbnailService, },
];
SearchControlComponent.propDecorators = {
    "expandable": [{ type: Input },],
    "highlight": [{ type: Input },],
    "inputType": [{ type: Input },],
    "autocomplete": [{ type: Input },],
    "liveSearchEnabled": [{ type: Input },],
    "liveSearchMaxResults": [{ type: Input },],
    "customQueryBody": [{ type: Input },],
    "submit": [{ type: Output },],
    "searchChange": [{ type: Output },],
    "optionClicked": [{ type: Output },],
    "searchAutocomplete": [{ type: ViewChild, args: ['search',] },],
    "searchInput": [{ type: ViewChild, args: ['searchInput',] },],
    "listResultElement": [{ type: ViewChildren, args: [MatListItem,] },],
    "emptySearchTemplate": [{ type: ContentChild, args: [EmptySearchResultComponent,] },],
};

const SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SearchTriggerDirective),
    multi: true
};
class SearchTriggerDirective {
    constructor(element, ngZone, changeDetectorRef, document) {
        this.element = element;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this._panelOpen = false;
        this.escapeEventStream = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    ngOnDestroy() {
        if (this.escapeEventStream) {
            this.escapeEventStream.unsubscribe();
            this.escapeEventStream = null;
        }
        if (this.closingActionsSubscription) {
            this.closingActionsSubscription.unsubscribe();
        }
    }
    get panelOpen() {
        return this._panelOpen && this.searchPanel.showPanel;
    }
    openPanel() {
        this.searchPanel.isOpen = this._panelOpen = true;
        this.closingActionsSubscription = this.subscribeToClosingActions();
    }
    closePanel() {
        if (this._panelOpen) {
            this.closingActionsSubscription.unsubscribe();
            this._panelOpen = false;
            this.searchPanel.resetResults();
            this.searchPanel.hidePanel();
            this.changeDetectorRef.detectChanges();
        }
    }
    get panelClosingActions() {
        return merge(this.escapeEventStream, this.outsideClickStream);
    }
    get outsideClickStream() {
        if (!this.document) {
            return Observable.of(null);
        }
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).filter((event) => {
            const                  clickTarget =                  (event.target);
            return this._panelOpen &&
                clickTarget !== this.element.nativeElement;
        });
    }
    writeValue(value) {
        Promise.resolve(null).then(() => this.setTriggerValue(value));
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    handleKeydown(event) {
        const                  keyCode = event.keyCode;
        if (keyCode === ESCAPE && this.panelOpen) {
            this.escapeEventStream.next();
            event.stopPropagation();
        }
        else if (keyCode === ENTER) {
            this.escapeEventStream.next();
            event.preventDefault();
        }
    }
    handleInput(event) {
        if (document.activeElement === event.target) {
            let                  inputValue = (                 (event.target)).value;
            this.onChange(inputValue);
            if (inputValue) {
                this.searchPanel.keyPressedStream.next(inputValue);
                this.openPanel();
            }
            else {
                this.searchPanel.resetResults();
                this.closePanel();
            }
        }
    }
    isPanelOptionClicked(event) {
        let                  isPanelOption = false;
        if (event) {
            let                  clickTarget =                  (event.target);
            isPanelOption = !this.isNoResultOption(event) &&
                !!this.searchPanel.panel &&
                !!this.searchPanel.panel.nativeElement.contains(clickTarget);
        }
        return isPanelOption;
    }
    isNoResultOption(event) {
        return this.searchPanel.results.list ? this.searchPanel.results.list.entries.length === 0 : true;
    }
    subscribeToClosingActions() {
        const                  firstStable = this.ngZone.onStable.asObservable();
        const                  optionChanges = this.searchPanel.keyPressedStream.asObservable();
        return merge(firstStable, optionChanges)
            .switchMap(() => {
            this.searchPanel.setVisibility();
            return this.panelClosingActions;
        })
            .subscribe(event => this.setValueAndClose(event));
    }
    setTriggerValue(value) {
        const                  toDisplay = this.searchPanel && this.searchPanel.displayWith ?
            this.searchPanel.displayWith(value) : value;
        const                  inputValue = toDisplay != null ? toDisplay : '';
        this.element.nativeElement.value = inputValue;
    }
    setValueAndClose(event) {
        if (this.isPanelOptionClicked(event)) {
            this.setTriggerValue(event.target.textContent.trim());
            this.onChange(event.target.textContent.trim());
            this.element.nativeElement.focus();
        }
        this.closePanel();
    }
}
SearchTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `input[searchAutocomplete], textarea[searchAutocomplete]`,
                host: {
                    'role': 'combobox',
                    'autocomplete': 'off',
                    'aria-autocomplete': 'list',
                    '[attr.aria-expanded]': 'panelOpen.toString()',
                    '[attr.aria-owns]': 'autocomplete?.id',
                    '(blur)': 'onTouched()',
                    '(input)': 'handleInput($event)',
                    '(keydown)': 'handleKeydown($event)'
                },
                providers: [SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR]
            },] },
];
SearchTriggerDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
];
SearchTriggerDirective.propDecorators = {
    "searchPanel": [{ type: Input, args: ['searchAutocomplete',] },],
};

class SearchFilterComponent {
    constructor(queryBuilder, search) {
        this.queryBuilder = queryBuilder;
        this.search = search;
        this.selectedFacetQueries = [];
        this.selectedBuckets = [];
        this.responseFacetQueries = [];
        this.responseFacetFields = [];
        this.queryBuilder.updated.subscribe(query => {
            this.queryBuilder.execute();
        });
    }
    ngOnInit() {
        if (this.queryBuilder) {
            this.queryBuilder.executed.subscribe(data => {
                this.onDataLoaded(data);
                this.search.dataLoaded.next(data);
            });
        }
    }
    onCategoryExpanded(category) {
        category.expanded = true;
    }
    onCategoryCollapsed(category) {
        category.expanded = false;
    }
    onFacetFieldExpanded(field) {
        field.$expanded = true;
    }
    onFacetFieldCollapsed(field) {
        field.$expanded = false;
    }
    onFacetQueryToggle(event, query) {
        const                  facetQuery = this.queryBuilder.getFacetQuery(query.label);
        if (event.checked) {
            query.$checked = true;
            this.selectedFacetQueries.push(facetQuery.label);
            if (facetQuery) {
                this.queryBuilder.addFilterQuery(facetQuery.query);
            }
        }
        else {
            query.$checked = false;
            this.selectedFacetQueries = this.selectedFacetQueries.filter(q => q !== query.label);
            if (facetQuery) {
                this.queryBuilder.removeFilterQuery(facetQuery.query);
            }
        }
        this.queryBuilder.update();
    }
    onFacetToggle(event, field, bucket) {
        if (event.checked) {
            bucket.$checked = true;
            this.selectedBuckets.push(Object.assign({}, bucket));
            this.queryBuilder.addFilterQuery(bucket.filterQuery);
        }
        else {
            bucket.$checked = false;
            const                  idx = this.selectedBuckets.findIndex(b => b.$field === bucket.$field && b.label === bucket.label);
            if (idx >= 0) {
                this.selectedBuckets.splice(idx, 1);
            }
            this.queryBuilder.removeFilterQuery(bucket.filterQuery);
        }
        this.queryBuilder.update();
    }
    unselectFacetQuery(label) {
        const                  facetQuery = this.queryBuilder.getFacetQuery(label);
        this.selectedFacetQueries = this.selectedFacetQueries.filter(q => q !== label);
        this.queryBuilder.removeFilterQuery(facetQuery.query);
        this.queryBuilder.update();
    }
    unselectFacetBucket(bucket) {
        if (bucket) {
            const                  idx = this.selectedBuckets.findIndex(b => b.$field === bucket.$field && b.label === bucket.label);
            if (idx >= 0) {
                this.selectedBuckets.splice(idx, 1);
            }
            this.queryBuilder.removeFilterQuery(bucket.filterQuery);
            this.queryBuilder.update();
        }
    }
    onDataLoaded(data) {
        const                  context = data.list.context;
        if (context) {
            this.responseFacetQueries = (context.facetQueries || []).map(q => {
                q.$checked = this.selectedFacetQueries.includes(q.label);
                return q;
            });
            const                  expandedFields = this.responseFacetFields.filter(f => f.$expanded).map(f => f.label);
            this.responseFacetFields = (context.facetsFields || []).map((field) => {
                field.$expanded = expandedFields.includes(field.label);
                (field.buckets || []).forEach(bucket => {
                    bucket.$field = field.label;
                    bucket.$checked = false;
                    const                  previousBucket = this.selectedBuckets.find(b => b.$field === bucket.$field && b.label === bucket.label);
                    if (previousBucket) {
                        bucket.$checked = true;
                    }
                });
                return field;
            });
        }
        else {
            this.responseFacetQueries = [];
            this.responseFacetFields = [];
        }
    }
}
SearchFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-filter',
                template: `<mat-accordion multi="true" displayMode="flat">

    <mat-expansion-panel
        *ngFor="let category of queryBuilder.categories"
        [expanded]="category.expanded"
        (opened)="onCategoryExpanded(category)"
        (closed)="onCategoryCollapsed(category)">
        <mat-expansion-panel-header>
            <mat-panel-title>
                {{ category.name | translate }}
            </mat-panel-title>
        </mat-expansion-panel-header>
        <adf-search-widget-container
            [id]="category.id"
            [selector]="category.component.selector"
            [settings]="category.component.settings">
        </adf-search-widget-container>
    </mat-expansion-panel>

    <mat-expansion-panel>
        <mat-expansion-panel-header>
            <mat-panel-title>Facet Queries</mat-panel-title>
        </mat-expansion-panel-header>
        <div class="checklist">
            <ng-container *ngFor="let query of responseFacetQueries">
                <mat-checkbox
                    *ngIf="query.count > 0"
                    [checked]="query.$checked"
                    (change)="onFacetQueryToggle($event, query)">
                    {{ query.label }} ({{ query.count }})
                </mat-checkbox>
            </ng-container>
        </div>
    </mat-expansion-panel>

    <mat-expansion-panel
        *ngFor="let field of responseFacetFields"
        [expanded]="field.$expanded"
        (opened)="onFacetFieldExpanded(field)"
        (closed)="onFacetFieldCollapsed(field)">
        <mat-expansion-panel-header>
            <mat-panel-title>{{ field.label }}</mat-panel-title>
        </mat-expansion-panel-header>
        <div class="checklist">
            <mat-checkbox
                *ngFor="let bucket of field.buckets"
                [checked]="bucket.$checked"
                (change)="onFacetToggle($event, field, bucket)">
                {{ bucket.display || bucket.label }} ({{ bucket.count }})
            </mat-checkbox>
        </div>
    </mat-expansion-panel>

</mat-accordion>
`,
                styles: [`.checklist{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.checklist .mat-checkbox{margin:5px}`],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-filter' }
            },] },
];
SearchFilterComponent.ctorParameters = () => [
    { type: SearchQueryBuilderService, },
    { type: SearchService, },
];

class SearchChipListComponent {
}
SearchChipListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-chip-list',
                template: `<mat-chip-list>
    <ng-container *ngIf="searchFilter && searchFilter.selectedFacetQueries">
        <mat-chip
            *ngFor="let label of searchFilter.selectedFacetQueries"
            [removable]="true"
            (remove)="searchFilter.unselectFacetQuery(label)">
            {{ label }}
            <mat-icon matChipRemove>cancel</mat-icon>
        </mat-chip>
    </ng-container>
    <ng-container *ngIf="searchFilter && searchFilter.selectedBuckets">
        <mat-chip
            *ngFor="let bucket of searchFilter.selectedBuckets"
            [removable]="true"
            (remove)="searchFilter.unselectFacetBucket(bucket)">
            {{ bucket.display || bucket.label }}
            <mat-icon matChipRemove>cancel</mat-icon>
        </mat-chip>
    </ng-container>
</mat-chip-list>
`,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-chip-list' }
            },] },
];
SearchChipListComponent.ctorParameters = () => [];
SearchChipListComponent.propDecorators = {
    "searchFilter": [{ type: Input },],
};

class SearchTextComponent {
    constructor() {
        this.value = '';
    }
    ngOnInit() {
        if (this.context && this.settings) {
            const                  pattern = new RegExp(this.settings["pattern"], 'g');
            const                  match = pattern.exec(this.context.queryFragments[this.id] || '');
            if (match && match.length > 1) {
                this.value = match[1];
            }
        }
    }
    onChangedHandler(event) {
        this.value = event.target.value;
        if (this.value) {
            this.context.queryFragments[this.id] = `${this.settings.field}:'${this.value}'`;
            this.context.update();
        }
    }
}
SearchTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-text',
                template: `<mat-form-field>
    <input
        matInput
        [placeholder]="settings?.placeholder"
        [value]="value"
        (change)="onChangedHandler($event)">
</mat-form-field>
`,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-text' }
            },] },
];
SearchTextComponent.ctorParameters = () => [];
SearchTextComponent.propDecorators = {
    "value": [{ type: Input },],
};

class SearchRadioComponent {
    ngOnInit() {
        this.setValue(this.getSelectedValue());
    }
    getSelectedValue() {
        const                  options = this.settings['options'] || [];
        if (options && options.length > 0) {
            let                  selected = options.find(opt => opt.default);
            if (!selected) {
                selected = options[0];
            }
            return selected.value;
        }
        return null;
    }
    setValue(newValue) {
        this.value = newValue;
        this.context.queryFragments[this.id] = newValue;
        this.context.update();
    }
    changeHandler(event) {
        this.setValue(event.value);
    }
}
SearchRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-radio',
                template: `<mat-radio-group [(ngModel)]="value" (change)="changeHandler($event)">
    <mat-radio-button
        *ngFor="let option of settings.options" [value]="option.value">
        {{ option.name }}
    </mat-radio-button>
</mat-radio-group>
`,
                styles: [`.adf-search-radio .mat-radio-group{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.adf-search-radio .mat-radio-button{margin:5px}`],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-radio' }
            },] },
];
SearchRadioComponent.ctorParameters = () => [];
SearchRadioComponent.propDecorators = {
    "value": [{ type: Input },],
};

class SearchFieldsComponent {
    ngOnInit() {
        const                  defaultOptions = (this.settings["options"] || [])
            .filter(opt => opt.default)
            .map(opt => {
            opt.checked = true;
            return opt;
        });
        if (defaultOptions.length > 0) {
            this.flush(defaultOptions);
        }
    }
    changeHandler(event, option) {
        option.checked = event.checked;
        this.flush(this.settings["options"]);
    }
    flush(opts = []) {
        const                  checkedValues = opts
            .filter(v => v.checked)
            .map(v => v.fields)
            .reduce((prev, curr) => {
            return prev.concat(curr);
        }, []);
        this.context.fields[this.id] = checkedValues;
        this.context.update();
    }
}
SearchFieldsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-fields',
                template: `<mat-checkbox
    *ngFor="let option of settings.options"
    [checked]="option.checked"
    (change)="changeHandler($event, option)">
    {{ option.name }}
</mat-checkbox>
`,
                styles: [`.adf-search-fields{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.adf-search-fields .mat-checkbox{margin:5px}`],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-fields' }
            },] },
];
SearchFieldsComponent.ctorParameters = () => [];
SearchFieldsComponent.propDecorators = {
    "value": [{ type: Input },],
};

class SearchScopeLocationsComponent {
    ngOnInit() {
        const                  defaultSelection = (this.settings["options"] || []).find(opt => opt.default);
        if (defaultSelection) {
            this.flush(defaultSelection.value);
        }
    }
    changeHandler(event) {
        this.flush(event.value);
    }
    flush(value) {
        this.value = value;
        this.context.scope.locations = value;
        this.context.update();
    }
}
SearchScopeLocationsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-scope-locations',
                template: `<mat-form-field>
    <mat-select
        [(value)]="value"
        (selectionChange)="changeHandler($event)">
        <mat-option
            *ngFor="let option of settings.options"
            [value]="option.value">
            {{option.name}}
        </mat-option>
    </mat-select>
</mat-form-field>
`,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-scope-locations' }
            },] },
];
SearchScopeLocationsComponent.ctorParameters = () => [];
SearchScopeLocationsComponent.propDecorators = {
    "value": [{ type: Input },],
};

class SearchWidgetsModule {
}
SearchWidgetsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatButtonModule,
                    MatInputModule,
                    MatRadioModule,
                    MatCheckboxModule,
                    MatSelectModule
                ],
                declarations: [
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchFieldsComponent,
                    SearchScopeLocationsComponent
                ],
                exports: [
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchFieldsComponent,
                    SearchScopeLocationsComponent
                ],
                entryComponents: [
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchFieldsComponent,
                    SearchScopeLocationsComponent
                ]
            },] },
];
SearchWidgetsModule.ctorParameters = () => [];

class SearchWidgetContainerComponent {
    constructor(compiler, queryBuilder) {
        this.queryBuilder = queryBuilder;
        this.module = compiler.compileModuleAndAllComponentsSync(SearchWidgetsModule);
    }
    ngOnInit() {
        const                  factory = this.module.componentFactories.find(f => f.selector === this.selector);
        if (factory) {
            this.content.clear();
            this.componentRef = this.content.createComponent(factory, 0);
            this.setupWidget(this.componentRef);
        }
    }
    setupWidget(ref) {
        if (ref && ref.instance) {
            ref.instance.id = this.id;
            ref.instance.settings = Object.assign({}, this.settings);
            ref.instance.context = this.queryBuilder;
        }
    }
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
}
SearchWidgetContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-widget-container',
                template: '<div #content></div>'
            },] },
];
SearchWidgetContainerComponent.ctorParameters = () => [
    { type: Compiler, },
    { type: SearchQueryBuilderService, },
];
SearchWidgetContainerComponent.propDecorators = {
    "content": [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] },],
    "id": [{ type: Input },],
    "selector": [{ type: Input },],
    "settings": [{ type: Input },],
    "config": [{ type: Input },],
};

const ALFRESCO_SEARCH_DIRECTIVES = [
    SearchComponent,
    SearchControlComponent,
    SearchTriggerDirective,
    EmptySearchResultComponent,
    SearchFilterComponent,
    SearchChipListComponent
];
class SearchModule {
}
SearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    PipeModule,
                    TranslateModule
                ],
                declarations: [
                    ...ALFRESCO_SEARCH_DIRECTIVES,
                    SearchWidgetContainerComponent
                ],
                exports: [
                    ...ALFRESCO_SEARCH_DIRECTIVES,
                    SearchWidgetContainerComponent
                ],
                entryComponents: [
                    SearchWidgetContainerComponent
                ]
            },] },
];
SearchModule.ctorParameters = () => [];

const Relations = {
    Members: 'members',
    Containers: 'containers',
};
class DropdownSitesComponent {
    constructor(sitesService, logService) {
        this.sitesService = sitesService;
        this.logService = logService;
        this.hideMyFiles = false;
        this.siteList = null;
        this.value = null;
        this.placeholder = 'DROPDOWN.PLACEHOLDER_LABEL';
        this.change = new EventEmitter();
        this.selected = null;
        this.MY_FILES_VALUE = '-my-';
    }
    ngOnInit() {
        if (!this.siteList) {
            this.setDefaultSiteList();
        }
    }
    selectedSite(event) {
        this.change.emit(event.value);
    }
    setDefaultSiteList() {
        let                  extendedOptions = null;
        if (this.relations) {
            extendedOptions = { relations: [this.relations] };
        }
        this.sitesService.getSites(extendedOptions).subscribe((result) => {
            this.siteList = this.relations === Relations.Members ? this.filteredResultsByMember(result) : result;
            if (!this.hideMyFiles) {
                let                  myItem = { entry: { id: '-my-', guid: '-my-', title: 'DROPDOWN.MY_FILES_OPTION' } };
                this.siteList.list.entries.unshift(myItem);
                if (!this.value) {
                    this.value = '-my-';
                }
            }
            this.selected = this.siteList.list.entries.find(site => site.entry.id === this.value);
        }, (error) => {
            this.logService.error(error);
        });
    }
    filteredResultsByMember(sites) {
        const                  loggedUserName = this.sitesService.getEcmCurrentLoggedUserName();
        sites.list.entries = sites.list.entries.filter((site) => this.isCurrentUserMember(site, loggedUserName));
        return sites;
    }
    isCurrentUserMember(site, loggedUserName) {
        return site.entry.visibility === 'PUBLIC' ||
            !!site.relations.members.list.entries.find((member) => {
                return member.entry.id.toLowerCase() === loggedUserName.toLowerCase();
            });
    }
}
DropdownSitesComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sites-dropdown',
                styles: [`.adf-sites-dropdown.full-width .mat-input-container{width:100%}`],
                template: `<div id="site-dropdown-container" class="adf-site-dropdown-container">
    <mat-form-field>
        <mat-select
            data-automation-id="site-my-files-option"
            class="adf-site-dropdown-list-element"
            id="site-dropdown"
            placeholder="{{placeholder | translate}}"
            floatPlaceholder="never"
            data-automation-id="site-my-files-select"
            [(value)]="selected"
            (selectionChange)="selectedSite($event)">
            <mat-option *ngFor="let site of siteList?.list.entries" [value]="site">
                {{ site.entry.title | translate}}
            </mat-option>
        </mat-select>
    </mat-form-field>
</div>
`,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-sites-dropdown' }
            },] },
];
DropdownSitesComponent.ctorParameters = () => [
    { type: SitesService, },
    { type: LogService, },
];
DropdownSitesComponent.propDecorators = {
    "hideMyFiles": [{ type: Input },],
    "siteList": [{ type: Input },],
    "value": [{ type: Input },],
    "placeholder": [{ type: Input },],
    "relations": [{ type: Input },],
    "change": [{ type: Output },],
};

class SitesDropdownModule {
}
SitesDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                exports: [
                    DropdownSitesComponent
                ],
                declarations: [
                    DropdownSitesComponent
                ]
            },] },
];
SitesDropdownModule.ctorParameters = () => [];

class BreadcrumbComponent {
    constructor() {
        this.folderNode = null;
        this.root = null;
        this.rootId = null;
        this.route = [];
        this.navigate = new EventEmitter();
    }
    get hasRoot() {
        return !!this.root;
    }
    ngOnInit() {
        this.transform = this.transform ? this.transform : null;
    }
    ngOnChanges(changes) {
        if (changes["folderNode"]) {
            let                  node = null;
            node = this.transform ? this.transform(changes["folderNode"].currentValue) : changes["folderNode"].currentValue;
            this.route = this.parseRoute(node);
        }
        if (changes["transform"]) {
            let                  node = this.transform ? this.transform(this.folderNode) : this.folderNode;
            this.route = this.parseRoute(node);
        }
    }
    parseRoute(node) {
        if (node && node.path) {
            const                  route =                  ((node.path.elements || []).slice());
            route.push(                 ({
                id: node.id,
                name: node.name
            }));
            const                  rootPos = this.getElementPosition(route, this.rootId);
            if (rootPos > 0) {
                route.splice(0, rootPos);
            }
            if (rootPos === -1 && this.rootId) {
                route[0].id = this.rootId;
            }
            if (this.root) {
                route[0].name = this.root;
            }
            return route;
        }
        return [];
    }
    getElementPosition(route, nodeId) {
        let                  result = -1;
        if (route && route.length > 0 && nodeId) {
            result = route.findIndex(el => el.id === nodeId);
        }
        return result;
    }
    onRoutePathClick(route, event) {
        if (event) {
            event.preventDefault();
        }
        if (route) {
            this.navigate.emit(route);
            if (this.target) {
                this.target.navigateTo(route.id);
            }
        }
    }
}
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-breadcrumb',
                template: `<div *ngIf="folderNode" data-automation-id="breadcrumb" class="adf-breadcrumb-container">
    <li *ngFor="let item of route; let last = last"
        [class.active]="last"
        [ngSwitch]="last"
        title="{{ item.name | translate }}"
        class="adf-breadcrumb-item">

        <a *ngSwitchDefault href="#" [attr.data-automation-id]="'breadcrumb_' + item.name"
           class="adf-breadcrumb-item-anchor"
           (click)="onRoutePathClick(item, $event)">
            {{ item.name | translate }}
        </a>

        <div *ngSwitchCase="true" class="adf-breadcrumb-item-current">
            {{ item.name | translate }}
        </div>

        <mat-icon class="adf-breadcrumb-item-chevron" *ngIf="!last">
            chevron_right
        </mat-icon>
    </li>
</div>
<div *ngIf="!folderNode && hasRoot">
    <li class="adf-breadcrumb-item">
        <div class="adf-breadcrumb-item-current">
            {{ root | translate }}
        </div>
    </li>
</div>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-breadcrumb'
                }
            },] },
];
BreadcrumbComponent.ctorParameters = () => [];
BreadcrumbComponent.propDecorators = {
    "folderNode": [{ type: Input },],
    "root": [{ type: Input },],
    "rootId": [{ type: Input },],
    "target": [{ type: Input },],
    "transform": [{ type: Input },],
    "navigate": [{ type: Output },],
};

class DropdownBreadcrumbComponent extends BreadcrumbComponent {
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        this.recalculateNodes();
    }
    recalculateNodes() {
        this.currentNode = this.route[this.route.length - 1];
        this.previousNodes = this.route.slice(0, this.route.length - 1).reverse();
    }
    open() {
        if (this.selectbox) {
            this.selectbox.open();
        }
    }
    hasPreviousNodes() {
        return this.previousNodes.length > 0;
    }
}
DropdownBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-breadcrumb',
                template: `<ng-container *ngIf="route.length > 0">

    <button
        tabindex="0"
        class="adf-dropdown-breadcumb-trigger"
        (click)="open()"
        data-automation-id="dropdown-breadcrumb-trigger">
        <mat-icon [class.isRoot]="!hasPreviousNodes()">folder</mat-icon>
    </button>
    <mat-icon class="adf-dropdown-breadcrumb-item-chevron">chevron_right</mat-icon>

    <mat-select
        #select
        *ngIf="hasPreviousNodes()"
        class="adf-dropdown-breadcrumb-path"
        tabindex="0"
        data-automation-id="dropdown-breadcrumb-path" >

        <mat-option
            *ngFor="let node of previousNodes;"
            (click)="onRoutePathClick(node, $event)"
            class="adf-dropdown-breadcrumb-path-option"
            tabindex="0"
            data-automation-class="dropdown-breadcrumb-path-option">
            {{ node.name }}
        </mat-option>
    </mat-select>

    <span
        class="adf-current-folder"
        [class.isRoot]="!hasPreviousNodes()"
        data-automation-id="current-folder">{{ currentNode.name }}</span>
</ng-container>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-dropdown-breadcrumb'
                }
            },] },
];
DropdownBreadcrumbComponent.ctorParameters = () => [];
DropdownBreadcrumbComponent.propDecorators = {
    "selectbox": [{ type: ViewChild, args: ['select',] },],
};

class BreadcrumbModule {
}
BreadcrumbModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                exports: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ],
                declarations: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ]
            },] },
];
BreadcrumbModule.ctorParameters = () => [];

class ConfirmDialogComponent {
    constructor(data) {
        data = data || {};
        this.title = data.title || 'ADF_CONFIRM_DIALOG.CONFIRM';
        this.message = data.message || 'ADF_CONFIRM_DIALOG.MESSAGE';
        this.yesLabel = data.yesLabel || 'ADF_CONFIRM_DIALOG.YES_LABEL';
        this.noLabel = data.noLabel || 'ADF_CONFIRM_DIALOG.NO_LABEL';
    }
}
ConfirmDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-confirm-dialog',
                template: `
        <h1 mat-dialog-title>{{ title | translate }}</h1>
        <mat-dialog-content>
            <p>{{ message | translate }}</p>
        </mat-dialog-content>
        <mat-dialog-actions>
            <span class="spacer"></span>
            <button mat-button [mat-dialog-close]="true">{{ yesLabel | translate }}</button>
            <button mat-button color="primary" [mat-dialog-close]="false" cdkFocusInitial>{{ noLabel | translate }}</button>
        </mat-dialog-actions>
    `,
                styles: [`
        .spacer { flex: 1 1 auto; }

        .adf-confirm-dialog .mat-dialog-actions .mat-button-wrapper {
            text-transform: uppercase;
        }
    `],
                host: { 'class': 'adf-confirm-dialog' },
                encapsulation: ViewEncapsulation.None
            },] },
];
ConfirmDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] },] },
];

class VersionListComponent {
    constructor(alfrescoApi, contentService, dialog, el) {
        this.alfrescoApi = alfrescoApi;
        this.contentService = contentService;
        this.dialog = dialog;
        this.el = el;
        this.versions = [];
        this.isLoading = true;
        this.showComments = true;
        this.allowDownload = true;
        this.versionsApi = this.alfrescoApi.versionsApi;
    }
    ngOnChanges() {
        this.loadVersionHistory();
    }
    canUpdate() {
        return this.contentService.hasPermission(this.node, 'update');
    }
    restore(versionId) {
        if (this.canUpdate()) {
            this.versionsApi
                .revertVersion(this.node.id, versionId, { majorVersion: true, comment: '' })
                .then(() => this.onVersionRestored());
        }
    }
    loadVersionHistory() {
        this.isLoading = true;
        this.versionsApi.listVersionHistory(this.node.id).then((data) => {
            this.versions = data.list.entries;
            this.isLoading = false;
        });
    }
    downloadVersion(versionId) {
        if (this.allowDownload) {
            const                  versionDownloadUrl = this.getVersionContentUrl(this.node.id, versionId, true);
            this.downloadContent(versionDownloadUrl);
        }
    }
    deleteVersion(versionId) {
        if (this.canUpdate()) {
            const                  dialogRef = this.dialog.open(ConfirmDialogComponent, {
                data: {
                    title: 'ADF_VERSION_LIST.CONFIRM_DELETE.TITLE',
                    message: 'ADF_VERSION_LIST.CONFIRM_DELETE.MESSAGE',
                    yesLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.YES_LABEL',
                    noLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.NO_LABEL'
                },
                minWidth: '250px'
            });
            dialogRef.afterClosed().subscribe(result => {
                if (result === true) {
                    this.alfrescoApi.versionsApi
                        .deleteVersion(this.node.id, versionId)
                        .then(() => this.onVersionDeleted());
                }
            });
        }
    }
    onVersionDeleted() {
        this.loadVersionHistory();
        const                  event = new CustomEvent('version-deleted', { bubbles: true });
        this.el.nativeElement.dispatchEvent(event);
    }
    onVersionRestored() {
        this.loadVersionHistory();
        const                  event = new CustomEvent('version-restored', { bubbles: true });
        this.el.nativeElement.dispatchEvent(event);
    }
    getVersionContentUrl(nodeId, versionId, attachment) {
        const                  nodeDownloadUrl = this.alfrescoApi.contentApi.getContentUrl(nodeId, attachment);
        return nodeDownloadUrl.replace('/content', '/versions/' + versionId + '/content');
    }
    downloadContent(url) {
        if (url) {
            const                  link = document.createElement('a');
            link.style.display = 'none';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
VersionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-list',
                template: `<mat-list class="adf-version-list" *ngIf="!isLoading; else loading_template">
    <mat-list-item *ngFor="let version of versions">
        <mat-icon mat-list-icon>insert_drive_file</mat-icon>
        <h4 mat-line class="adf-version-list-item-name">{{version.entry.name}}</h4>
        <p mat-line>
            <span class="adf-version-list-item-version">{{version.entry.id}}</span> -
            <span class="adf-version-list-item-date">{{version.entry.modifiedAt | date}}</span>
        </p>
        <p mat-line class="adf-version-list-item-comment" *ngIf="showComments">{{version.entry.versionComment}}</p>

        <mat-menu #versionMenu="matMenu" yPosition="below" xPosition="before">
            <button *ngIf="canUpdate()"
                mat-menu-item
                (click)="restore(version.entry.id)">
                {{ 'ADF_VERSION_LIST.ACTIONS.RESTORE' | translate }}
            </button>
            <button *ngIf="allowDownload"
                mat-menu-item
                (click)="downloadVersion(version.entry.id)">
                {{ 'ADF_VERSION_LIST.ACTIONS.DOWNLOAD' | translate }}
            </button>
            <button *ngIf="canUpdate()"
                (click)="deleteVersion(version.entry.id)"
                mat-menu-item>
                {{ 'ADF_VERSION_LIST.ACTIONS.DELETE' | translate }}
            </button>
        </mat-menu>

        <button mat-icon-button [matMenuTriggerFor]="versionMenu">
            <mat-icon>more_vert</mat-icon>
        </button>
    </mat-list-item>
</mat-list>

<ng-template #loading_template>
    <mat-progress-bar data-automation-id="version-history-loading-bar" mode="indeterminate" color="accent"></mat-progress-bar>
</ng-template>
`,
                styles: [`.adf-version-list .mat-list-item{border-bottom:1px solid #d8d8d8}.adf-version-list-item-version{font-weight:700}.adf-version-list-item-date{opacity:.6}.adf-version-list-item-comment{opacity:.5}`],
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-version-list'
                }
            },] },
];
VersionListComponent.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: ContentService, },
    { type: MatDialog, },
    { type: ElementRef, },
];
VersionListComponent.propDecorators = {
    "id": [{ type: Input },],
    "node": [{ type: Input },],
    "showComments": [{ type: Input },],
    "allowDownload": [{ type: Input },],
};

class VersionManagerComponent {
    constructor(config, contentService) {
        this.contentService = contentService;
        this.showComments = true;
        this.allowDownload = true;
        this.uploadSuccess = new EventEmitter();
        this.uploadError = new EventEmitter();
        this.showComments = config.get('adf-version-manager.allowComments', true);
        this.allowDownload = config.get('adf-version-manager.allowDownload', true);
    }
    onUploadSuccess(event) {
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(event);
    }
    canUpdate() {
        return this.contentService.hasPermission(this.node, 'update');
    }
}
VersionManagerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-manager',
                template: `<div class="adf-new-version-uploader-container" fxLayout="row" fxLayoutAlign="end center">
    <adf-version-upload
        [node]="node"
        (success)="onUploadSuccess($event)"
        (error)="uploadError.emit($event)">
    </adf-version-upload>
</div>
<div class="adf-version-list-container">
    <adf-version-list
        #versionList
        [node]="node"
        [allowDownload]="allowDownload"
        [showComments]="showComments">
    </adf-version-list>
</div>
`,
                styles: [`.adf-button.upload-new-version{-webkit-box-shadow:none;box-shadow:none}.adf-new-version-uploader-container{border-bottom:1px solid #d8d8d8;padding:16px 0}`],
                encapsulation: ViewEncapsulation.None
            },] },
];
VersionManagerComponent.ctorParameters = () => [
    { type: AppConfigService, },
    { type: ContentService, },
];
VersionManagerComponent.propDecorators = {
    "node": [{ type: Input },],
    "showComments": [{ type: Input },],
    "allowDownload": [{ type: Input },],
    "uploadSuccess": [{ type: Output },],
    "uploadError": [{ type: Output },],
    "versionListComponent": [{ type: ViewChild, args: ['versionList',] },],
};

class VersionUploadComponent {
    constructor(contentService) {
        this.contentService = contentService;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
    }
    canUpload() {
        return this.contentService.hasPermission(this.node, 'update');
    }
}
VersionUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-upload',
                template: `<adf-upload-version-button
    data-automation-id="adf-new-version-file-upload"
    class="adf-new-version-file-upload"
    staticTitle="{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TITLE' | translate }}"
    [node]="node"
    [disabled]="!canUpload()"
    [rootFolderId]="node.parentId"
    tooltip="{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TOOLTIP' | translate }}"
    [versioning]="true"
    (success)="success.emit($event)"
    (error)="error.emit($event)">
</adf-upload-version-button>
`,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-version-upload' }
            },] },
];
VersionUploadComponent.ctorParameters = () => [
    { type: ContentService, },
];
VersionUploadComponent.propDecorators = {
    "node": [{ type: Input },],
    "success": [{ type: Output },],
    "error": [{ type: Output },],
};

class VersionManagerModule {
}
VersionManagerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    UploadModule
                ],
                exports: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ],
                declarations: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ],
                providers: []
            },] },
];
VersionManagerModule.ctorParameters = () => [];

class NameLocationCellComponent {
    constructor() {
        this.name = '';
        this.path = '';
    }
    ngOnInit() {
        if (this.row) {
            this.name = this.row.getValue('name');
            const                  fullPath = this.row.getValue('path');
            if (fullPath) {
                this.path = fullPath.name || '';
            }
        }
    }
}
NameLocationCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-name-location-cell',
                template: `
        <div class="adf-name-location-cell-name">{{ name }}</div>
        <div class="adf-name-location-cell-location" [title]="path">{{ path }}</div>
    `,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-name-location-cell' }
            },] },
];
NameLocationCellComponent.ctorParameters = () => [];
NameLocationCellComponent.propDecorators = {
    "row": [{ type: Input },],
};

class ContentNodeSelectorService {
    constructor(searchService) {
        this.searchService = searchService;
    }
    search(searchTerm, rootNodeId = null, skipCount = 0, maxItems = 25, extraNodeIds) {
        let                  extraParentFiltering = '';
        if (extraNodeIds && extraNodeIds.length) {
            extraNodeIds
                .filter(id => id !== rootNodeId)
                .forEach(extraId => {
                extraParentFiltering += ` OR ANCESTOR:'workspace://SpacesStore/${extraId}'`;
            });
        }
        const                  parentFiltering = rootNodeId ? [{ query: `ANCESTOR:'workspace://SpacesStore/${rootNodeId}'${extraParentFiltering}` }] : [];
        let                  defaultSearchNode = {
            query: {
                query: `${searchTerm}* OR name:${searchTerm}*`
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxItems,
                skipCount: skipCount
            },
            filterQueries: [
                { query: "TYPE:'cm:folder'" },
                { query: 'NOT cm:creator:System' },
                ...parentFiltering
            ],
            scope: {
                locations: ['nodes']
            }
        };
        return this.searchService.searchByQueryBody(defaultSearchNode);
    }
}
ContentNodeSelectorService.decorators = [
    { type: Injectable },
];
ContentNodeSelectorService.ctorParameters = () => [
    { type: SearchService, },
];

const defaultValidation = () => true;
class ContentNodeSelectorPanelComponent {
    constructor(contentNodeSelectorService, apiService, preferences) {
        this.contentNodeSelectorService = contentNodeSelectorService;
        this.apiService = apiService;
        this.preferences = preferences;
        this.currentFolderId = null;
        this.dropdownHideMyFiles = false;
        this.dropdownSiteList = null;
        this.rowFilter = null;
        this.imageResolver = null;
        this.isSelectionValid = defaultValidation;
        this.select = new EventEmitter();
        this.nodes = null;
        this.searchTerm = '';
        this.showingSearchResults = false;
        this.loadingSearchResults = false;
        this.inDialog = false;
        this._chosenNode = null;
        this.folderIdToShow = null;
        this.paginationStrategy = PaginationStrategy.Infinite;
        this.skipCount = 0;
        this.infiniteScroll = false;
        this.debounceSearch = 200;
        this.searchInput = new FormControl();
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((searchValue) => {
            this.search(searchValue);
        });
        this.pageSize = this.preferences.paginationSize;
        let                  defaultPagination =                  ({
            maxItems: this.pageSize,
            skipCount: 0,
            totalItems: 0,
            hasMoreItems: false
        });
        this.pagination = new BehaviorSubject(defaultPagination);
    }
    set chosenNode(value) {
        this._chosenNode = value;
        let                  valuesArray = null;
        if (value) {
            valuesArray = [value];
        }
        this.select.next(valuesArray);
    }
    get chosenNode() {
        return this._chosenNode;
    }
    ngOnInit() {
        this.folderIdToShow = this.currentFolderId;
        this.breadcrumbTransform = this.breadcrumbTransform ? this.breadcrumbTransform : null;
        this.isSelectionValid = this.isSelectionValid ? this.isSelectionValid : defaultValidation;
    }
    siteChanged(chosenSite) {
        this.siteId = chosenSite.entry.guid;
        this.updateResults();
    }
    search(searchTerm) {
        this.searchTerm = searchTerm;
        this.updateResults();
    }
    get breadcrumbFolderNode() {
        let                  folderNode;
        if (this.showingSearchResults && this.chosenNode) {
            folderNode = this.chosenNode;
        }
        else {
            folderNode = this.documentList.folderNode;
        }
        return folderNode;
    }
    clear() {
        this.clearSearch();
        this.folderIdToShow = this.siteId || this.currentFolderId;
    }
    clearSearch() {
        this.searchTerm = '';
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.showingSearchResults = false;
    }
    updateResults() {
        if (this.searchTerm.length === 0) {
            this.clear();
        }
        else {
            this.startNewSearch();
        }
    }
    startNewSearch() {
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.folderIdToShow = null;
        this.querySearch();
    }
    updatePagination(pagination) {
        this.infiniteScroll = true;
        this.skipCount = pagination.skipCount;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    }
    querySearch() {
        this.loadingSearchResults = true;
        if (this.dropdownSiteList) {
            this.documentList.getCorrespondingNodeIds(this.siteId)
                .subscribe(nodeIds => {
                this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.skipCount, this.pageSize, nodeIds)
                    .subscribe(this.showSearchResults.bind(this));
            }, () => {
                this.showSearchResults({ list: { entries: [] } });
            });
        }
        else {
            this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.skipCount, this.pageSize)
                .subscribe(this.showSearchResults.bind(this));
        }
    }
    showSearchResults(nodePaging) {
        this.showingSearchResults = true;
        this.loadingSearchResults = false;
        if (!this.nodes) {
            this.nodes = nodePaging;
        }
        else {
            this.documentList.data.loadPage(nodePaging, true);
        }
        this.pagination.next(nodePaging.list.pagination);
        this.highlight();
    }
    highlight() {
        setTimeout(() => {
            this.highlighter.highlight(this.searchTerm);
        }, 0);
    }
    onFolderChange() {
        this.showingSearchResults = false;
        this.infiniteScroll = false;
        this.clearSearch();
    }
    onFolderLoaded(nodePaging) {
        if (!this.showingSearchResults) {
            this.attemptNodeSelection(this.documentList.folderNode);
        }
    }
    showBreadcrumbs() {
        return !this.showingSearchResults || this.chosenNode;
    }
    getNextPageOfSearch(event) {
        this.infiniteScroll = true;
        this.skipCount = event.skipCount;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    }
    attemptNodeSelection(entry) {
        if (this.isSelectionValid(entry)) {
            this.chosenNode = entry;
        }
        else {
            this.resetChosenNode();
        }
    }
    resetChosenNode() {
        this.chosenNode = null;
    }
    onNodeSelect(event) {
        this.attemptNodeSelection(event.detail.node.entry);
    }
    onNodeDoubleClick(e) {
        const                  node = e.detail.node.entry;
        if (node && node.guid) {
            const                  options = {
                maxItems: this.pageSize,
                skipCount: this.skipCount,
                include: ['path', 'properties', 'allowableOperations']
            };
            this.apiService.nodesApi.getNode(node.guid, options)
                .then(documentLibrary => {
                this.documentList.performCustomSourceNavigation(documentLibrary);
            });
        }
    }
}
ContentNodeSelectorPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-node-selector-panel',
                styles: [``],
                template: `<div class="adf-content-node-selector-content" (node-select)="onNodeSelect($event)">
    <mat-form-field floatPlaceholder="never" class="adf-content-node-selector-content-input">
        <input matInput
            id="searchInput"
            [formControl]="searchInput"
            type="text"
            placeholder="{{'NODE_SELECTOR.SEARCH' | translate}}"
            [value]="searchTerm"
            data-automation-id="content-node-selector-search-input">

        <mat-icon *ngIf="searchTerm.length > 0"
            matSuffix (click)="clear()"
            class="adf-content-node-selector-content-input-icon"
            data-automation-id="content-node-selector-search-clear">clear
        </mat-icon>

        <mat-icon *ngIf="searchTerm.length === 0"
            matSuffix
            class="adf-content-node-selector-content-input-icon"
            data-automation-id="content-node-selector-search-icon">search
        </mat-icon>

    </mat-form-field>

    <adf-sites-dropdown
        class="full-width"
        (change)="siteChanged($event)"
        [placeholder]="'NODE_SELECTOR.SELECT_LOCATION'"
        [hideMyFiles]="dropdownHideMyFiles"
        [siteList]="dropdownSiteList"
        data-automation-id="content-node-selector-sites-combo">
    </adf-sites-dropdown>

    <adf-toolbar>
        <adf-toolbar-title>
            <ng-container *ngIf="!showBreadcrumbs()">
                <span class="search-results-label">{{ 'NODE_SELECTOR.SEARCH_RESULTS' | translate }}</span>
            </ng-container>
            <adf-dropdown-breadcrumb *ngIf="showBreadcrumbs()"
                class="adf-content-node-selector-content-breadcrumb"
                (navigate)="clearSearch()"
                [target]="documentList"
                [transform]="breadcrumbTransform"
                [folderNode]="breadcrumbFolderNode"
                data-automation-id="content-node-selector-content-breadcrumb">
            </adf-dropdown-breadcrumb>
        </adf-toolbar-title>
    </adf-toolbar>

    <div
        class="adf-content-node-selector-content-list"
        [class.adf-content-node-selector-content-list-searchLayout]="showingSearchResults"
        data-automation-id="content-node-selector-content-list">
        <adf-document-list
            #documentList
            adf-highlight
            adf-highlight-selector="adf-name-location-cell .adf-name-location-cell-name"
            [showHeader]="false"
            [node]="nodes"
            [maxItems]="pageSize"
            [rowFilter]="rowFilter"
            [imageResolver]="imageResolver"
            [currentFolderId]="folderIdToShow"
            selectionMode="single"
            [contextMenuActions]="false"
            [contentActions]="false"
            [allowDropFiles]="false"
            (folderChange)="onFolderChange()"
            (ready)="onFolderLoaded($event)"
            (node-dblclick)="onNodeDoubleClick($event)"
            data-automation-id="content-node-selector-document-list">
            <empty-folder-content>
                <ng-template>
                    <div>{{ 'NODE_SELECTOR.NO_RESULTS' | translate }}</div>
                </ng-template>
            </empty-folder-content>

            <data-columns>
                <data-column key="$thumbnail" type="image"></data-column>
                <data-column key="name" type="text" class="full-width ellipsis-cell">
                    <ng-template let-context>
                        <adf-name-location-cell [row]="context.row"></adf-name-location-cell>
                    </ng-template>
                </data-column>
                <data-column key="modifiedAt" type="date" format="timeAgo" class="adf-content-selector-modified-cell"></data-column>
                <data-column key="modifiedByUser.displayName" type="text" class="adf-content-selector-modifier-cell"></data-column>
                <data-column key="visibility" type="text"></data-column>
            </data-columns>

        </adf-document-list>

        <adf-infinite-pagination
            [target]="documentList"
            [loading]="loadingSearchResults"
            (loadMore)="getNextPageOfSearch($event)"
            data-automation-id="content-node-selector-search-pagination">
            {{ 'ADF-DOCUMENT-LIST.LAYOUT.LOAD_MORE' | translate }}
        </adf-infinite-pagination>
    </div>
</div>
`,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-content-node-selector-panel' }
            },] },
];
ContentNodeSelectorPanelComponent.ctorParameters = () => [
    { type: ContentNodeSelectorService, },
    { type: AlfrescoApiService, },
    { type: UserPreferencesService, },
];
ContentNodeSelectorPanelComponent.propDecorators = {
    "currentFolderId": [{ type: Input },],
    "dropdownHideMyFiles": [{ type: Input },],
    "dropdownSiteList": [{ type: Input },],
    "rowFilter": [{ type: Input },],
    "imageResolver": [{ type: Input },],
    "pageSize": [{ type: Input },],
    "isSelectionValid": [{ type: Input },],
    "breadcrumbTransform": [{ type: Input },],
    "select": [{ type: Output },],
    "documentList": [{ type: ViewChild, args: ['documentList',] },],
    "highlighter": [{ type: ViewChild, args: [HighlightDirective,] },],
};

class ContentNodeSelectorModule {
}
ContentNodeSelectorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    DirectiveModule,
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ToolbarModule,
                    DocumentListModule,
                    DataColumnModule,
                    DataTableModule,
                    PaginationModule
                ],
                exports: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ],
                entryComponents: [
                    ContentNodeSelectorPanelComponent, ContentNodeSelectorComponent
                ],
                declarations: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ],
                providers: [
                    ContentNodeSelectorService,
                    ContentNodeDialogService
                ]
            },] },
];
ContentNodeSelectorModule.ctorParameters = () => [];

const I18N_ERRORS_PATH = 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS';
function forbidSpecialCharacters({ value }) {
    const                  specialCharacters = /([\*\"\<\>\\\/\?\:\|])/;
    const                  isValid = !specialCharacters.test(value);
    return (isValid) ? null : {
        message: `${I18N_ERRORS_PATH}.SPECIAL_CHARACTERS`
    };
}
function forbidEndingDot({ value }) {
    const                  isValid = ((value || '').trim().split('').pop() !== '.');
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ENDING_DOT`
    };
}
function forbidOnlySpaces({ value }) {
    const                  isValid = !!((value || '')).trim();
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ONLY_SPACES`
    };
}

class FolderDialogComponent {
    constructor(formBuilder, dialog, nodesApi, translation, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.nodesApi = nodesApi;
        this.translation = translation;
        this.data = data;
        this.folder = null;
        this.error = new EventEmitter();
    }
    get editing() {
        return !!this.data.folder;
    }
    ngOnInit() {
        const { folder } = this.data;
        let                  name = '';
        let                  description = '';
        if (folder) {
            const { properties } = folder;
            name = folder.name || '';
            description = properties ? properties['cm:description'] : '';
        }
        const                  validators = {
            name: [
                Validators.required,
                forbidSpecialCharacters,
                forbidEndingDot,
                forbidOnlySpaces
            ]
        };
        this.form = this.formBuilder.group({
            name: [name, validators.name],
            description: [description]
        });
    }
    get name() {
        let { name } = this.form.value;
        return (name || '').trim();
    }
    get description() {
        let { description } = this.form.value;
        return (description || '').trim();
    }
    get properties() {
        const { name: title, description } = this;
        return {
            'cm:title': title,
            'cm:description': description
        };
    }
    create() {
        const { name, properties, nodesApi, data: { parentNodeId } } = this;
        return nodesApi.createFolder(parentNodeId, { name, properties });
    }
    edit() {
        const { name, properties, nodesApi, data: { folder: { id: nodeId } } } = this;
        return nodesApi.updateNode(nodeId, { name, properties });
    }
    submit() {
        const { form, dialog, editing } = this;
        if (!form.valid) {
            return;
        }
        (editing ? this.edit() : this.create())
            .subscribe((folder) => dialog.close(folder), (error) => this.handleError(error));
    }
    handleError(error) {
        let                  errorMessage = 'CORE.MESSAGES.ERRORS.GENERIC';
        try {
            const { error: { statusCode } } = JSON.parse(error.message);
            if (statusCode === 409) {
                errorMessage = 'CORE.MESSAGES.ERRORS.EXISTENT_FOLDER';
            }
        }
        catch (                 err) {
        }
        this.error.emit(this.translation.instant(errorMessage));
        return error;
    }
}
FolderDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-folder-dialog',
                styles: [`.adf-fill-remaining-space{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-full-width{width:100%}`],
                template: `<h2 mat-dialog-title>
    {{
    (editing
    ? 'CORE.FOLDER_DIALOG.EDIT_FOLDER_TITLE'
    : 'CORE.FOLDER_DIALOG.CREATE_FOLDER_TITLE'
    ) | translate
    }}
</h2>

<mat-dialog-content>
    <form [formGroup]="form" (submit)="submit()">
        <mat-input-container class="adf-full-width">
            <input
                placeholder="{{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.LABEL' | translate }}"
                matInput
                required
                [formControl]="form.controls['name']"
            />

            <mat-hint *ngIf="form.controls['name'].dirty">
                <span *ngIf="form.controls['name'].errors?.required">
                    {{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS.REQUIRED' | translate }}
                </span>

                <span *ngIf="!form.controls['name'].errors?.required && form.controls['name'].errors?.message">
                    {{ form.controls['name'].errors?.message | translate }}
                </span>
            </mat-hint>
        </mat-input-container>

        <br />
        <br />

        <mat-input-container class="adf-full-width">
            <textarea
                matInput
                placeholder="{{ 'CORE.FOLDER_DIALOG.FOLDER_DESCRIPTION.LABEL' | translate }}"
                rows="4"
                [formControl]="form.controls['description']"></textarea>
        </mat-input-container>
    </form>
</mat-dialog-content>

<mat-dialog-actions class="adf-dialog-buttons">
    <span class="adf-fill-remaining-space"></span>

    <button
        mat-button
        mat-dialog-close>
        {{ 'CORE.FOLDER_DIALOG.CANCEL_BUTTON.LABEL' | translate }}
    </button>

    <button class="adf-dialog-action-button"
            mat-button
            (click)="submit()"
            [disabled]="!form.valid">
        {{
        (editing
        ? 'CORE.FOLDER_DIALOG.UPDATE_BUTTON.LABEL'
        : 'CORE.FOLDER_DIALOG.CREATE_BUTTON.LABEL'
        ) | translate
        }}
    </button>
</mat-dialog-actions>
`
            },] },
];
FolderDialogComponent.ctorParameters = () => [
    { type: FormBuilder, },
    { type: MatDialogRef, },
    { type: NodesApiService, },
    { type: TranslationService, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] },] },
];
FolderDialogComponent.propDecorators = {
    "error": [{ type: Output },],
};

class DialogModule {
}
DialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    FormModule,
                    ReactiveFormsModule,
                    MatMomentDatetimeModule,
                    MatDatetimepickerModule
                ],
                declarations: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ShareDialogComponent,
                    ConfirmDialogComponent
                ],
                exports: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ShareDialogComponent,
                    ConfirmDialogComponent
                ],
                entryComponents: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ShareDialogComponent,
                    ConfirmDialogComponent
                ]
            },] },
];
DialogModule.ctorParameters = () => [];

const DEFAULT_FOLDER_PARENT_ID = '-my-';
class FolderCreateDirective {
    constructor(dialogRef, content) {
        this.dialogRef = dialogRef;
        this.content = content;
        this.parentNodeId = DEFAULT_FOLDER_PARENT_ID;
        this.error = new EventEmitter();
    }
    onClick(event) {
        event.preventDefault();
        this.openDialog();
    }
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderCreateDirective;
        const { parentNodeId } = this;
        return {
            data: { parentNodeId },
            width: `${width}px`
        };
    }
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        const                  dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((error) => {
            this.error.emit(error);
        });
        dialogInstance.afterClosed().subscribe((node) => {
            if (node) {
                content.folderCreate.next(node);
            }
        });
    }
}
FolderCreateDirective.DIALOG_WIDTH = 400;
FolderCreateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-create-folder]'
            },] },
];
FolderCreateDirective.ctorParameters = () => [
    { type: MatDialog, },
    { type: ContentService, },
];
FolderCreateDirective.propDecorators = {
    "parentNodeId": [{ type: Input, args: ['adf-create-folder',] },],
    "error": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['click', ['$event'],] },],
};

class FolderEditDirective {
    constructor(dialogRef, elementRef, content) {
        this.dialogRef = dialogRef;
        this.elementRef = elementRef;
        this.content = content;
        this.error = new EventEmitter();
    }
    onClick(event) {
        event.preventDefault();
        if (this.folder) {
            this.openDialog();
        }
    }
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderEditDirective;
        const { folder } = this;
        return {
            data: { folder },
            width: `${width}px`
        };
    }
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        const                  dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((error) => {
            this.error.emit(error);
        });
        dialogInstance.afterClosed().subscribe((node) => {
            if (node) {
                content.folderEdit.next(node);
            }
        });
    }
}
FolderEditDirective.DIALOG_WIDTH = 400;
FolderEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-edit-folder]'
            },] },
];
FolderEditDirective.ctorParameters = () => [
    { type: MatDialog, },
    { type: ElementRef, },
    { type: ContentService, },
];
FolderEditDirective.propDecorators = {
    "folder": [{ type: Input, args: ['adf-edit-folder',] },],
    "error": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['click', ['$event'],] },],
};

class FolderDirectiveModule {
}
FolderDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    FolderCreateDirective,
                    FolderEditDirective
                ],
                exports: [
                    FolderCreateDirective,
                    FolderEditDirective
                ]
            },] },
];
FolderDirectiveModule.ctorParameters = () => [];

class ContentMetadataCardComponent {
    constructor() {
        this.displayEmpty = false;
        this.readOnly = false;
        this.multi = false;
        this.editable = false;
        this.expanded = false;
    }
    toggleEdit() {
        this.editable = !this.editable;
    }
    toggleExpanded() {
        this.expanded = !this.expanded;
    }
}
ContentMetadataCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata-card',
                template: `<mat-card *ngIf="node">
    <mat-card-content>
        <adf-content-metadata
            [node]="node"
            [displayEmpty]="displayEmpty"
            [editable]="editable"
            [expanded]="expanded"
            [multi]="multi"
            [preset]="preset">
        </adf-content-metadata>
    </mat-card-content>
    <mat-card-footer class="adf-content-metadata-card-footer" fxLayout="row" fxLayoutAlign="space-between stretch">
        <div>
            <button *ngIf="!readOnly"
                mat-icon-button
                (click)="toggleEdit()"
                [attr.title]="'CORE.METADATA.ACTIONS.EDIT' | translate"
                data-automation-id="mata-data-card-toggle-edit">
                <mat-icon>mode_edit</mat-icon>
            </button>
        </div>
        <button mat-button (click)="toggleExpanded()" data-automation-id="mata-data-card-toggle-expand">
            <ng-container *ngIf="!expanded">
                <span data-automation-id="mata-data-card-toggle-expand-label">{{ 'ADF_VIEWER.SIDEBAR.METADATA.MORE_INFORMATION' | translate }}</span>
                <mat-icon>keyboard_arrow_down</mat-icon>
            </ng-container>
            <ng-container *ngIf="expanded">
                <span data-automation-id="mata-data-card-toggle-expand-label">{{ 'ADF_VIEWER.SIDEBAR.METADATA.LESS_INFORMATION' | translate }}</span>
                <mat-icon>keyboard_arrow_up</mat-icon>
            </ng-container>
        </button>
    </mat-card-footer>
</mat-card>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-content-metadata-card' }
            },] },
];
ContentMetadataCardComponent.ctorParameters = () => [];
ContentMetadataCardComponent.propDecorators = {
    "node": [{ type: Input },],
    "displayEmpty": [{ type: Input },],
    "preset": [{ type: Input },],
    "readOnly": [{ type: Input },],
    "multi": [{ type: Input },],
};

class BasicPropertiesService {
    constructor(fileSizePipe) {
        this.fileSizePipe = fileSizePipe;
    }
    getProperties(node) {
        const                  sizeInBytes = node.content ? node.content.sizeInBytes : '',
        mimeTypeName = node.content ? node.content.mimeTypeName : '',
        author = node.properties ? node.properties['cm:author'] : '',
        description = node.properties ? node.properties['cm:description'] : '',
        title = node.properties ? node.properties['cm:title'] : '';
        return [
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.NAME',
                value: node.name,
                key: 'name',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.TITLE',
                value: title,
                key: 'properties.cm:title',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.CREATOR',
                value: node.createdByUser.displayName,
                key: 'createdByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.CREATED_DATE',
                value: node.createdAt,
                key: 'createdAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.SIZE',
                value: sizeInBytes,
                key: 'content.sizeInBytes',
                pipes: [{ pipe: this.fileSizePipe }],
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIER',
                value: node.modifiedByUser.displayName,
                key: 'modifiedByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIED_DATE',
                value: node.modifiedAt,
                key: 'modifiedAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MIMETYPE',
                value: mimeTypeName,
                key: 'content.mimeTypeName',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.AUTHOR',
                value: author,
                key: 'properties.cm:author',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.DESCRIPTION',
                value: description,
                key: 'properties.cm:description',
                multiline: true,
                editable: true
            })
        ];
    }
}
BasicPropertiesService.decorators = [
    { type: Injectable },
];
BasicPropertiesService.ctorParameters = () => [
    { type: FileSizePipe, },
];

const D_TEXT = 'd:text';
const D_MLTEXT = 'd:mltext';
const D_DATE = 'd:date';
const D_DATETIME = 'd:datetime';
const D_INT = 'd:int';
const D_LONG = 'd:long';
const D_FLOAT = 'd:float';
const D_DOUBLE = 'd:double';
const D_BOOLEAN = 'd:boolean';
class PropertyGroupTranslatorService {
    constructor(logService) {
        this.logService = logService;
    }
    translateToCardViewGroups(propertyGroups, propertyValues) {
        return propertyGroups.map(propertyGroup => {
            const                  translatedPropertyGroup = Object.assign({}, propertyGroup);
            translatedPropertyGroup.properties = this.translateArray(propertyGroup.properties, propertyValues);
            return translatedPropertyGroup;
        });
    }
    translateArray(properties, propertyValues) {
        return properties.map(property => {
            return this.translate(property, propertyValues[property.name]);
        });
    }
    translate(property, propertyValue) {
        this.checkECMTypeValidity(property.dataType);
        const                  prefix = 'properties.';
        let                  propertyDefinition = {
            label: property.title,
            value: propertyValue,
            key: `${prefix}${property.name}`,
            default: property.defaultValue,
            editable: true
        };
        let                  cardViewItemProperty;
        switch (property.dataType) {
            case D_MLTEXT:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: true
                }));
                break;
            case D_INT:
            case D_LONG:
                cardViewItemProperty = new CardViewIntItemModel(propertyDefinition);
                break;
            case D_FLOAT:
            case D_DOUBLE:
                cardViewItemProperty = new CardViewFloatItemModel(propertyDefinition);
                break;
            case D_DATE:
                cardViewItemProperty = new CardViewDateItemModel(propertyDefinition);
                break;
            case D_DATETIME:
                cardViewItemProperty = new CardViewDatetimeItemModel(propertyDefinition);
                break;
            case D_BOOLEAN:
                cardViewItemProperty = new CardViewBoolItemModel(propertyDefinition);
                break;
            case D_TEXT:
            default:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: false
                }));
        }
        return cardViewItemProperty;
    }
    checkECMTypeValidity(ecmPropertyType) {
        if (PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES.indexOf(ecmPropertyType) === -1) {
            this.logService.error(`Unknown type for mapping: ${ecmPropertyType}`);
        }
    }
}
PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES = [D_TEXT, D_MLTEXT, D_DATE, D_DATETIME, D_INT, D_LONG, D_FLOAT, D_DOUBLE, D_BOOLEAN];
PropertyGroupTranslatorService.decorators = [
    { type: Injectable },
];
PropertyGroupTranslatorService.ctorParameters = () => [
    { type: LogService, },
];

const emptyGroup = {
    properties: {}
};
function convertObjectToArray(object) {
    return Object.keys(object).map(key => object[key]);
}
function getGroup(propertyGroups, groupName) {
    return propertyGroups[groupName];
}
function getProperty(propertyGroups, groupName, propertyName) {
    const                  groupDefinition = getGroup(propertyGroups, groupName) || emptyGroup;
    let                  propertyDefinitions;
    if (propertyName === '*') {
        propertyDefinitions = convertObjectToArray(groupDefinition.properties);
    }
    else {
        propertyDefinitions = groupDefinition.properties[propertyName];
    }
    return propertyDefinitions;
}

class AspectOrientedConfigService {
    constructor(config) {
        this.config = config;
    }
    isGroupAllowed(groupName) {
        const                  groupNames = Object.keys(this.config);
        return groupNames.indexOf(groupName) !== -1;
    }
    reorganiseByConfig(propertyGroups) {
        const                  aspects = this.config,
        aspectNames = Object.keys(aspects);
        return aspectNames
            .reduce((groupAccumulator, aspectName) => {
            const                  newGroup = this.getOrganisedPropertyGroup(propertyGroups, aspectName);
            return groupAccumulator.concat(newGroup);
        }, [])
            .filter(organisedPropertyGroup => organisedPropertyGroup.properties.length > 0);
    }
    getOrganisedPropertyGroup(propertyGroups, aspectName) {
        const                  group = getGroup(propertyGroups, aspectName);
        let                  newGroup = [];
        if (group) {
            const                  aspectProperties = this.config[aspectName];
            let                  properties;
            if (aspectProperties === '*') {
                properties = getProperty(propertyGroups, aspectName, aspectProperties);
            }
            else {
                properties = (                 (aspectProperties))
                    .map((propertyName) => getProperty(propertyGroups, aspectName, propertyName))
                    .filter(props => props !== undefined);
            }
            newGroup = [{ title: group.title, properties }];
        }
        return newGroup;
    }
}
AspectOrientedConfigService.decorators = [
    { type: Injectable },
];
AspectOrientedConfigService.ctorParameters = () => [
    null,
];

class IndifferentConfigService {
    constructor(config) { }
    isGroupAllowed(groupName) {
        return true;
    }
    reorganiseByConfig(propertyGroups) {
        return Object.keys(propertyGroups)
            .map((groupName) => {
            const                  propertyGroup = propertyGroups[groupName],
            properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map(propertyName => properties[propertyName])
            });
        });
    }
}
IndifferentConfigService.decorators = [
    { type: Injectable },
];
IndifferentConfigService.ctorParameters = () => [
    null,
];

class LayoutOrientedConfigService {
    constructor(config) {
        this.config = config;
    }
    isGroupAllowed(groupName) {
        return this.getMatchingGroups(groupName).length > 0;
    }
    reorganiseByConfig(propertyGroups) {
        const                  layoutBlocks = this.config;
        return layoutBlocks.map((layoutBlock) => {
            const                  flattenedItems = this.flattenItems(layoutBlock.items),
            properties = flattenedItems.reduce((props, explodedItem) => {
                const                  property = getProperty(propertyGroups, explodedItem.groupName, explodedItem.propertyName) || [];
                return props.concat(property);
            }, []);
            return {
                title: layoutBlock.title,
                properties
            };
        });
    }
    flattenItems(items) {
        return items.reduce((accumulator, item) => {
            const                  properties = Array.isArray(item.properties) ? item.properties : [item.properties];
            const                  flattenedProperties = properties.map(propertyName => {
                return {
                    groupName: item.aspect || item.type,
                    propertyName
                };
            });
            return accumulator.concat(flattenedProperties);
        }, []);
    }
    getMatchingGroups(groupName) {
        return this.config
            .map(layoutBlock => layoutBlock.items)
            .reduce((accumulator, items) => accumulator.concat(items), [])
            .filter((item) => item.aspect === groupName || item.type === groupName);
    }
}
LayoutOrientedConfigService.decorators = [
    { type: Injectable },
];
LayoutOrientedConfigService.ctorParameters = () => [
    null,
];

class ContentMetadataConfigFactory {
    constructor(appConfigService, logService) {
        this.appConfigService = appConfigService;
        this.logService = logService;
    }
    get(presetName = 'default') {
        let                  presetConfig;
        try {
            presetConfig = this.appConfigService.config['content-metadata'].presets[presetName];
        }
        catch (_a) {
            if (presetName !== ContentMetadataConfigFactory.DEFAULT_PRESET_NAME) {
                this.logService.error(`No content-metadata preset for: ${presetName}`);
            }
            presetConfig = ContentMetadataConfigFactory.INDIFFERENT_PRESET;
        }
        return this.createConfig(presetConfig);
    }
    createConfig(presetConfig) {
        let                  config;
        if (this.isLayoutOrientedPreset(presetConfig)) {
            config = new LayoutOrientedConfigService(                 (presetConfig));
        }
        else if (this.isAspectOrientedPreset(presetConfig)) {
            config = new AspectOrientedConfigService(                 (presetConfig));
        }
        else {
            config = new IndifferentConfigService(                 (presetConfig));
        }
        Object.freeze(config);
        return config;
    }
    isAspectOrientedPreset(presetConfig) {
        return this.isObject(presetConfig);
    }
    isLayoutOrientedPreset(presetConfig) {
        return Array.isArray(presetConfig);
    }
    isObject(x) {
        return x != null && typeof x === 'object';
    }
}
ContentMetadataConfigFactory.INDIFFERENT_PRESET = '*';
ContentMetadataConfigFactory.DEFAULT_PRESET_NAME = 'default';
ContentMetadataConfigFactory.decorators = [
    { type: Injectable },
];
ContentMetadataConfigFactory.ctorParameters = () => [
    { type: AppConfigService, },
    { type: LogService, },
];

class PropertyDescriptorsService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    load(groupNames) {
        const                  groupFetchStreams = groupNames
            .map(groupName => groupName.replace(':', '_'))
            .map(groupName => defer(() => this.alfrescoApiService.classesApi.getClass(groupName)));
        return forkJoin(groupFetchStreams)
            .map(this.convertToObject);
    }
    convertToObject(propertyGroupsArray) {
        return propertyGroupsArray.reduce((propertyGroups, propertyGroup) => {
            return Object.assign({}, propertyGroups, {
                [propertyGroup.name]: propertyGroup
            });
        }, {});
    }
}
PropertyDescriptorsService.decorators = [
    { type: Injectable },
];
PropertyDescriptorsService.ctorParameters = () => [
    { type: AlfrescoApiService, },
];

class ContentMetadataService {
    constructor(basicPropertiesService, contentMetadataConfigFactory, propertyGroupTranslatorService, propertyDescriptorsService) {
        this.basicPropertiesService = basicPropertiesService;
        this.contentMetadataConfigFactory = contentMetadataConfigFactory;
        this.propertyGroupTranslatorService = propertyGroupTranslatorService;
        this.propertyDescriptorsService = propertyDescriptorsService;
    }
    getBasicProperties(node) {
        return Observable.of(this.basicPropertiesService.getProperties(node));
    }
    getGroupedProperties(node, presetName = 'default') {
        let                  groupedProperties = Observable.of([]);
        if (node.aspectNames) {
            const                  config = this.contentMetadataConfigFactory.get(presetName),
            groupNames = node.aspectNames
                .concat(node.nodeType)
                .filter(groupName => config.isGroupAllowed(groupName));
            if (groupNames.length > 0) {
                groupedProperties = this.propertyDescriptorsService.load(groupNames)
                    .map(groups => config.reorganiseByConfig(groups))
                    .map(groups => this.propertyGroupTranslatorService.translateToCardViewGroups(groups, node.properties));
            }
        }
        return groupedProperties;
    }
}
ContentMetadataService.decorators = [
    { type: Injectable },
];
ContentMetadataService.ctorParameters = () => [
    { type: BasicPropertiesService, },
    { type: ContentMetadataConfigFactory, },
    { type: PropertyGroupTranslatorService, },
    { type: PropertyDescriptorsService, },
];

class ContentMetadataComponent {
    constructor(contentMetadataService, cardViewUpdateService, nodesApi, logService, apiService) {
        this.contentMetadataService = contentMetadataService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.nodesApi = nodesApi;
        this.logService = logService;
        this.apiService = apiService;
        this.editable = false;
        this.displayEmpty = false;
        this.expanded = false;
        this.multi = false;
        this.nodeHasBeenUpdated = false;
    }
    ngOnInit() {
        this.cardViewUpdateService.itemUpdated$
            .switchMap(this.saveNode.bind(this))
            .subscribe((node) => {
            this.nodeHasBeenUpdated = true;
            this.node = node;
            this.apiService.nodeUpdated.next(node);
        }, error => this.logService.error(error));
    }
    ngOnChanges(changes) {
        const                  nodeChange = changes['node'];
        if (nodeChange || this.nodeHasBeenUpdated) {
            const                  node = nodeChange && nodeChange.currentValue || this.node;
            this.nodeHasBeenUpdated = false;
            this.basicProperties$ = this.contentMetadataService.getBasicProperties(node);
            this.groupedProperties$ = this.contentMetadataService.getGroupedProperties(node, this.preset);
        }
    }
    saveNode({ changed: nodeBody }) {
        return this.nodesApi.updateNode(this.node.id, nodeBody);
    }
}
ContentMetadataComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata',
                template: `<div class="adf-metadata-properties">
    <mat-accordion displayMode="flat" [multi]="multi">
        <mat-expansion-panel [expanded]="!expanded" [hideToggle]="!expanded">
            <mat-expansion-panel-header>
                <mat-panel-title>
                    {{ 'CORE.METADATA.BASIC.HEADER' | translate }}
                </mat-panel-title>
            </mat-expansion-panel-header>

            <adf-card-view
                [properties]="basicProperties$ | async"
                [editable]="editable"
                [displayEmpty]="displayEmpty">
            </adf-card-view>
        </mat-expansion-panel>

        <ng-container *ngIf="expanded">
            <ng-container *ngIf="groupedProperties$ | async; else loading; let groupedProperties">
                <div *ngFor="let group of groupedProperties" class="adf-metadata-grouped-properties-container">
                    <mat-expansion-panel>
                        <mat-expansion-panel-header>
                            <mat-panel-title>
                                {{ group.title | translate }}
                            </mat-panel-title>
                        </mat-expansion-panel-header>

                        <adf-card-view
                            [properties]="group.properties"
                            [editable]="editable"
                            [displayEmpty]="displayEmpty">
                        </adf-card-view>
                    </mat-expansion-panel>
                </div>
            </ng-container>
            <ng-template #loading>
                <mat-progress-bar mode="indeterminate"></mat-progress-bar>
            </ng-template>
        </ng-container>
    </mat-accordion>
</div>`,
                styles: [``],
                host: { 'class': 'adf-content-metadata' },
                encapsulation: ViewEncapsulation.None
            },] },
];
ContentMetadataComponent.ctorParameters = () => [
    { type: ContentMetadataService, },
    { type: CardViewUpdateService, },
    { type: NodesApiService, },
    { type: LogService, },
    { type: AlfrescoApiService, },
];
ContentMetadataComponent.propDecorators = {
    "node": [{ type: Input },],
    "editable": [{ type: Input },],
    "displayEmpty": [{ type: Input },],
    "expanded": [{ type: Input },],
    "multi": [{ type: Input },],
    "preset": [{ type: Input },],
};

class ContentMetadataModule {
}
ContentMetadataModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FlexLayoutModule,
                    CardViewModule
                ],
                exports: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ],
                declarations: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ]
            },] },
];
ContentMetadataModule.ctorParameters = () => [];

class PermissionDisplayModel {
    constructor(obj) {
        this.isInherited = false;
        if (obj) {
            this.authorityId = obj.authorityId;
            this.name = obj.name;
            this.accessStatus = obj.accessStatus;
            this.isInherited = obj.isInherited !== null && obj.isInherited !== undefined ? obj.isInherited : false;
            this.icon = obj.icon ? obj.icon : 'lock_open';
        }
    }
}

class NodePermissionService {
    constructor(apiService, searchApiService, nodeService) {
        this.apiService = apiService;
        this.searchApiService = searchApiService;
        this.nodeService = nodeService;
    }
    getNodeRoles(node) {
        const                  retrieveSiteQueryBody = this.buildRetrieveSiteQueryBody(node.path.elements);
        return this.searchApiService.searchByQueryBody(retrieveSiteQueryBody)
            .switchMap((siteNodeList) => {
            if (siteNodeList.list.entries.length > 0) {
                let                  siteName = siteNodeList.list.entries[0].entry.name;
                return this.getGroupMembersBySiteName(siteName);
            }
            else {
                return Observable.of(node.permissions.settable);
            }
        });
    }
    updatePermissionRoles(node, updatedPermissionRole) {
        let                  permissionBody = { permissions: { locallySet: [] } };
        const                  index = node.permissions.locallySet.map((permission) => permission.authorityId).indexOf(updatedPermissionRole.authorityId);
        permissionBody.permissions.locallySet = permissionBody.permissions.locallySet.concat(node.permissions.locallySet);
        if (index !== -1) {
            permissionBody.permissions.locallySet[index] = updatedPermissionRole;
        }
        else {
            permissionBody.permissions.locallySet.push(updatedPermissionRole);
        }
        return this.nodeService.updateNode(node.id, permissionBody);
    }
    getGroupMembersBySiteName(siteName) {
        const                  groupName = 'GROUP_site_' + siteName;
        return this.getGroupMemeberByGroupName(groupName)
            .map((res) => {
            let                  displayResult = [];
            res.list.entries.forEach((member) => {
                displayResult.push(this.formattedRoleName(member.entry.displayName, 'site_' + siteName));
            });
            return displayResult;
        });
    }
    getGroupMemeberByGroupName(groupName, opts) {
        return Observable.fromPromise(this.apiService.groupsApi.getGroupMembers(groupName, opts));
    }
    formattedRoleName(displayName, siteName) {
        return displayName.replace(siteName + '_', '');
    }
    buildRetrieveSiteQueryBody(nodePath) {
        const                  pathNames = nodePath.map((node) => 'name: "' + node.name + '"');
        const                  buildedPathNames = pathNames.join(' OR ');
        return {
            'query': {
                'query': buildedPathNames
            },
            'paging': {
                'maxItems': 100,
                'skipCount': 0
            },
            'include': ['aspectNames', 'properties'],
            'filterQueries': [
                {
                    'query': "TYPE:'st:site'"
                }
            ]
        };
    }
}
NodePermissionService.decorators = [
    { type: Injectable },
];
NodePermissionService.ctorParameters = () => [
    { type: AlfrescoApiService, },
    { type: SearchService, },
    { type: NodesApiService, },
];

class PermissionListComponent {
    constructor(nodeService, nodePermissionService) {
        this.nodeService = nodeService;
        this.nodePermissionService = nodePermissionService;
        this.nodeId = '';
        this.update = new EventEmitter();
    }
    ngOnInit() {
        this.fetchNodePermissions();
    }
    reload() {
        this.fetchNodePermissions();
    }
    fetchNodePermissions() {
        this.nodeService.getNode(this.nodeId).subscribe((node) => {
            this.actualNode = node;
            this.permissionList = this.getPermissionList(node);
            this.nodePermissionService.getNodeRoles(node).subscribe((settableList) => {
                this.settableRoles = settableList;
            });
        });
    }
    getPermissionList(node) {
        let                  allPermissions = [];
        if (node.permissions.locallySet) {
            node.permissions.locallySet.map((element) => {
                let                  permission = new PermissionDisplayModel(element);
                allPermissions.push(permission);
            });
        }
        if (node.permissions.inherited) {
            node.permissions.inherited.map((element) => {
                let                  permissionInherited = new PermissionDisplayModel(element);
                permissionInherited.isInherited = true;
                allPermissions.push(permissionInherited);
            });
        }
        return allPermissions;
    }
    saveNewRole(event, permissionRow) {
        let                  updatedPermissionRole = this.buildUpdatedPermission(event.value, permissionRow);
        this.nodePermissionService.updatePermissionRoles(this.actualNode, updatedPermissionRole)
            .subscribe((node) => {
            this.update.emit(updatedPermissionRole);
        });
    }
    buildUpdatedPermission(newRole, permissionRow) {
        let                  permissionRole = {};
        permissionRole.accessStatus = permissionRow.accessStatus;
        permissionRole.name = newRole;
        permissionRole.authorityId = permissionRow.authorityId;
        return permissionRole;
    }
}
PermissionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-permission-list',
                template: `<div id="adf-permission-display-container" class="adf-display-permission-container">
    <adf-datatable [rows]="permissionList" class="adf-datatable-permission">
        <data-columns>
            <data-column key="icon" type="icon" [sortable]="false">
            </data-column>
            <data-column title="{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.AUTHORITY_ID' | translate}}" key="authorityId"></data-column>
            <data-column title="{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.ROLE' | translate}}" key="name">
                <ng-template let-entry="$implicit">
                    <mat-form-field *ngIf="!entry.row.getValue('isInherited') else show_only_label">
                        <mat-select id="adf-select-role-permission"
                                    value="{{entry.data.getValue(entry.row, entry.col)}}"
                                    (selectionChange)="saveNewRole($event, entry.row.obj)">
                          <mat-option *ngFor="let role of settableRoles" [value]="role">
                            {{ role }}
                          </mat-option>
                        </mat-select>
                      </mat-form-field>
                      <ng-template #show_only_label>
                          <span>{{entry.data.getValue(entry.row, entry.col)}}</span>
                      </ng-template>
                </ng-template>
            </data-column>
            <data-column title="{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}" key="isInherited">
                <ng-template let-entry="$implicit">
                    <mat-chip-list>
                        <mat-chip *ngIf="!!entry.data.getValue(entry.row, entry.col) else locally_set_chip"
                                id="adf-permission-inherited-label"
                                color="primary" selected="true">{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}</mat-chip>
                    </mat-chip-list>
                    <ng-template #locally_set_chip>
                            <mat-chip-list>
                                    <mat-chip id="adf-permission-locallyset-label"
                                              color="accent" selected="true">
                                              {{'PERMISSION_MANAGER.PERMISSION_DISPLAY.LOCALLY_SET' | translate}}
                                    </mat-chip>
                            </mat-chip-list>
                    </ng-template>
                </ng-template>
            </data-column>
        </data-columns>
    </adf-datatable>
</div>

`,
                styles: [``],
                encapsulation: ViewEncapsulation.None
            },] },
];
PermissionListComponent.ctorParameters = () => [
    { type: NodesApiService, },
    { type: NodePermissionService, },
];
PermissionListComponent.propDecorators = {
    "nodeId": [{ type: Input },],
    "update": [{ type: Output },],
};

class InheritPermissionDirective {
    constructor(nodeService) {
        this.nodeService = nodeService;
        this.updated = new EventEmitter();
    }
    onInheritPermissionClicked() {
        this.nodeService.getNode(this.nodeId).subscribe((node) => {
            const                  nodeBody = { permissions: { isInheritanceEnabled: !node.permissions.isInheritanceEnabled } };
            this.nodeService.updateNode(this.nodeId, nodeBody, { include: ['permissions'] }).subscribe((nodeUpdated) => {
                this.updated.emit(nodeUpdated);
            });
        });
    }
}
InheritPermissionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-inherit-permission], mat-button-toggle[adf-inherit-permission]',
                host: {
                    'role': 'button',
                    '(click)': 'onInheritPermissionClicked()'
                }
            },] },
];
InheritPermissionDirective.ctorParameters = () => [
    { type: NodesApiService, },
];
InheritPermissionDirective.propDecorators = {
    "nodeId": [{ type: Input },],
    "updated": [{ type: Output },],
};

class PermissionManagerModule {
}
PermissionManagerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    TranslateModule,
                    DataTableModule,
                    DataColumnModule
                ],
                declarations: [
                    PermissionListComponent,
                    InheritPermissionDirective
                ],
                providers: [
                    NodePermissionService
                ],
                exports: [
                    PermissionListComponent,
                    InheritPermissionDirective
                ]
            },] },
];
PermissionManagerModule.ctorParameters = () => [];

const 0$1 = {
    name: 'adf-content-services',
    source: 'assets/adf-content-services'
};
class ContentModule {
}
ContentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    SocialModule,
                    TagModule,
                    CommonModule,
                    WebScriptModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DialogModule,
                    SearchModule,
                    DocumentListModule,
                    UploadModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentMetadataModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: 0$1
                    },
                    RatingService,
                    ContentMetadataService,
                    PropertyDescriptorsService,
                    ContentMetadataConfigFactory,
                    BasicPropertiesService,
                    PropertyGroupTranslatorService,
                    SearchQueryBuilderService
                ],
                exports: [
                    CoreModule,
                    SocialModule,
                    TagModule,
                    WebScriptModule,
                    DocumentListModule,
                    UploadModule,
                    SearchModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ]
            },] },
];
ContentModule.ctorParameters = () => [];

export { NodeDownloadDirective, NodeSharedDirective, ContentDirectiveModule, RatingComponent, LikeComponent, RatingService, SocialModule, TagActionsComponent, TagListComponent, TagNodeListComponent, TagService, TagModule, WebscriptComponent, WebScriptModule, PaginationStrategy, DocumentListComponent, NodeEntityEvent, NodeEntryEvent, ContentColumnComponent, ContentColumnListComponent, ContentActionComponent, ContentActionListComponent, EmptyFolderContentDirective, NoPermissionContentDirective, ShareDataTableAdapter, ShareDataRow, FolderActionsService, DocumentActionsService, DocumentListService, NodeActionsService, CustomResourcesService, ContentActionModel, ContentActionTarget, DocumentActionModel, FolderActionModel, NodePaging, NodePagingList, NodeMinimalEntry, Pagination, NodeMinimal, UserInfo, ContentInfo, PathInfoEntity, PathElementEntity, PermissionModel, PermissionStyleModel, DocumentListModule, UploadButtonComponent, UploadVersionButtonComponent, FileUploadingDialogComponent, UploadDragAreaComponent, FileUploadingListComponent, FileUploadingListRowComponent, FileDraggableDirective, UploadBase, UploadModule, SearchQueryBuilderService, SearchComponent, SearchControlComponent, SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR, SearchTriggerDirective, EmptySearchResultComponent, SearchFilterComponent, SearchChipListComponent, ALFRESCO_SEARCH_DIRECTIVES, SearchModule, Relations, DropdownSitesComponent, SitesDropdownModule, BreadcrumbComponent, DropdownBreadcrumbComponent, BreadcrumbModule, VersionListComponent, VersionManagerComponent, VersionUploadComponent, VersionManagerModule, NameLocationCellComponent, ContentNodeSelectorPanelComponent, ContentNodeSelectorComponent, ContentNodeSelectorService, ContentNodeDialogService, ContentNodeSelectorModule, DownloadZipDialogComponent, FolderDialogComponent, NodeLockDialogComponent, ShareDialogComponent, ConfirmDialogComponent, DialogModule, FolderCreateDirective, FolderEditDirective, FolderDirectiveModule, ContentMetadataCardComponent, BasicPropertiesService, ContentMetadataService, PropertyDescriptorsService, PropertyGroupTranslatorService, ContentMetadataConfigFactory, IndifferentConfigService, LayoutOrientedConfigService, AspectOrientedConfigService, ContentMetadataModule, PermissionListComponent, InheritPermissionDirective, NodePermissionService, PermissionDisplayModel, PermissionManagerModule, ContentModule, ContentMetadataComponent as e, NodeLockDirective as c, MaterialModule as b, modules as a, InheritPermissionDirective as i, PermissionListComponent as g, PermissionManagerModule as f, NodePermissionService as h, SearchWidgetContainerComponent as d };
//# sourceMappingURL=adf-content-services.js.map
