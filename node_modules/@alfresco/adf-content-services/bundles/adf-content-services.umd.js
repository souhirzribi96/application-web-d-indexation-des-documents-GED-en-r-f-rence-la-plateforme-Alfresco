/**
 * @license
 * Copyright 2018 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/material'), require('@alfresco/adf-core'), require('alfresco-js-api'), require('rxjs/Observable'), require('rxjs/add/observable/throw'), require('moment-es6'), require('@angular/forms'), require('rxjs/Subject'), require('rxjs/operator/switchMap'), require('@angular/common'), require('@ngx-translate/core'), require('rxjs/BehaviorSubject'), require('rxjs/add/observable/merge'), require('@angular/flex-layout'), require('@angular/animations'), require('rxjs/operators'), require('@angular/cdk/keycodes'), require('@angular/platform-browser'), require('rxjs/observable/fromEvent'), require('rxjs/observable/merge'), require('@mat-datetimepicker/core'), require('@mat-datetimepicker/moment'), require('rxjs/observable/forkJoin'), require('rxjs/observable/defer'), require('rxjs/add/operator/switchMap')) :
	typeof define === 'function' && define.amd ? define('@alfresco/adf-content-services', ['exports', '@angular/core', '@angular/material', '@alfresco/adf-core', 'alfresco-js-api', 'rxjs/Observable', 'rxjs/add/observable/throw', 'moment-es6', '@angular/forms', 'rxjs/Subject', 'rxjs/operator/switchMap', '@angular/common', '@ngx-translate/core', 'rxjs/BehaviorSubject', 'rxjs/add/observable/merge', '@angular/flex-layout', '@angular/animations', 'rxjs/operators', '@angular/cdk/keycodes', '@angular/platform-browser', 'rxjs/observable/fromEvent', 'rxjs/observable/merge', '@mat-datetimepicker/core', '@mat-datetimepicker/moment', 'rxjs/observable/forkJoin', 'rxjs/observable/defer', 'rxjs/add/operator/switchMap'], factory) :
	(factory((global.alfresco = global.alfresco || {}, global.alfresco['adf-content-services'] = {}),global.ng.core,global['@angular/material'],global['@alfresco/adf-core'],global['alfresco-js-api'],global.Rx,global.Rx.Observable,global['moment-es6'],global.ng.forms,global.Rx,global.Rx.Observable.prototype,global.ng.common,global['@ngx-translate/core'],global.Rx,global.Rx.Observable,global['@angular/flex-layout'],global['@angular/animations'],global.Rx.Observable.prototype,global.ng.cdk.keycodes,global.ng.platformBrowser,global.Rx.Observable,global.Rx.Observable,global['@mat-datetimepicker/core'],global['@mat-datetimepicker/moment'],global.Rx.Observable,global.Rx.Observable));
}(this, (function (exports,core,material,adfCore,alfrescoJsApi,Observable,_throw,moment,forms,Subject,switchMap,common,core$1,BehaviorSubject,merge,flexLayout,animations,operators,keycodes,platformBrowser,fromEvent,merge$1,core$2,moment$1,forkJoin,defer) { 'use strict';

moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}





function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var DownloadZipDialogComponent =               (function () {
    function DownloadZipDialogComponent(apiService, dialogRef, data, logService) {
        this.apiService = apiService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.logService = logService;
        this.cancelled = false;
    }
    DownloadZipDialogComponent.prototype.ngOnInit = function () {
        if (this.data && this.data.nodeIds && this.data.nodeIds.length > 0) {
            if (!this.cancelled) {
                this.downloadZip(this.data.nodeIds);
            }
            else {
                this.logService.log('Cancelled');
            }
        }
    };
    DownloadZipDialogComponent.prototype.cancelDownload = function () {
        this.cancelled = true;
        this.dialogRef.close(false);
    };
    DownloadZipDialogComponent.prototype.downloadZip = function (nodeIds) {
        var _this = this;
        if (nodeIds && nodeIds.length > 0) {
            var promise = this.apiService.getInstance().core.downloadsApi.createDownload({ nodeIds: nodeIds });
            promise.on('progress', function (progress) { return _this.logService.log('Progress', progress); });
            promise.on('error', function (error) { return _this.logService.error('Error', error); });
            promise.on('abort', function (data) { return _this.logService.log('Abort', data); });
            promise.on('success', function (data) {
                if (data && data.entry && data.entry.id) {
                    var url_1 = _this.apiService.getInstance().content.getContentUrl(data.entry.id, true);
                    _this.apiService.getInstance().core.nodesApi.getNode(data.entry.id).then(function (downloadNode) {
                        _this.logService.log(downloadNode);
                        var fileName = downloadNode.entry.name;
                        _this.waitAndDownload(data.entry.id, url_1, fileName);
                    });
                }
            });
        }
    };
    DownloadZipDialogComponent.prototype.waitAndDownload = function (downloadId, url, fileName) {
        var _this = this;
        if (this.cancelled) {
            return;
        }
        this.apiService.getInstance().core.downloadsApi.getDownload(downloadId).then(function (downloadEntry) {
            if (downloadEntry.entry) {
                if (downloadEntry.entry.status === 'DONE') {
                    _this.download(url, fileName);
                }
                else {
                    setTimeout(function () {
                        _this.waitAndDownload(downloadId, url, fileName);
                    }, 1000);
                }
            }
        });
    };
    DownloadZipDialogComponent.prototype.download = function (url, fileName) {
        if (url && fileName) {
            var link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        this.dialogRef.close(true);
    };
    return DownloadZipDialogComponent;
}());
DownloadZipDialogComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-download-zip-dialog',
                template: "<h1 matDialogTitle>{{ 'CORE.DIALOG.DOWNLOAD_ZIP.TITLE' | translate }}</h1>\n<div mat-dialog-content>\n    <mat-progress-bar color=\"primary\" mode=\"indeterminate\"></mat-progress-bar>\n</div>\n<div mat-dialog-actions>\n    <span class=\"spacer\"></span>\n    <button mat-button color=\"primary\" (click)=\"cancelDownload()\">\n        {{ 'CORE.DIALOG.DOWNLOAD_ZIP.ACTIONS.CANCEL' | translate }}\n    </button>\n</div>\n",
                styles: [".spacer{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-download-zip-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}"],
                host: { 'class': 'adf-download-zip-dialog' },
                encapsulation: core.ViewEncapsulation.None
            },] },
];
DownloadZipDialogComponent.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
    { type: material.MatDialogRef, },
    { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] },] },
    { type: adfCore.LogService, },
]; };
var NodeDownloadDirective =               (function () {
    function NodeDownloadDirective(apiService, dialog) {
        this.apiService = apiService;
        this.dialog = dialog;
    }
    NodeDownloadDirective.prototype.onClick = function () {
        this.downloadNodes(this.nodes);
    };
    NodeDownloadDirective.prototype.downloadNodes = function (selection) {
        if (!selection || selection.length === 0) {
            return;
        }
        if (selection.length === 1) {
            this.downloadNode(selection[0]);
        }
        else {
            this.downloadZip(selection);
        }
    };
    NodeDownloadDirective.prototype.downloadNode = function (node) {
        if (node && node.entry) {
            var entry = node.entry;
            if (entry.isFile) {
                this.downloadFile(node);
            }
            if (entry.isFolder) {
                this.downloadZip([node]);
            }
            if (!entry.isFile && !entry.isFolder && ((entry)).nodeId) {
                this.downloadFile(node);
            }
        }
    };
    NodeDownloadDirective.prototype.downloadFile = function (node) {
        if (node && node.entry) {
            var contentApi = this.apiService.getInstance().content;
            var url = contentApi.getContentUrl(node.entry.id, true);
            var fileName = node.entry.name;
            this.download(url, fileName);
        }
    };
    NodeDownloadDirective.prototype.downloadZip = function (selection) {
        if (selection && selection.length > 0) {
            var nodeIds = selection.map(function (node) { return (node.entry.nodeId || node.entry.id); });
            this.dialog.open(DownloadZipDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    nodeIds: nodeIds
                }
            });
        }
    };
    NodeDownloadDirective.prototype.download = function (url, fileName) {
        if (url && fileName) {
            var link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };
    return NodeDownloadDirective;
}());
NodeDownloadDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[adfNodeDownload]'
            },] },
];
NodeDownloadDirective.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
    { type: material.MatDialog, },
]; };
NodeDownloadDirective.propDecorators = {
    "nodes": [{ type: core.Input, args: ['adfNodeDownload',] },],
    "onClick": [{ type: core.HostListener, args: ['click',] },],
};
var ShareDialogComponent =               (function () {
    function ShareDialogComponent(sharedLinksApiService, dialogRef, data) {
        this.sharedLinksApiService = sharedLinksApiService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.isFileShared = false;
        this.isDisabled = false;
    }
    ShareDialogComponent.prototype.ngOnInit = function () {
        if (this.data.node && this.data.node.entry) {
            this.fileName = this.data.node.entry.name;
            this.baseShareUrl = this.data.baseShareUrl;
            if (this.data.node.entry.properties && this.data.node.entry.properties['qshare:sharedId']) {
                this.sharedId = this.data.node.entry.properties['qshare:sharedId'];
                this.isFileShared = true;
            }
            else {
                this.createSharedLinks(this.data.node.entry.id);
            }
        }
    };
    ShareDialogComponent.prototype.cancelShare = function () {
        this.dialogRef.close(false);
    };
    ShareDialogComponent.prototype.onSlideShareChange = function (event) {
        this.isDisabled = true;
        if (event.checked) {
            this.createSharedLinks(this.data.node.entry.id);
        }
        else {
            this.deleteSharedLink(this.sharedId);
        }
    };
    ShareDialogComponent.prototype.createSharedLinks = function (nodeId) {
        var _this = this;
        this.sharedLinksApiService.createSharedLinks(nodeId).subscribe(function (sharedLink) {
            if (sharedLink.entry) {
                _this.sharedId = sharedLink.entry.id;
                _this.isFileShared = true;
                _this.isDisabled = false;
            }
        }, function () {
            _this.isFileShared = false;
            _this.isDisabled = false;
        });
    };
    ShareDialogComponent.prototype.deleteSharedLink = function (sharedId) {
        var _this = this;
        this.sharedLinksApiService.deleteSharedLink(sharedId).subscribe(function () {
            _this.isFileShared = false;
            _this.isDisabled = false;
        }, function () {
            _this.isFileShared = true;
            _this.isDisabled = false;
        });
    };
    return ShareDialogComponent;
}());
ShareDialogComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-share-dialog',
                template: "<h1 mat-dialog-title id=\"adf-share-title\" >{{ 'SHARE.TITLE' | translate }} {{fileName}}</h1>\n\n<mat-dialog-content>\n    <span class=\"spacer\"></span>\n\n    <mat-slide-toggle [checked]=\"isFileShared\" [disabled]=\"isDisabled\" (change)=\"onSlideShareChange($event)\">\n        {{ 'SHARE.ACTIONS.SHARE' | translate }}\n    </mat-slide-toggle>\n\n    <span class=\"spacer\"></span>\n\n    .\n\n    <h2 *ngIf=\"isFileShared\">{{ 'SHARE.DESCRIPTION' | translate }}</h2>\n    <div *ngIf=\"isFileShared\">{{ 'SHARE.ALERT' | translate }}</div>\n\n    <form *ngIf=\"isFileShared\">\n        <mat-form-field class=\"full-width\">\n            <input class=\"adf-share-link\" matInput placeholder=\"{{ 'SHARE.PUBLIC-LINK' | translate }}\" [value]=\"baseShareUrl + sharedId\">\n            <mat-icon matPrefix>link</mat-icon>\n        </mat-form-field>\n    </form>\n\n    <h2 *ngIf=\"!isFileShared\">{{ 'SHARE.UNSHARED' | translate }}</h2>\n\n</mat-dialog-content>\n\n<mat-dialog-actions>\n    <button mat-button color=\"primary\" (click)=\"cancelShare()\">\n        {{ 'SHARE.ACTIONS.CLOSE' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                styles: [".spacer{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-share-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}.full-width{width:100%}.adf-share-link{margin-left:10px;font-size:18px!important}"],
                host: { 'class': 'adf-share-dialog' },
                encapsulation: core.ViewEncapsulation.None
            },] },
];
ShareDialogComponent.ctorParameters = function () { return [
    { type: adfCore.SharedLinksApiService, },
    { type: material.MatDialogRef, },
    { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] },] },
]; };
var NodeSharedDirective =               (function () {
    function NodeSharedDirective(dialog, elementRef) {
        this.dialog = dialog;
        this.elementRef = elementRef;
    }
    NodeSharedDirective.prototype.onClick = function () {
        this.shareNode(this.node);
    };
    NodeSharedDirective.prototype.shareNode = function (node) {
        if (node.entry && node.entry.isFile) {
            this.setDisableAttribute(true);
            this.dialog.open(ShareDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    node: node,
                    baseShareUrl: this.baseShareUrl
                }
            });
        }
        else {
            this.setDisableAttribute(true);
        }
    };
    NodeSharedDirective.prototype.ngOnChanges = function () {
        if (!this.node || this.node.entry.isFolder) {
            this.setDisableAttribute(true);
        }
        else {
            this.setDisableAttribute(false);
        }
    };
    NodeSharedDirective.prototype.setDisableAttribute = function (disable) {
        this.elementRef.nativeElement.disabled = disable;
    };
    return NodeSharedDirective;
}());
NodeSharedDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[adf-share]'
            },] },
];
NodeSharedDirective.ctorParameters = function () { return [
    { type: material.MatDialog, },
    { type: core.ElementRef, },
]; };
NodeSharedDirective.propDecorators = {
    "node": [{ type: core.Input, args: ['adf-share',] },],
    "baseShareUrl": [{ type: core.Input },],
    "onClick": [{ type: core.HostListener, args: ['click',] },],
};
function modules() {
    return [
        material.MatButtonModule,
        material.MatChipsModule,
        material.MatDialogModule,
        material.MatIconModule,
        material.MatCardModule,
        material.MatInputModule,
        material.MatListModule,
        material.MatProgressSpinnerModule,
        material.MatProgressBarModule,
        material.MatRippleModule,
        material.MatMenuModule,
        material.MatOptionModule,
        material.MatExpansionModule,
        material.MatSelectModule,
        material.MatCheckboxModule,
        material.MatDatepickerModule,
        material.MatSlideToggleModule
    ];
}
var MaterialModule =               (function () {
    function MaterialModule() {
    }
    return MaterialModule;
}());
MaterialModule.decorators = [
    { type: core.NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] },
];
MaterialModule.ctorParameters = function () { return []; };
var DocumentListService =               (function () {
    function DocumentListService(authService, contentService, apiService, logService, thumbnailService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
    }
    DocumentListService.prototype.getNodesPromise = function (folder, opts, includeFields) {
        if (includeFields === void 0) { includeFields = []; }
        var rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        var includeFieldsRequest = __spread(['path', 'properties', 'allowableOperations', 'permissions'], includeFields).filter(function (element, index, array) { return index === array.indexOf(element); });
        var params = {
            includeSource: true,
            include: includeFieldsRequest
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
        }
        return this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params);
    };
    DocumentListService.prototype.deleteNode = function (nodeId) {
        return Observable.Observable.fromPromise(this.apiService.getInstance().nodes.deleteNode(nodeId));
    };
    DocumentListService.prototype.copyNode = function (nodeId, targetParentId) {
        var _this = this;
        return Observable.Observable.fromPromise(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId: targetParentId }))
            .catch(function (err) { return _this.handleError(err); });
    };
    DocumentListService.prototype.moveNode = function (nodeId, targetParentId) {
        var _this = this;
        return Observable.Observable.fromPromise(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId: targetParentId }))
            .catch(function (err) { return _this.handleError(err); });
    };
    DocumentListService.prototype.createFolder = function (name, parentId) {
        var _this = this;
        var observable = Observable.Observable.fromPromise(this.apiService.getInstance().nodes.createFolder(name, '/', parentId));
        observable.catch(function (err) { return _this.handleError(err); });
        return observable;
    };
    DocumentListService.prototype.getFolder = function (folder, opts, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        return Observable.Observable.fromPromise(this.getNodesPromise(folder, opts, includeFields))
            .map(function (res) { return (res); })
            .catch(function (err) { return _this.handleError(err); });
    };
    DocumentListService.prototype.getNode = function (nodeId, includeFields) {
        if (includeFields === void 0) { includeFields = []; }
        var includeFieldsRequest = __spread(['path', 'properties', 'allowableOperations', 'permissions'], includeFields).filter(function (element, index, array) { return index === array.indexOf(element); });
        var opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return this.contentService.getNode(nodeId, opts);
    };
    DocumentListService.prototype.getFolderNode = function (nodeId, includeFields) {
        if (includeFields === void 0) { includeFields = []; }
        var includeFieldsRequest = __spread(['path', 'properties', 'allowableOperations', 'permissions'], includeFields).filter(function (element, index, array) { return index === array.indexOf(element); });
        var opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return Observable.Observable.fromPromise(this.apiService.getInstance().nodes.getNodeInfo(nodeId, opts));
    };
    DocumentListService.prototype.getDocumentThumbnailUrl = function (node) {
        return this.thumbnailService.getDocumentThumbnailUrl(node);
    };
    DocumentListService.prototype.getMimeTypeIcon = function (mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    };
    DocumentListService.prototype.getDefaultMimeTypeIcon = function () {
        return this.thumbnailService.getDefaultMimeTypeIcon();
    };
    DocumentListService.prototype.hasPermission = function (node, permission) {
        return this.contentService.hasPermission(node, permission);
    };
    DocumentListService.prototype.handleError = function (error) {
        this.logService.error(error);
        return Observable.Observable.throw(error || 'Server error');
    };
    return DocumentListService;
}());
DocumentListService.ROOT_ID = '-root-';
DocumentListService.decorators = [
    { type: core.Injectable },
];
DocumentListService.ctorParameters = function () { return [
    { type: adfCore.AuthenticationService, },
    { type: adfCore.ContentService, },
    { type: adfCore.AlfrescoApiService, },
    { type: adfCore.LogService, },
    { type: adfCore.ThumbnailService, },
]; };
var ContentNodeSelectorComponent =               (function () {
    function ContentNodeSelectorComponent(data) {
        this.data = data;
        this.title = null;
        this.currentFolderId = null;
        this.dropdownHideMyFiles = false;
        this.dropdownSiteList = null;
        this.rowFilter = null;
        this.imageResolver = null;
        this.buttonActionName = data.actionName ? "NODE_SELECTOR." + data.actionName.toUpperCase() : 'NODE_SELECTOR.CHOOSE';
    }
    ContentNodeSelectorComponent.prototype.close = function () {
        this.data.select.complete();
    };
    ContentNodeSelectorComponent.prototype.onSelect = function (nodeList) {
        this.chosenNode = nodeList;
    };
    ContentNodeSelectorComponent.prototype.onClick = function () {
        this.data.select.next(this.chosenNode);
        this.data.select.complete();
    };
    return ContentNodeSelectorComponent;
}());
ContentNodeSelectorComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-content-node-selector',
                template: "<header\n    mat-dialog-title\n    data-automation-id=\"content-node-selector-title\">{{title || data?.title}}\n</header>\n\n<mat-dialog-content>\n    <adf-content-node-selector-panel\n        [currentFolderId]=\"currentFolderId || data?.currentFolderId\"\n        [dropdownHideMyFiles]=\"dropdownHideMyFiles || data?.dropdownHideMyFiles\"\n        [dropdownSiteList]=\"dropdownSiteList || data?.dropdownSiteList\"\n        [rowFilter]=\"rowFilter || data?.rowFilter\"\n        [imageResolver]=\"imageResolver || data?.imageResolver\"\n        [isSelectionValid]=\"data?.isSelectionValid\"\n        [breadcrumbTransform]=\"data?.breadcrumbTransform\"\n        (select)=\"onSelect($event)\">\n    </adf-content-node-selector-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"content-node-selector-actions-cancel\">{{ 'NODE_SELECTOR.CANCEL' | translate }}\n    </button>\n\n    <button mat-button\n        [disabled]=\"!chosenNode\"\n        class=\"choose-action\"\n        (click)=\"onClick()\"\n        data-automation-id=\"content-node-selector-actions-choose\">{{ buttonActionName | translate }}\n    </button>\n</mat-dialog-actions>\n\n",
                styles: [""],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
ContentNodeSelectorComponent.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] },] },
]; };
ContentNodeSelectorComponent.propDecorators = {
    "title": [{ type: core.Input },],
    "currentFolderId": [{ type: core.Input },],
    "dropdownHideMyFiles": [{ type: core.Input },],
    "dropdownSiteList": [{ type: core.Input },],
    "rowFilter": [{ type: core.Input },],
    "imageResolver": [{ type: core.Input },],
    "pageSize": [{ type: core.Input },],
};
var NodeLockDialogComponent =               (function () {
    function NodeLockDialogComponent(formBuilder, dialog, alfrescoApi, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.alfrescoApi = alfrescoApi;
        this.data = data;
        this.node = null;
    }
    NodeLockDialogComponent.prototype.ngOnInit = function () {
        var node = this.data.node;
        this.nodeName = node.name;
        this.form = this.formBuilder.group({
            isLocked: node.isLocked || false,
            allowOwner: node.properties['cm:lockType'] === 'WRITE_LOCK',
            isTimeLock: !!node.properties['cm:expiryDate'],
            time: !!node.properties['cm:expiryDate'] ? moment(node.properties['cm:expiryDate']) : moment()
        });
    };
    Object.defineProperty(NodeLockDialogComponent.prototype, "lockTimeInSeconds", {
        get: function () {
            if (this.form.value.isTimeLock) {
                var duration = moment.duration(moment(this.form.value.time).diff(moment()));
                return duration.asSeconds();
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeLockDialogComponent.prototype, "nodeBodyLock", {
        get: function () {
            return {
                'timeToExpire': this.lockTimeInSeconds,
                'type': this.form.value.allowOwner ? 'ALLOW_OWNER_CHANGES' : 'FULL',
                'lifetime': 'PERSISTENT'
            };
        },
        enumerable: true,
        configurable: true
    });
    NodeLockDialogComponent.prototype.toggleLock = function () {
        var _b = this, nodesApi = _b.alfrescoApi.nodesApi, node = _b.data.node;
        if (this.form.value.isLocked) {
            return nodesApi.lockNode(node.id, this.nodeBodyLock);
        }
        return nodesApi.unlockNode(node.id);
    };
    NodeLockDialogComponent.prototype.submit = function () {
        var _this = this;
        this.toggleLock()
            .then(function (node) {
            _this.data.node.isLocked = _this.form.value.isLocked;
            _this.dialog.close(node.entry);
        })
            .catch(function (error) { return _this.data.onError(error); });
    };
    return NodeLockDialogComponent;
}());
NodeLockDialogComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-node-lock',
                styles: [".adf-fill-remaining-space{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-full-width{width:100%}"],
                template: "<h2 mat-dialog-title>\n    {{ 'CORE.FILE_DIALOG.FILE_LOCK' | translate }}\n</h2>\n\n<mat-dialog-content>\n    <br />\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-checkbox [formControl]=\"form.controls['isLocked']\" ngDefaultControl>\n            {{ 'CORE.FILE_DIALOG.FILE_LOCK_CHECKBOX' | translate }} <strong>\"{{ nodeName }}\"</strong>\n        </mat-checkbox>\n\n        <br />\n\n        <div *ngIf=\"form.value.isLocked\">\n            <mat-checkbox [formControl]=\"form.controls['allowOwner']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.ALLOW_OTHERS_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-checkbox [formControl]=\"form.controls['isTimeLock']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.TIME_LOCK_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-form-field *ngIf=\"form.value.isTimeLock\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input matInput [formControl]=\"form.controls['time']\" [matDatetimepicker]=\"datetimePicker\" required autocomplete=\"false\">\n            </mat-form-field>\n        </div>\n    </form>\n    <br />\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button mat-button mat-dialog-close>\n        {{ 'CORE.FILE_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\" mat-button (click)=\"submit()\">\n        {{ 'CORE.FILE_DIALOG.SAVE_BUTTON.LABEL' | translate }}\n    </button>\n</mat-dialog-actions>\n"
            },] },
];
NodeLockDialogComponent.ctorParameters = function () { return [
    { type: forms.FormBuilder, },
    { type: material.MatDialogRef, },
    { type: adfCore.AlfrescoApiService, },
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_DIALOG_DATA,] },] },
]; };
var ContentNodeDialogService =               (function () {
    function ContentNodeDialogService(dialog, contentService, documentListService, siteService, translation) {
        this.dialog = dialog;
        this.contentService = contentService;
        this.documentListService = documentListService;
        this.siteService = siteService;
        this.translation = translation;
        this.error = new core.EventEmitter();
    }
    ContentNodeDialogService.prototype.openFileBrowseDialogByFolderId = function (folderNodeId) {
        var _this = this;
        return this.documentListService.getFolderNode(folderNodeId).switchMap(function (node) {
            return _this.openUploadFileDialog('Choose', node);
        });
    };
    ContentNodeDialogService.prototype.openLockNodeDialog = function (contentEntry) {
        var _this = this;
        var observable = new Subject.Subject();
        if (this.contentService.hasPermission(contentEntry, adfCore.PermissionsEnum.LOCK)) {
            this.dialog.open(NodeLockDialogComponent, {
                data: {
                    node: contentEntry,
                    onError: function (error) {
                        _this.error.emit(error);
                        observable.error(error);
                    }
                },
                width: '400px'
            });
        }
        else {
            observable.error('OPERATION.FAIL.NODE.NO_PERMISSION');
        }
        return observable;
    };
    ContentNodeDialogService.prototype.openFileBrowseDialogBySite = function () {
        var _this = this;
        return this.siteService.getSites().switchMap(function (response) {
            return _this.openFileBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        });
    };
    ContentNodeDialogService.prototype.openFolderBrowseDialogBySite = function () {
        var _this = this;
        return this.siteService.getSites().switchMap(function (response) {
            return _this.openFolderBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        });
    };
    ContentNodeDialogService.prototype.openFolderBrowseDialogByFolderId = function (folderNodeId) {
        var _this = this;
        return this.documentListService.getFolderNode(folderNodeId).switchMap(function (node) {
            return _this.openUploadFolderDialog('Choose', node);
        });
    };
    ContentNodeDialogService.prototype.openCopyMoveDialog = function (action, contentEntry, permission) {
        if (this.contentService.hasPermission(contentEntry, permission)) {
            var select = new Subject.Subject();
            select.subscribe({
                complete: this.close.bind(this)
            });
            var title = this.getTitleTranslation(action, contentEntry.name);
            var data = {
                title: title,
                actionName: action,
                currentFolderId: contentEntry.parentId,
                imageResolver: this.imageResolver.bind(this),
                rowFilter: this.rowFilter.bind(this, contentEntry.id),
                isSelectionValid: this.isCopyMoveSelectionValid.bind(this),
                select: select
            };
            this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
            return select;
        }
        else {
            var errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            return Observable.Observable.throw(errors);
        }
    };
    ContentNodeDialogService.prototype.getTitleTranslation = function (action, name) {
        return this.translation.instant("NODE_SELECTOR." + action.toUpperCase() + "_ITEM", { name: name });
    };
    ContentNodeDialogService.prototype.openUploadFolderDialog = function (action, contentEntry) {
        var select = new Subject.Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        var data = {
            title: action + " '" + contentEntry.name + "' to ...",
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.hasPermissionOnNodeFolder.bind(this),
            rowFilter: this.rowFilter.bind(this, contentEntry.id),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    };
    ContentNodeDialogService.prototype.openUploadFileDialog = function (action, contentEntry) {
        var select = new Subject.Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        var data = {
            title: action + " '" + contentEntry.name + "' to ...",
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.isNodeFile.bind(this),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    };
    ContentNodeDialogService.prototype.openContentNodeDialog = function (data, currentPanelClass, chosenWidth) {
        this.dialog.open(ContentNodeSelectorComponent, { data: data, panelClass: currentPanelClass, width: chosenWidth });
    };
    ContentNodeDialogService.prototype.imageResolver = function (row, col) {
        var entry = row.node.entry;
        if (!this.contentService.hasPermission(entry, 'create')) {
            return this.documentListService.getMimeTypeIcon('disable/folder');
        }
        return null;
    };
    ContentNodeDialogService.prototype.rowFilter = function (currentNodeId, row) {
        var node = row.node.entry;
        if (node.id === currentNodeId || node.isFile) {
            return false;
        }
        else {
            return true;
        }
    };
    ContentNodeDialogService.prototype.isNodeFile = function (entry) {
        return entry.isFile;
    };
    ContentNodeDialogService.prototype.hasPermissionOnNodeFolder = function (entry) {
        return this.isNodeFolder(entry) && this.contentService.hasPermission(entry, 'create');
    };
    ContentNodeDialogService.prototype.isNodeFolder = function (entry) {
        return entry.isFolder;
    };
    ContentNodeDialogService.prototype.isCopyMoveSelectionValid = function (entry) {
        return this.hasEntityCreatePermission(entry) && !this.isSite(entry);
    };
    ContentNodeDialogService.prototype.hasEntityCreatePermission = function (entry) {
        return this.contentService.hasPermission(entry, 'create');
    };
    ContentNodeDialogService.prototype.isSite = function (entry) {
        return !!entry.guid || entry.nodeType === 'st:site' || entry.nodeType === 'st:sites';
    };
    ContentNodeDialogService.prototype.close = function () {
        this.dialog.closeAll();
    };
    return ContentNodeDialogService;
}());
ContentNodeDialogService.decorators = [
    { type: core.Injectable },
];
ContentNodeDialogService.ctorParameters = function () { return [
    { type: material.MatDialog, },
    { type: adfCore.ContentService, },
    { type: DocumentListService, },
    { type: adfCore.SitesService, },
    { type: adfCore.TranslationService, },
]; };
ContentNodeDialogService.propDecorators = {
    "error": [{ type: core.Output },],
};
var NodeLockDirective =               (function () {
    function NodeLockDirective(element, renderer, contentService, contentNodeDialogService) {
        this.element = element;
        this.renderer = renderer;
        this.contentService = contentService;
        this.contentNodeDialogService = contentNodeDialogService;
    }
    NodeLockDirective.prototype.onClick = function (event) {
        event.preventDefault();
        this.contentNodeDialogService.openLockNodeDialog(this.node);
    };
    NodeLockDirective.prototype.ngAfterViewInit = function () {
        var hasPermission = this.contentService.hasPermission(this.node, adfCore.PermissionsEnum.LOCK);
        this.renderer.setProperty(this.element.nativeElement, 'disabled', !hasPermission);
    };
    return NodeLockDirective;
}());
NodeLockDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[adf-node-lock]'
            },] },
];
NodeLockDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
    { type: adfCore.ContentService, },
    { type: ContentNodeDialogService, },
]; };
NodeLockDirective.propDecorators = {
    "node": [{ type: core.Input, args: ['adf-node-lock',] },],
    "onClick": [{ type: core.HostListener, args: ['click', ['$event'],] },],
};
var ContentDirectiveModule =               (function () {
    function ContentDirectiveModule() {
    }
    return ContentDirectiveModule;
}());
ContentDirectiveModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule
                ],
                declarations: [
                    NodeDownloadDirective,
                    NodeSharedDirective,
                    NodeLockDirective
                ],
                exports: [
                    NodeDownloadDirective,
                    NodeSharedDirective,
                    NodeLockDirective
                ]
            },] },
];
ContentDirectiveModule.ctorParameters = function () { return []; };
var RatingService =               (function () {
    function RatingService(apiService) {
        this.apiService = apiService;
    }
    RatingService.prototype.getRating = function (nodeId, ratingType) {
        return Observable.Observable.fromPromise(this.apiService.getInstance().core.ratingsApi.getRating(nodeId, ratingType))
            .map(function (res) { return res; })
            .catch(this.handleError);
    };
    RatingService.prototype.postRating = function (nodeId, ratingType, vote) {
        var ratingBody = {
            'id': ratingType,
            'myRating': vote
        };
        return Observable.Observable.fromPromise(this.apiService.getInstance().core.ratingsApi.rate(nodeId, ratingBody))
            .map(function (res) { return res; })
            .catch(this.handleError);
    };
    RatingService.prototype.deleteRating = function (nodeId, ratingType) {
        return Observable.Observable.fromPromise(this.apiService.getInstance().core.ratingsApi.removeRating(nodeId, ratingType))
            .map(function (res) { return res; })
            .catch(this.handleError);
    };
    RatingService.prototype.handleError = function (error) {
        console.error(error);
        return Observable.Observable.throw(error || 'Server error');
    };
    return RatingService;
}());
RatingService.decorators = [
    { type: core.Injectable },
];
RatingService.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
]; };
var RatingComponent =               (function () {
    function RatingComponent(ratingService) {
        this.ratingService = ratingService;
        this.average = 0;
        this.ratingType = 'fiveStar';
        this.changeVote = new core.EventEmitter();
        this.stars = [];
    }
    RatingComponent.prototype.ngOnChanges = function () {
        var _this = this;
        var ratingObserver = this.ratingService.getRating(this.nodeId, this.ratingType);
        ratingObserver.subscribe(function (data) {
            if (data.entry.aggregate) {
                _this.average = data.entry.aggregate.average;
                _this.calculateStars();
            }
        });
        return ratingObserver;
    };
    RatingComponent.prototype.calculateStars = function () {
        this.stars = [];
        for (var i = 0; i < 5; i++) {
            if (i < this.average) {
                this.stars.push({ fill: true });
            }
            else {
                this.stars.push({ fill: false });
            }
        }
        this.changeVote.emit(this.average);
    };
    RatingComponent.prototype.updateVote = function (vote) {
        var _this = this;
        this.ratingService.postRating(this.nodeId, this.ratingType, vote).subscribe(function (data) {
            if (data.entry.aggregate) {
                if (_this.average !== data.entry.aggregate.average) {
                    _this.average = data.entry.aggregate.average;
                    _this.calculateStars();
                }
            }
        });
    };
    return RatingComponent;
}());
RatingComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-rating',
                styles: [".adf-rating-container{overflow:hidden;width:100%}.adf-rating-container .adf-rating-star{float:left;-webkit-transition:all .3s;transition:all .3s;padding:1px;cursor:pointer}.adf-rating-container .adf-rating-star .mat-list-item-content{padding:0 2px!important}.adf-rating-container .adf-colored-star{color:#ffe944}.adf-rating-container .adf-grey-star{color:grey}.adf-rating-container .adf-stars-container{padding:0!important;margin:0!important;display:inline-block}.adf-rating-container .adf-rating-star:hover{-webkit-transform:rotate(13deg) scale(1.2);transform:rotate(13deg) scale(1.2)}"],
                template: "<mat-list id=\"adf-rating-container\" class=\"adf-rating-container\">\n    <mat-list-item class=\"adf-rating-star\" *ngFor=\"let currentRate of stars; let idx = index\">\n            <span id=\"adf-rate-{{idx}}\">\n                <mat-icon id=\"adf-grey-star-{{idx}}\" *ngIf=\"currentRate.fill\" class=\"adf-colored-star\"\n                         (click)=\"updateVote(idx + 1)\">star_rate\n                </mat-icon>\n                <mat-icon id=\"adf-colored-star-{{idx}}\" *ngIf=\"!currentRate.fill\" class=\"adf-grey-star\"\n                         (click)=\"updateVote(idx + 1)\">star_border\n                </mat-icon>\n            </span>\n    </mat-list-item>\n</mat-list>\n",
                encapsulation: core.ViewEncapsulation.None
            },] },
];
RatingComponent.ctorParameters = function () { return [
    { type: RatingService, },
]; };
RatingComponent.propDecorators = {
    "nodeId": [{ type: core.Input },],
    "changeVote": [{ type: core.Output },],
};
var LikeComponent =               (function () {
    function LikeComponent(ratingService) {
        this.ratingService = ratingService;
        this.changeVote = new core.EventEmitter();
        this.likesCounter = 0;
        this.ratingType = 'likes';
        this.isLike = false;
    }
    LikeComponent.prototype.ngOnChanges = function () {
        var _this = this;
        this.clean();
        this.ratingService.getRating(this.nodeId, this.ratingType).subscribe(function (data) {
            if (data.entry.aggregate) {
                _this.likesCounter = data.entry.aggregate.numberOfRatings;
                if (data.entry.ratedAt) {
                    _this.isLike = true;
                }
            }
        });
    };
    LikeComponent.prototype.likeClick = function () {
        var _this = this;
        if (this.isLike) {
            this.ratingService.deleteRating(this.nodeId, this.ratingType).subscribe(function () {
                _this.likesCounter -= 1;
                _this.isLike = false;
                _this.changeVote.emit(_this.likesCounter);
            });
        }
        else {
            this.ratingService.postRating(this.nodeId, this.ratingType, true).subscribe(function (data) {
                _this.likesCounter = data.entry.aggregate.numberOfRatings;
                _this.isLike = true;
                _this.changeVote.emit(_this.likesCounter);
            });
        }
    };
    LikeComponent.prototype.clean = function () {
        this.isLike = false;
        this.likesCounter = 0;
    };
    return LikeComponent;
}());
LikeComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-like',
                styles: [".adf-like-container{overflow:hidden;width:100%}.adf-like-container .adf-like{padding:5px;cursor:pointer;float:left;margin:5px 0 5px 5px}.adf-like-container .adf-like-select{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-grey,.adf-like-container .adf-like-select:hover{cursor:pointer;color:grey}.adf-like-container .adf-like-grey:hover{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-counter{float:left;padding:13px 0 0}.adf-like-container .adf-left{float:left;padding:13px 0 0 4px}"],
                template: "<div id=\"adf-like-container\" class=\"adf-like-container\">\n    <div class=\"adf-like\">\n        <span id=\"adf-like-{{nodeId}}\" [ngClass]=\"{'adf-like-select': isLike ,'adf-like-grey': !isLike  }\"\n              (click)=\"likeClick()\">\n            <mat-icon>thumb_up</mat-icon>\n        </span>\n    </div>\n    <div id=\"adf-like-counter\" class=\"adf-like-counter\">{{likesCounter}}</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter<=1\">Like</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter>1\">Likes</div>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None
            },] },
];
LikeComponent.ctorParameters = function () { return [
    { type: RatingService, },
]; };
LikeComponent.propDecorators = {
    "nodeId": [{ type: core.Input },],
    "changeVote": [{ type: core.Output },],
};
var SocialModule =               (function () {
    function SocialModule() {
    }
    return SocialModule;
}());
SocialModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule
                ],
                exports: [
                    RatingComponent,
                    LikeComponent
                ],
                declarations: [
                    RatingComponent,
                    LikeComponent
                ]
            },] },
];
SocialModule.ctorParameters = function () { return []; };
var TagService =               (function () {
    function TagService(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.refresh = new core.EventEmitter();
    }
    TagService.prototype.getTagsByNodeId = function (nodeId) {
        var _this = this;
        return Observable.Observable.fromPromise(this.apiService.getInstance().core.tagsApi.getNodeTags(nodeId))
            .catch(function (err) { return _this.handleError(err); });
    };
    TagService.prototype.getAllTheTags = function () {
        var _this = this;
        return Observable.Observable.fromPromise(this.apiService.getInstance().core.tagsApi.getTags())
            .catch(function (err) { return _this.handleError(err); });
    };
    TagService.prototype.addTag = function (nodeId, tagName) {
        var _this = this;
        var alfrescoApi = this.apiService.getInstance();
        var tagBody = new alfrescoApi.core.TagBody();
        tagBody.tag = tagName;
        var promiseAdd = Observable.Observable.fromPromise(this.apiService.getInstance().core.tagsApi.addTag(nodeId, tagBody));
        promiseAdd.subscribe(function (data) {
            _this.refresh.emit(data);
        }, function (err) {
            _this.handleError(err);
        });
        return promiseAdd;
    };
    TagService.prototype.removeTag = function (nodeId, tag) {
        var _this = this;
        var promiseRemove = Observable.Observable.fromPromise(this.apiService.getInstance().core.tagsApi.removeTag(nodeId, tag));
        promiseRemove.subscribe(function (data) {
            _this.refresh.emit(data);
        }, function (err) {
            _this.handleError(err);
        });
        return promiseRemove;
    };
    TagService.prototype.handleError = function (error) {
        this.logService.error(error);
        return Observable.Observable.throw(error || 'Server error');
    };
    return TagService;
}());
TagService.decorators = [
    { type: core.Injectable },
];
TagService.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
    { type: adfCore.LogService, },
]; };
TagService.propDecorators = {
    "refresh": [{ type: core.Output },],
};
var TagActionsComponent =               (function () {
    function TagActionsComponent(tagService, translateService) {
        var _this = this;
        this.tagService = tagService;
        this.translateService = translateService;
        this.successAdd = new core.EventEmitter();
        this.error = new core.EventEmitter();
        this.result = new core.EventEmitter();
        this.disableAddTag = true;
        this.tagService.refresh.subscribe(function () {
            _this.refreshTag();
        });
    }
    TagActionsComponent.prototype.ngOnChanges = function () {
        return this.refreshTag();
    };
    TagActionsComponent.prototype.refreshTag = function () {
        var _this = this;
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe(function (data) {
                _this.tagsEntries = data.list.entries;
                _this.disableAddTag = false;
                _this.result.emit(_this.tagsEntries);
            }, function () {
                _this.tagsEntries = null;
                _this.disableAddTag = true;
                _this.result.emit(_this.tagsEntries);
            });
        }
    };
    TagActionsComponent.prototype.addTag = function () {
        var _this = this;
        if (this.searchTag(this.newTagName)) {
            this.translateService.get('TAG.MESSAGES.EXIST').subscribe(function (error) {
                _this.errorMsg = error;
            });
            this.error.emit(this.errorMsg);
        }
        else {
            this.tagService.addTag(this.nodeId, this.newTagName).subscribe(function () {
                _this.newTagName = '';
                _this.successAdd.emit(_this.nodeId);
            });
        }
    };
    TagActionsComponent.prototype.searchTag = function (searchTagName) {
        if (this.tagsEntries) {
            return this.tagsEntries.find(function (currentTag) {
                return (searchTagName === currentTag.entry.tag);
            });
        }
    };
    TagActionsComponent.prototype.cleanErrorMsg = function () {
        this.errorMsg = '';
    };
    TagActionsComponent.prototype.removeTag = function (tag) {
        this.tagService.removeTag(this.nodeId, tag);
    };
    return TagActionsComponent;
}());
TagActionsComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-tag-node-actions-list',
                template: "<mat-list>\n    <mat-list-item *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <div class=\"adf-tag-actions-container\" id=\"tag_delete_{{idx}}\" (click)=\"removeTag(currentEntry.entry.id)\">\n            <div class=\"adf-tag-actions-delete-text\" id=\"tag_name_{{idx}}\">\n                {{currentEntry.entry.tag}}\n            </div>\n            <mat-icon class=\"adf-tag-actions-delete-icon\">delete</mat-icon>\n        </div>\n    </mat-list-item>\n</mat-list>\n<table class=\"adf-full-width\" cellspacing=\"0\">\n    <tr>\n        <td>\n            <mat-form-field class=\"adf-full-width\">\n                <input matInput placeholder=\"{{'TAG.LABEL.NEWTAG' | translate }}\"\n                       type=\"text\"\n                       (keypress)=\"cleanErrorMsg()\"\n                       [(ngModel)]=\"newTagName\"\n                       id=\"new-tag-text\"/>\n                <mat-hint data-automation-id=\"errorMessage\" *ngIf=\"error\" [ngStyle]=\"{'color': 'red'}\" align=\"start\">{{errorMsg}}</mat-hint>\n            </mat-form-field>\n        </td>\n        <td>\n            <button class=\"adf-full-width\" color=\"primary\" id=\"add-tag\" (click)=\"addTag()\" [disabled]=\"disableAddTag\"\n                    mat-raised-button>\n                {{'TAG.BUTTON.ADD' | translate }}\n            </button>\n        </td>\n    </tr>\n</table>\n",
                styles: [".adf-full-width{width:100%}.adf-tag-actions-delete-icon{float:right;cursor:pointer}.adf-tag-actions-delete-text{font-size:16px;float:left}.adf-tag-actions-container{padding:8px 0;height:20px}"],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
TagActionsComponent.ctorParameters = function () { return [
    { type: TagService, },
    { type: adfCore.TranslationService, },
]; };
TagActionsComponent.propDecorators = {
    "nodeId": [{ type: core.Input },],
    "successAdd": [{ type: core.Output },],
    "error": [{ type: core.Output },],
    "result": [{ type: core.Output },],
};
var TagListComponent =               (function () {
    function TagListComponent(tagService) {
        var _this = this;
        this.tagService = tagService;
        this.result = new core.EventEmitter();
        this.tagService.refresh.subscribe(function () {
            _this.refreshTag();
        });
    }
    TagListComponent.prototype.ngOnInit = function () {
        return this.refreshTag();
    };
    TagListComponent.prototype.refreshTag = function () {
        var _this = this;
        this.tagService.getAllTheTags().subscribe(function (data) {
            _this.tagsEntries = data.list.entries;
            _this.result.emit(_this.tagsEntries);
        });
    };
    return TagListComponent;
}());
TagListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-tag-list',
                template: "<mat-list>\n    <mat-list-item *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <div class=\"adf-list-tag\" id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</div>\n    </mat-list-item>\n</mat-list>\n",
                styles: [".adf-list-tag{padding:16px;font-size:16px}"],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
TagListComponent.ctorParameters = function () { return [
    { type: TagService, },
]; };
TagListComponent.propDecorators = {
    "result": [{ type: core.Output },],
};
var TagNodeListComponent =               (function () {
    function TagNodeListComponent(tagService) {
        var _this = this;
        this.tagService = tagService;
        this.results = new core.EventEmitter();
        this.tagService.refresh.subscribe(function () {
            _this.refreshTag();
        });
    }
    TagNodeListComponent.prototype.ngOnChanges = function () {
        return this.refreshTag();
    };
    TagNodeListComponent.prototype.refreshTag = function () {
        var _this = this;
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe(function (data) {
                _this.tagsEntries = data.list.entries;
                _this.results.emit(_this.tagsEntries);
            });
        }
    };
    TagNodeListComponent.prototype.removeTag = function (tag) {
        var _this = this;
        this.tagService.removeTag(this.nodeId, tag).subscribe(function () {
            _this.refreshTag();
        });
    };
    return TagNodeListComponent;
}());
TagNodeListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-tag-node-list',
                template: "<mat-chip-list>\n    <mat-chip class=\"adf-tag-chips adf-primary-background-color\" *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        <button class=\"adf-tag-chips-delete\" id=\"tag_delete_{{idx}}\" type=\"button\" (click)=\"removeTag(currentEntry.entry.id)\">\n            <mat-icon class=\"adf-tag-chips-delete-icon adf-primary-contrast-text-color\" matChipRemove>cancel</mat-icon>\n        </button>\n    </mat-chip>\n</mat-chip-list>\n",
                styles: [".adf-tag-chips-delete{overflow:visible;cursor:pointer;height:17px;width:20px;float:right;border:0;background:0 0;padding:0;margin:-1px 0 0 10px}.adf-tag-chips-delete-icon{font-size:20px;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:20px;width:20px}"],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
TagNodeListComponent.ctorParameters = function () { return [
    { type: TagService, },
]; };
TagNodeListComponent.propDecorators = {
    "nodeId": [{ type: core.Input },],
    "results": [{ type: core.Output },],
};
var TagModule =               (function () {
    function TagModule() {
    }
    return TagModule;
}());
TagModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    forms.FormsModule,
                    forms.ReactiveFormsModule
                ],
                exports: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                declarations: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                providers: [
                    TagService
                ]
            },] },
];
TagModule.ctorParameters = function () { return []; };
var WebscriptComponent =               (function () {
    function WebscriptComponent(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.showData = true;
        this.contextRoot = 'alfresco';
        this.servicePath = 'service';
        this.contentType = 'TEXT';
        this.success = new core.EventEmitter();
        this.data = undefined;
        this.showError = false;
    }
    WebscriptComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.showData) {
            this.clean();
        }
        return new Promise(function (resolve, reject) {
            _this.apiService.getInstance().webScript.executeWebScript('GET', _this.scriptPath, _this.scriptArgs, _this.contextRoot, _this.servicePath).then(function (webScriptdata) {
                _this.data = webScriptdata;
                if (_this.showData) {
                    if (_this.contentType === 'DATATABLE') {
                        _this.data = _this.showDataAsDataTable(webScriptdata);
                    }
                }
                _this.success.emit(_this.data);
                resolve();
            }, function (error) {
                _this.logService.log('Error' + error);
                reject();
            });
        });
    };
    WebscriptComponent.prototype.showDataAsDataTable = function (data) {
        var datatableData = null;
        try {
            if (!data.schema) {
                data.schema = adfCore.ObjectDataTableAdapter.generateSchema(data.data);
            }
            if (data.schema && data.schema.length > 0) {
                this.data = new adfCore.ObjectDataTableAdapter(data.data, data.schema);
            }
        }
        catch (e) {
            this.logService.error('error during the cast as datatable');
        }
        return datatableData;
    };
    WebscriptComponent.prototype.clean = function () {
        this.data = undefined;
    };
    WebscriptComponent.prototype.isDataTableContent = function () {
        return this.contentType === 'DATATABLE';
    };
    return WebscriptComponent;
}());
WebscriptComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-webscript-get',
                template: "<div *ngIf=\"showData\">\n    <div *ngIf=\"contentType === 'JSON'\" id=\"webscript-data-JSON\">{{data | json}}</div>\n    <div *ngIf=\"contentType === 'HTML'\" id=\"webscript-data-HTML\" [innerHTML]=\"data\"></div>\n    <div *ngIf=\"contentType === 'TEXT'\" id=\"webscript-data-TEXT\">{{data}}</div>\n    <div *ngIf=\"isDataTableContent()\">\n        <adf-datatable id=\"webscript-datatable-wrapper\" [data]=\"data\"></adf-datatable>\n        <div>\n            <div *ngIf=\"showError\" id=\"error\">{{'WEBSCRIPT.ERROR' | translate: {\n                data: data,\n                contentType: contentType\n                }\n                }}\n            </div>\n        </div>\n    </div>\n</div>\n"
            },] },
];
WebscriptComponent.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
    { type: adfCore.LogService, },
]; };
WebscriptComponent.propDecorators = {
    "scriptPath": [{ type: core.Input },],
    "scriptArgs": [{ type: core.Input },],
    "showData": [{ type: core.Input },],
    "contextRoot": [{ type: core.Input },],
    "servicePath": [{ type: core.Input },],
    "contentType": [{ type: core.Input },],
    "success": [{ type: core.Output },],
};
var WebScriptModule =               (function () {
    function WebScriptModule() {
    }
    return WebScriptModule;
}());
WebScriptModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    adfCore.PipeModule,
                    MaterialModule,
                    adfCore.DataTableModule,
                    core$1.TranslateModule
                ],
                exports: [
                    WebscriptComponent
                ],
                declarations: [
                    WebscriptComponent
                ]
            },] },
];
WebScriptModule.ctorParameters = function () { return []; };
var ShareDataRow =               (function () {
    function ShareDataRow(obj, documentListService, permissionsStyle) {
        this.obj = obj;
        this.documentListService = documentListService;
        this.permissionsStyle = permissionsStyle;
        this.cache = {};
        this.isSelected = false;
        this.cssClass = '';
        if (!obj) {
            throw new Error(ShareDataRow.ERR_OBJECT_NOT_FOUND);
        }
        this.isDropTarget = this.isFolderAndHasPermissionToUpload(obj);
        if (permissionsStyle) {
            this.cssClass = this.getPermissionClass(obj);
        }
    }
    Object.defineProperty(ShareDataRow.prototype, "node", {
        get: function () {
            return this.obj;
        },
        enumerable: true,
        configurable: true
    });
    ShareDataRow.prototype.getPermissionClass = function (nodeEntity) {
        var _this = this;
        var permissionsClasses = '';
        this.permissionsStyle.forEach(function (currentPermissionsStyle) {
            if (_this.applyPermissionStyleToFolder(nodeEntity.entry, currentPermissionsStyle) || _this.applyPermissionStyleToFile(nodeEntity.entry, currentPermissionsStyle)) {
                if (_this.documentListService.hasPermission(nodeEntity.entry, currentPermissionsStyle.permission)) {
                    permissionsClasses += " " + currentPermissionsStyle.css;
                }
            }
        });
        return permissionsClasses;
    };
    ShareDataRow.prototype.applyPermissionStyleToFile = function (node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFile && node.isFile);
    };
    ShareDataRow.prototype.applyPermissionStyleToFolder = function (node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFolder && node.isFolder);
    };
    ShareDataRow.prototype.isFolderAndHasPermissionToUpload = function (obj) {
        return this.isFolder(obj) && this.documentListService.hasPermission(obj.entry, 'create');
    };
    ShareDataRow.prototype.isFolder = function (obj) {
        return obj.entry && obj.entry.isFolder;
    };
    ShareDataRow.prototype.cacheValue = function (key, value) {
        this.cache[key] = value;
        return value;
    };
    ShareDataRow.prototype.getValue = function (key) {
        if (this.cache[key] !== undefined) {
            return this.cache[key];
        }
        return adfCore.ObjectUtils.getValue(this.obj.entry, key);
    };
    ShareDataRow.prototype.hasValue = function (key) {
        return this.getValue(key) !== undefined;
    };
    return ShareDataRow;
}());
ShareDataRow.ERR_OBJECT_NOT_FOUND = 'Object source not found';
var ShareDataTableAdapter =               (function () {
    function ShareDataTableAdapter(documentListService, schema, sorting) {
        if (schema === void 0) { schema = []; }
        this.documentListService = documentListService;
        this.ERR_ROW_NOT_FOUND = 'Row not found';
        this.ERR_COL_NOT_FOUND = 'Column not found';
        this.thumbnails = false;
        this.rows = [];
        this.columns = schema || [];
        this.sorting = sorting;
    }
    ShareDataTableAdapter.prototype.getRows = function () {
        return this.rows;
    };
    ShareDataTableAdapter.prototype.setRows = function (rows) {
        this.rows = rows || [];
        this.sort();
    };
    ShareDataTableAdapter.prototype.getColumns = function () {
        return this.columns;
    };
    ShareDataTableAdapter.prototype.setColumns = function (columns) {
        this.columns = columns || [];
    };
    ShareDataTableAdapter.prototype.getValue = function (row, col) {
        if (!row) {
            throw new Error(this.ERR_ROW_NOT_FOUND);
        }
        if (!col) {
            throw new Error(this.ERR_COL_NOT_FOUND);
        }
        var dataRow = (row);
        var value = row.getValue(col.key);
        if (dataRow.cache[col.key] !== undefined) {
            return dataRow.cache[col.key];
        }
        if (col.type === 'date') {
            try {
                var result = this.formatDate(col, value);
                return dataRow.cacheValue(col.key, result);
            }
            catch (err) {
                console.error("Error parsing date " + value + " to format " + col.format);
                return 'Error';
            }
        }
        if (col.key === '$thumbnail') {
            if (this.imageResolver) {
                var resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
            var node = ((row)).node;
            if (node.entry.isFolder) {
                return this.documentListService.getMimeTypeIcon('folder');
            }
            if (node.entry.isFile) {
                if (this.thumbnails) {
                    return this.documentListService.getDocumentThumbnailUrl(node);
                }
            }
            if (node.entry.content) {
                var mimeType = node.entry.content.mimeType;
                if (mimeType) {
                    return this.documentListService.getMimeTypeIcon(mimeType);
                }
            }
            return this.documentListService.getDefaultMimeTypeIcon();
        }
        if (col.type === 'image') {
            if (this.imageResolver) {
                var resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
        }
        return dataRow.cacheValue(col.key, value);
    };
    ShareDataTableAdapter.prototype.formatDate = function (col, value) {
        if (col.type === 'date') {
            var format = col.format || 'medium';
            if (format === 'timeAgo') {
                var timeAgoPipe = new adfCore.TimeAgoPipe();
                return timeAgoPipe.transform(value);
            }
            else {
                var datePipe = new common.DatePipe('en-US');
                return datePipe.transform(value, format);
            }
        }
        return value;
    };
    ShareDataTableAdapter.prototype.getSorting = function () {
        return this.sorting;
    };
    ShareDataTableAdapter.prototype.setSorting = function (sorting) {
        this.sorting = sorting;
        this.sortRows(this.rows, this.sorting);
    };
    ShareDataTableAdapter.prototype.sort = function (key, direction) {
        var sorting = this.sorting || new adfCore.DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    };
    ShareDataTableAdapter.prototype.setFilter = function (filter) {
        this.filter = filter;
    };
    ShareDataTableAdapter.prototype.setImageResolver = function (resolver) {
        this.imageResolver = resolver;
    };
    ShareDataTableAdapter.prototype.sortRows = function (rows, sorting) {
        var options = {};
        if (sorting && sorting.key && rows && rows.length > 0) {
            if (sorting.key.includes('sizeInBytes') || sorting.key === 'name') {
                options.numeric = true;
            }
            rows.sort(function (a, b) {
                if (a.node.entry.isFolder !== b.node.entry.isFolder) {
                    return a.node.entry.isFolder ? -1 : 1;
                }
                var left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                var right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right, undefined, options)
                    : right.localeCompare(left, undefined, options);
            });
        }
    };
    ShareDataTableAdapter.prototype.loadPage = function (page, merge$$1) {
        var _this = this;
        if (merge$$1 === void 0) { merge$$1 = false; }
        var rows = [];
        if (page && page.list) {
            var data = page.list.entries;
            if (data && data.length > 0) {
                rows = data.map(function (item) { return new ShareDataRow(item, _this.documentListService, _this.permissionsStyle); });
                if (this.filter) {
                    rows = rows.filter(this.filter);
                }
                if (this.columns && this.columns.length > 0) {
                    var sorting = this.getSorting();
                    if (sorting) {
                        this.sortRows(rows, sorting);
                    }
                    else {
                        var sortable = this.columns.filter(function (c) { return c.sortable; });
                        if (sortable.length > 0) {
                            this.sort(sortable[0].key, 'asc');
                        }
                        else {
                            this.sort(this.columns[0].key, 'asc');
                        }
                    }
                }
            }
        }
        if (merge$$1) {
            this.rows = this.rows.concat(rows);
        }
        else {
            this.rows = rows;
        }
    };
    return ShareDataTableAdapter;
}());
var presetsDefaultModel = {
    '-trashcan-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'archivedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'archivedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_BY',
            sortable: true
        }
    ],
    '-sites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-mysites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-favorites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ],
    '-recent-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        }
    ],
    '-sharedlinks-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        },
        {
            key: 'sharedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SHARED_BY',
            sortable: true
        }
    ],
    'default': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ]
};
var ContentActionModel =               (function () {
    function ContentActionModel(obj) {
        this.disableWithNoPermission = false;
        this.disabled = false;
        if (obj) {
            this.icon = obj.icon;
            this.title = obj.title;
            this.handler = obj.handler;
            this.execute = obj.execute;
            this.target = obj.target;
            this.permission = obj.permission;
            this.disableWithNoPermission = obj.disableWithNoPermission;
            this.disabled = obj.disabled;
        }
    }
    return ContentActionModel;
}());
var ContentActionTarget = {
    Document: 'document',
    Folder: 'folder',
    All: 'all',
};
var DocumentActionModel =               (function (_super) {
    __extends(DocumentActionModel, _super);
    function DocumentActionModel(json) {
        var _this = _super.call(this, json) || this;
        _this.target = 'document';
        return _this;
    }
    return DocumentActionModel;
}(ContentActionModel));
var FolderActionModel =               (function (_super) {
    __extends(FolderActionModel, _super);
    function FolderActionModel(json) {
        var _this = _super.call(this, json) || this;
        _this.target = 'folder';
        return _this;
    }
    return FolderActionModel;
}(ContentActionModel));
var NodeEntityEvent =               (function (_super) {
    __extends(NodeEntityEvent, _super);
    function NodeEntityEvent(entity) {
        var _this = _super.call(this) || this;
        _this.value = entity;
        return _this;
    }
    return NodeEntityEvent;
}(adfCore.BaseEvent));
var NodeEntryEvent =               (function (_super) {
    __extends(NodeEntryEvent, _super);
    function NodeEntryEvent(entity) {
        var _this = _super.call(this) || this;
        _this.value = entity;
        return _this;
    }
    return NodeEntryEvent;
}(adfCore.BaseEvent));
var CustomResourcesService =               (function () {
    function CustomResourcesService(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.CREATE_PERMISSION = 'create';
    }
    CustomResourcesService.prototype.getRecentFiles = function (personId, pagination) {
        var _this = this;
        return new Observable.Observable(function (observer) {
            _this.apiService.peopleApi.getPerson(personId)
                .then(function (person) {
                var username = person.entry.id;
                var query = {
                    query: {
                        query: '*',
                        language: 'afts'
                    },
                    filterQueries: [
                        { query: "cm:modified:[NOW/DAY-30DAYS TO NOW/DAY+1DAY]" },
                        { query: "cm:modifier:" + username + " OR cm:creator:" + username },
                        { query: "TYPE:\"content\" AND -TYPE:\"app:filelink\" AND -TYPE:\"fm:post\"" }
                    ],
                    include: ['path', 'properties', 'allowableOperations'],
                    sort: [{
                            type: 'FIELD',
                            field: 'cm:modified',
                            ascending: false
                        }],
                    paging: {
                        maxItems: pagination.maxItems,
                        skipCount: pagination.skipCount
                    }
                };
                return _this.apiService.searchApi.search(query)
                    .then(function (serachResult) {
                    observer.next(serachResult);
                    observer.complete();
                }, function (err) {
                    observer.error(err);
                    observer.complete();
                });
            }, function (err) {
                observer.error(err);
                observer.complete();
            });
        }).catch(function (err) { return _this.handleError(err); });
    };
    CustomResourcesService.prototype.loadFavorites = function (pagination, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        var includeFieldsRequest = this.getIncludesFields(includeFields);
        var options = {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: includeFieldsRequest
        };
        return new Observable.Observable(function (observer) {
            _this.apiService.favoritesApi.getFavorites('-me-', options)
                .then(function (result) {
                var page = {
                    list: {
                        entries: result.list.entries
                            .map(function (_b) {
                            var target = _b.entry.target;
                            return ({
                                entry: target.file || target.folder
                            });
                        })
                            .map(function (_b) {
                            var entry = _b.entry;
                            entry.properties = {
                                'cm:title': entry.title,
                                'cm:description': entry.description
                            };
                            return { entry: entry };
                        }),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }, function (err) {
                observer.error(err);
                observer.complete();
            });
        }).catch(function (err) { return _this.handleError(err); });
    };
    CustomResourcesService.prototype.loadMemberSites = function (pagination) {
        var _this = this;
        var options = {
            include: ['properties'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable.Observable(function (observer) {
            _this.apiService.peopleApi.getSiteMembership('-me-', options)
                .then(function (result) {
                var page = {
                    list: {
                        entries: result.list.entries
                            .map(function (_b) {
                            var site = _b.entry.site;
                            site.allowableOperations = site.allowableOperations ? site.allowableOperations : [_this.CREATE_PERMISSION];
                            site.name = site.name || site.title;
                            return {
                                entry: site
                            };
                        }),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }, function (err) {
                observer.error(err);
                observer.complete();
            });
        }).catch(function (err) { return _this.handleError(err); });
    };
    CustomResourcesService.prototype.loadSites = function (pagination) {
        var _this = this;
        var options = {
            include: ['properties'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable.Observable(function (observer) {
            _this.apiService.sitesApi.getSites(options)
                .then(function (page) {
                page.list.entries.map(function (_b) {
                    var entry = _b.entry;
                    entry.name = entry.name || entry.title;
                    return { entry: entry };
                });
                observer.next(page);
                observer.complete();
            }, function (err) {
                observer.error(err);
                observer.complete();
            });
        }).catch(function (err) { return _this.handleError(err); });
    };
    CustomResourcesService.prototype.loadTrashcan = function (pagination, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        var includeFieldsRequest = this.getIncludesFields(includeFields);
        var options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return Observable.Observable.fromPromise(this.apiService.nodesApi.getDeletedNodes(options)).catch(function (err) { return _this.handleError(err); });
    };
    CustomResourcesService.prototype.loadSharedLinks = function (pagination, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        var includeFieldsRequest = this.getIncludesFields(includeFields);
        var options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return Observable.Observable.fromPromise(this.apiService.sharedLinksApi.findSharedLinks(options)).catch(function (err) { return _this.handleError(err); });
    };
    CustomResourcesService.prototype.isCustomSource = function (folderId) {
        var isCustomSources = false;
        var sources = ['-trashcan-', '-sharedlinks-', '-sites-', '-mysites-', '-favorites-', '-recent-'];
        if (sources.indexOf(folderId) > -1) {
            isCustomSources = true;
        }
        return isCustomSources;
    };
    CustomResourcesService.prototype.loadFolderByNodeId = function (nodeId, pagination, includeFields) {
        if (nodeId === '-trashcan-') {
            return this.loadTrashcan(pagination, includeFields);
        }
        else if (nodeId === '-sharedlinks-') {
            return this.loadSharedLinks(pagination, includeFields);
        }
        else if (nodeId === '-sites-') {
            return this.loadSites(pagination);
        }
        else if (nodeId === '-mysites-') {
            return this.loadMemberSites(pagination);
        }
        else if (nodeId === '-favorites-') {
            return this.loadFavorites(pagination, includeFields);
        }
        else if (nodeId === '-recent-') {
            return this.getRecentFiles('-me-', pagination);
        }
    };
    CustomResourcesService.prototype.getCorrespondingNodeIds = function (nodeId, pagination) {
        var _this = this;
        if (nodeId === '-trashcan-') {
            return Observable.Observable.fromPromise(this.apiService.nodesApi.getDeletedNodes()
                .then(function (result) { return result.list.entries.map(function (node) { return node.entry.id; }); }));
        }
        else if (nodeId === '-sharedlinks-') {
            return Observable.Observable.fromPromise(this.apiService.sharedLinksApi.findSharedLinks()
                .then(function (result) { return result.list.entries.map(function (node) { return node.entry.nodeId; }); }));
        }
        else if (nodeId === '-sites-') {
            return Observable.Observable.fromPromise(this.apiService.sitesApi.getSites()
                .then(function (result) { return result.list.entries.map(function (node) { return node.entry.guid; }); }));
        }
        else if (nodeId === '-mysites-') {
            return Observable.Observable.fromPromise(this.apiService.peopleApi.getSiteMembership('-me-')
                .then(function (result) { return result.list.entries.map(function (node) { return node.entry.guid; }); }));
        }
        else if (nodeId === '-favorites-') {
            return Observable.Observable.fromPromise(this.apiService.favoritesApi.getFavorites('-me-')
                .then(function (result) { return result.list.entries.map(function (node) { return node.entry.targetGuid; }); }));
        }
        else if (nodeId === '-recent-') {
            return new Observable.Observable(function (observer) {
                _this.getRecentFiles('-me-', pagination)
                    .subscribe(function (recentFiles) {
                    var recentFilesIdS = recentFiles.list.entries.map(function (node) { return node.entry.id; });
                    observer.next(recentFilesIdS);
                    observer.complete();
                });
            });
        }
        return Observable.Observable.of([]);
    };
    CustomResourcesService.prototype.getIncludesFields = function (includeFields) {
        return __spread(['path', 'properties', 'allowableOperations', 'permissions'], includeFields).filter(function (element, index, array) { return index === array.indexOf(element); });
    };
    CustomResourcesService.prototype.handleError = function (error) {
        this.logService.error(error);
        return Observable.Observable.throw(error || 'Server error');
    };
    return CustomResourcesService;
}());
CustomResourcesService.decorators = [
    { type: core.Injectable },
];
CustomResourcesService.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
    { type: adfCore.LogService, },
]; };
var PaginationStrategy = {
    Finite: 0,
    Infinite: 1,
};
PaginationStrategy[PaginationStrategy.Finite] = "Finite";
PaginationStrategy[PaginationStrategy.Infinite] = "Infinite";
var DocumentListComponent =               (function () {
    function DocumentListComponent(documentListService, ngZone, elementRef, appConfig, preferences, customResourcesService, contentService) {
        this.documentListService = documentListService;
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.appConfig = appConfig;
        this.preferences = preferences;
        this.customResourcesService = customResourcesService;
        this.contentService = contentService;
        this.display = adfCore.DisplayMode.List;
        this.permissionsStyle = [];
        this.locationFormat = '/';
        this.navigate = true;
        this.showHeader = true;
        this.navigationMode = DocumentListComponent.DOUBLE_CLICK_NAVIGATION;
        this.thumbnails = false;
        this.selectionMode = 'single';
        this.multiselect = false;
        this.contentActions = false;
        this.contentActionsPosition = 'right';
        this.contextMenuActions = false;
        this.emptyFolderImageUrl = './assets/images/empty_doc_lib.svg';
        this.allowDropFiles = false;
        this.loading = false;
        this.rowFilter = null;
        this.imageResolver = null;
        this.currentFolderId = null;
        this.folderNode = null;
        this.node = null;
        this.skipCount = 0;
        this.enableInfiniteScrolling = false;
        this.nodeClick = new core.EventEmitter();
        this.nodeDblClick = new core.EventEmitter();
        this.folderChange = new core.EventEmitter();
        this.preview = new core.EventEmitter();
        this.ready = new core.EventEmitter();
        this.error = new core.EventEmitter();
        this.actions = [];
        this.contextActionHandler = new Subject.Subject();
        this.noPermission = false;
        this.selection = new Array();
        this.layoutPresets = {};
    }
    DocumentListComponent.prototype.getContextActions = function (node) {
        var _this = this;
        if (node && node.entry) {
            var actions = this.getNodeActions(node);
            if (actions && actions.length > 0) {
                return actions.map(function (currentAction) {
                    return {
                        model: currentAction,
                        node: node,
                        subject: _this.contextActionHandler
                    };
                });
            }
        }
        return null;
    };
    Object.defineProperty(DocumentListComponent.prototype, "supportedPageSizes", {
        get: function () {
            return this.preferences.getDefaultPageSizes();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentListComponent.prototype, "hasCustomLayout", {
        get: function () {
            return this.columnList && this.columnList.columns && this.columnList.columns.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    DocumentListComponent.prototype.getDefaultSorting = function () {
        var defaultSorting;
        if (this.sorting) {
            var _b = __read(this.sorting, 2), key = _b[0], direction = _b[1];
            defaultSorting = new adfCore.DataSorting(key, direction);
        }
        return defaultSorting;
    };
    DocumentListComponent.prototype.getLayoutPreset = function (name) {
        if (name === void 0) { name = 'default'; }
        return (this.layoutPresets[name] || this.layoutPresets['default']).map(function (col) { return new adfCore.ObjectDataColumn(col); });
    };
    Object.defineProperty(DocumentListComponent.prototype, "pagination", {
        get: function () {
            var maxItems = this.preferences.paginationSize;
            if (!this._pagination) {
                if (this.maxItems) {
                    maxItems = this.maxItems;
                }
                var defaultPagination = ({
                    maxItems: maxItems,
                    skipCount: 0,
                    totalItems: 0,
                    hasMoreItems: false
                });
                this._pagination = new BehaviorSubject.BehaviorSubject(defaultPagination);
            }
            return this._pagination;
        },
        enumerable: true,
        configurable: true
    });
    DocumentListComponent.prototype.isEmptyTemplateDefined = function () {
        if (this.dataTable) {
            if (this.emptyFolderTemplate) {
                return true;
            }
        }
        return false;
    };
    DocumentListComponent.prototype.isNoPermissionTemplateDefined = function () {
        if (this.dataTable) {
            if (this.noPermissionTemplate) {
                return true;
            }
        }
        return false;
    };
    DocumentListComponent.prototype.isMobile = function () {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    };
    DocumentListComponent.prototype.isEmpty = function () {
        return !this.data || this.data.getRows().length === 0;
    };
    DocumentListComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.loadLayoutPresets();
        this.data = new ShareDataTableAdapter(this.documentListService, null, this.getDefaultSorting());
        this.data.thumbnails = this.thumbnails;
        this.data.permissionsStyle = this.permissionsStyle;
        if (this.rowFilter) {
            this.data.setFilter(this.rowFilter);
        }
        if (this.imageResolver) {
            this.data.setImageResolver(this.imageResolver);
        }
        this.contextActionHandlerSubscription = this.contextActionHandler.subscribe(function (val) { return _this.contextActionCallback(val); });
        this.enforceSingleClickNavigationForMobile();
    };
    DocumentListComponent.prototype.ngAfterContentInit = function () {
        var schema = [];
        if (this.hasCustomLayout) {
            schema = this.columnList.columns.map(function (c) { return (c); });
        }
        if (!this.data) {
            this.data = new ShareDataTableAdapter(this.documentListService, schema, this.getDefaultSorting());
        }
        else if (schema && schema.length > 0) {
            this.data.setColumns(schema);
        }
        var columns = this.data.getColumns();
        if (!columns || columns.length === 0) {
            this.setupDefaultColumns(this.currentFolderId);
        }
    };
    DocumentListComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        this.resetSelection();
        if (changes["folderNode"] && changes["folderNode"].currentValue) {
            this.currentFolderId = changes["folderNode"].currentValue.id;
            this.resetNewFolderPagination();
            this.loadFolder();
        }
        else if (changes["currentFolderId"] &&
            changes["currentFolderId"].currentValue &&
            changes["currentFolderId"].currentValue !== changes["currentFolderId"].previousValue) {
            this.resetNewFolderPagination();
            this.loadFolder();
        }
        else if (this.data) {
            if (changes["node"] && changes["node"].currentValue) {
                if (changes["node"].currentValue.list.pagination) {
                    changes["node"].currentValue.list.pagination.skipCount = 0;
                }
                this.data.loadPage(changes["node"].currentValue);
                this.onDataReady(changes["node"].currentValue);
            }
            else if (changes["rowFilter"]) {
                this.data.setFilter(changes["rowFilter"].currentValue);
                if (this.currentFolderId) {
                    this.loadFolderNodesByFolderNodeId(this.currentFolderId, this.pagination.getValue()).catch(function (err) { return _this.error.emit(err); });
                }
            }
            else if (changes["imageResolver"]) {
                this.data.setImageResolver(changes["imageResolver"].currentValue);
            }
        }
    };
    DocumentListComponent.prototype.reload = function () {
        var _this = this;
        this.ngZone.run(function () {
            _this.resetSelection();
            if (_this.node) {
                _this.data.loadPage(_this.node);
                _this.onDataReady(_this.node);
            }
            else {
                _this.loadFolder();
            }
        });
    };
    DocumentListComponent.prototype.contextActionCallback = function (action) {
        if (action) {
            this.executeContentAction(action.node, action.model);
        }
    };
    DocumentListComponent.prototype.getNodeActions = function (node) {
        var _this = this;
        var target = null;
        if (node && node.entry) {
            if (node.entry.isFile) {
                target = 'document';
            }
            else if (node.entry.isFolder) {
                target = 'folder';
            }
            if (target) {
                var actionsByTarget = this.actions.filter(function (entry) {
                    return entry.target.toLowerCase() === target;
                }).map(function (action) { return new ContentActionModel(action); });
                actionsByTarget.forEach(function (action) {
                    _this.disableActionsWithNoPermissions(node, action);
                });
                return actionsByTarget;
            }
        }
        return [];
    };
    DocumentListComponent.prototype.disableActionsWithNoPermissions = function (node, action) {
        if (action.permission && node.entry.allowableOperations && !this.contentService.hasPermission(node.entry, action.permission)) {
            action.disabled = true;
        }
    };
    DocumentListComponent.prototype.onShowContextMenu = function (e) {
        if (e && this.contextMenuActions) {
            e.preventDefault();
        }
    };
    DocumentListComponent.prototype.performNavigation = function (node) {
        if (this.canNavigateFolder(node)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    };
    DocumentListComponent.prototype.performCustomSourceNavigation = function (node) {
        if (this.customResourcesService.isCustomSource(this.currentFolderId)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    };
    DocumentListComponent.prototype.updateFolderData = function (node) {
        this.resetNewFolderPagination();
        this.currentFolderId = node.entry.id;
        this.reload();
        this.folderChange.emit(new NodeEntryEvent(node.entry));
    };
    DocumentListComponent.prototype.updateCustomSourceData = function (nodeId) {
        this.folderNode = null;
        this.currentFolderId = nodeId;
    };
    DocumentListComponent.prototype.executeContentAction = function (node, action) {
        if (node && node.entry && action) {
            var handlerSub = void 0;
            if (typeof action.handler === 'function') {
                handlerSub = action.handler(node, this, action.permission);
            }
            else {
                handlerSub = Observable.Observable.of(true);
            }
            if (typeof action.execute === 'function') {
                handlerSub.subscribe(function () {
                    action.execute(node);
                });
            }
        }
    };
    DocumentListComponent.prototype.loadFolder = function () {
        var _this = this;
        if (!this.pagination.getValue().merge) {
            this.loading = true;
        }
        if (!this.hasCustomLayout) {
            this.setupDefaultColumns(this.currentFolderId);
        }
        if (this.folderNode) {
            return this.loadFolderNodesByFolderNodeId(this.folderNode.id, this.pagination.getValue())
                .catch(function (err) { return _this.handleError(err); });
        }
        else {
            this.loadFolderByNodeId(this.currentFolderId);
        }
    };
    DocumentListComponent.prototype.loadFolderByNodeId = function (nodeId) {
        var _this = this;
        if (this.customResourcesService.isCustomSource(nodeId)) {
            this.updateCustomSourceData(nodeId);
            this.customResourcesService.loadFolderByNodeId(nodeId, this.pagination.getValue(), this.includeFields)
                .subscribe(function (page) {
                _this.onPageLoaded(page);
            }, function (err) {
                _this.error.emit(err);
            });
        }
        else {
            this.documentListService
                .getFolderNode(nodeId, this.includeFields)
                .subscribe(function (node) {
                _this.folderNode = node;
                return _this.loadFolderNodesByFolderNodeId(node.id, _this.pagination.getValue())
                    .catch(function (err) { return _this.handleError(err); });
            }, function (err) {
                _this.handleError(err);
            });
        }
    };
    DocumentListComponent.prototype.loadFolderNodesByFolderNodeId = function (id, pagination) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.documentListService
                .getFolder(null, {
                maxItems: pagination.maxItems,
                skipCount: pagination.skipCount,
                rootFolderId: id
            }, _this.includeFields)
                .subscribe(function (nodePaging) {
                _this.data.loadPage((nodePaging), _this.pagination.getValue().merge);
                _this.loading = false;
                _this.onDataReady(nodePaging);
                resolve(true);
            }, function (err) {
                _this.handleError(err);
            });
        });
    };
    DocumentListComponent.prototype.resetSelection = function () {
        this.dataTable.resetSelection();
        this.selection = [];
        this.noPermission = false;
    };
    DocumentListComponent.prototype.onPageLoaded = function (nodePaging) {
        if (nodePaging) {
            this.data.loadPage(nodePaging, this.pagination.getValue().merge);
            this.loading = false;
            this.onDataReady(nodePaging);
        }
    };
    DocumentListComponent.prototype.setupDefaultColumns = function (preset) {
        if (preset === void 0) { preset = 'default'; }
        if (this.data) {
            var columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    };
    DocumentListComponent.prototype.onPreviewFile = function (node) {
        if (node) {
            this.preview.emit(new NodeEntityEvent(node));
        }
    };
    DocumentListComponent.prototype.onNodeClick = function (node) {
        var domEvent = new CustomEvent('node-click', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        var event = new NodeEntityEvent(node);
        this.nodeClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.SINGLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    };
    DocumentListComponent.prototype.onNodeDblClick = function (node) {
        var domEvent = new CustomEvent('node-dblclick', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        var event = new NodeEntityEvent(node);
        this.nodeDblClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.DOUBLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    };
    DocumentListComponent.prototype.onNodeSelect = function (event) {
        this.selection = event.selection.map(function (entry) { return entry.node; });
        var domEvent = new CustomEvent('node-select', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    };
    DocumentListComponent.prototype.onNodeUnselect = function (event) {
        this.selection = event.selection.map(function (entry) { return entry.node; });
        var domEvent = new CustomEvent('node-unselect', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    };
    DocumentListComponent.prototype.onShowRowContextMenu = function (event) {
        if (this.contextMenuActions) {
            var args = event.value;
            var node = ((args.row)).node;
            if (node) {
                args.actions = this.getContextActions(node) || [];
            }
        }
    };
    DocumentListComponent.prototype.onShowRowActionsMenu = function (event) {
        if (this.contentActions) {
            var args = event.value;
            var node = ((args.row)).node;
            if (node) {
                args.actions = this.getNodeActions(node) || [];
            }
        }
    };
    DocumentListComponent.prototype.onExecuteRowAction = function (event) {
        if (this.contentActions) {
            var args = event.value;
            var node = ((args.row)).node;
            var action = ((args.action));
            this.executeContentAction(node, action);
        }
    };
    DocumentListComponent.prototype.enforceSingleClickNavigationForMobile = function () {
        if (this.isMobile()) {
            this.navigationMode = DocumentListComponent.SINGLE_CLICK_NAVIGATION;
        }
    };
    DocumentListComponent.prototype.canNavigateFolder = function (node) {
        var canNavigateFolder = false;
        if (this.customResourcesService.isCustomSource(this.currentFolderId)) {
            canNavigateFolder = false;
        }
        else if (node && node.entry && node.entry.isFolder) {
            canNavigateFolder = true;
        }
        return canNavigateFolder;
    };
    DocumentListComponent.prototype.loadLayoutPresets = function () {
        var externalSettings = this.appConfig.get('document-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, presetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = presetsDefaultModel;
        }
    };
    DocumentListComponent.prototype.onDataReady = function (nodePaging) {
        this.ready.emit(nodePaging);
        this.pagination.next(nodePaging.list.pagination);
    };
    DocumentListComponent.prototype.updatePagination = function (pagination) {
        this.reload();
    };
    DocumentListComponent.prototype.navigateTo = function (nodeId) {
        this.currentFolderId = nodeId;
        this.resetNewFolderPagination();
        this.loadFolder();
        this.folderChange.emit(new NodeEntryEvent({ id: nodeId }));
    };
    DocumentListComponent.prototype.resetNewFolderPagination = function () {
        this.folderNode = null;
        this.pagination.value.skipCount = 0;
    };
    DocumentListComponent.prototype.getCorrespondingNodeIds = function (nodeId) {
        var _this = this;
        if (this.customResourcesService.isCustomSource(nodeId)) {
            return this.customResourcesService.getCorrespondingNodeIds(nodeId, this.pagination.getValue());
        }
        else if (nodeId) {
            return new Observable.Observable(function (observer) {
                _this.documentListService.getFolderNode(nodeId, _this.includeFields)
                    .subscribe(function (node) {
                    observer.next([node.id]);
                    observer.complete();
                });
            });
        }
    };
    DocumentListComponent.prototype.ngOnDestroy = function () {
        if (this.contextActionHandlerSubscription) {
            this.contextActionHandlerSubscription.unsubscribe();
            this.contextActionHandlerSubscription = null;
        }
    };
    DocumentListComponent.prototype.handleError = function (err) {
        if (err.message) {
            if (JSON.parse(err.message).error.statusCode === 403) {
                this.loading = false;
                this.noPermission = true;
            }
        }
        this.error.emit(err);
    };
    return DocumentListComponent;
}());
DocumentListComponent.SINGLE_CLICK_NAVIGATION = 'click';
DocumentListComponent.DOUBLE_CLICK_NAVIGATION = 'dblclick';
DocumentListComponent.DEFAULT_PAGE_SIZE = 20;
DocumentListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-document-list',
                styles: [""],
                template: "<adf-datatable\n    #dataTable\n    [selectionMode]=\"selectionMode\"\n    [data]=\"data\"\n    [actions]=\"contentActions\"\n    [actionsPosition]=\"contentActionsPosition\"\n    [multiselect]=\"multiselect\"\n    [allowDropFiles]=\"allowDropFiles\"\n    [contextMenu]=\"contextMenuActions\"\n    [rowStyle]=\"rowStyle\"\n    [rowStyleClass]=\"rowStyleClass\"\n    [loading]=\"loading\"\n    [display]=\"display\"\n    [noPermission]=\"noPermission\"\n    [showHeader]=\"!isEmpty() && showHeader\"\n    (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n    (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n    (executeRowAction)=\"onExecuteRowAction($event)\"\n    (rowClick)=\"onNodeClick($event.value?.node)\"\n    (rowDblClick)=\"onNodeDblClick($event.value?.node)\"\n    (row-select)=\"onNodeSelect($event.detail)\"\n    (row-unselect)=\"onNodeUnselect($event.detail)\">\n\n    <div *ngIf=\"!isEmptyTemplateDefined()\">\n        <no-content-template>\n            <ng-template>\n                <adf-empty-list>\n                    <div class=\"adf-empty-list_template adf-empty-folder\">\n                        <div class=\"adf-empty-folder-this-space-is-empty\">{{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}}</div>\n                        <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-drag-drop\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate }}</div>\n                        <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-any-files-here-to-add\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.SUBTITLE' | translate }}</div>\n                        <img class=\"adf-empty-folder-image\" [src]=\"emptyFolderImageUrl\">\n                    </div>\n                    <!-- <div adf-empty-list-header class=\"adf-empty-list-header\"> {{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}} </div> -->\n                </adf-empty-list>\n            </ng-template>\n        </no-content-template>\n    </div>\n\n    <div *ngIf=\"!isNoPermissionTemplateDefined()\">\n        <no-permission-template>\n            <ng-template>\n                <div class=\"adf-no-permission__template\">\n                    <mat-icon>ic_error</mat-icon>\n                    <p class=\"adf-no-permission__template--text\">{{ 'ADF-DOCUMENT-LIST.NO_PERMISSION' | translate }}</p>\n                </div>\n            </ng-template>\n        </no-permission-template>\n    </div>\n\n    <div>\n        <loading-content-template>\n            <ng-template>\n                <div class=\"adf-document-list-loading-container\">\n                    <mat-progress-spinner\n                        id=\"adf-document-list-loading\"\n                        class=\"adf-document-list-loading-margin\"\n                        [color]=\"'primary'\"\n                        [mode]=\"'indeterminate'\">\n                    </mat-progress-spinner>\n                </div>\n            </ng-template>\n        </loading-content-template>\n    </div>\n</adf-datatable>\n",
                encapsulation: core.ViewEncapsulation.None
            },] },
];
DocumentListComponent.ctorParameters = function () { return [
    { type: DocumentListService, },
    { type: core.NgZone, },
    { type: core.ElementRef, },
    { type: adfCore.AppConfigService, },
    { type: adfCore.UserPreferencesService, },
    { type: CustomResourcesService, },
    { type: adfCore.ContentService, },
]; };
DocumentListComponent.propDecorators = {
    "columnList": [{ type: core.ContentChild, args: [adfCore.DataColumnListComponent,] },],
    "includeFields": [{ type: core.Input },],
    "display": [{ type: core.Input },],
    "permissionsStyle": [{ type: core.Input },],
    "locationFormat": [{ type: core.Input },],
    "navigate": [{ type: core.Input },],
    "showHeader": [{ type: core.Input },],
    "navigationMode": [{ type: core.Input },],
    "thumbnails": [{ type: core.Input },],
    "selectionMode": [{ type: core.Input },],
    "multiselect": [{ type: core.Input },],
    "contentActions": [{ type: core.Input },],
    "contentActionsPosition": [{ type: core.Input },],
    "contextMenuActions": [{ type: core.Input },],
    "emptyFolderImageUrl": [{ type: core.Input },],
    "allowDropFiles": [{ type: core.Input },],
    "sorting": [{ type: core.Input },],
    "rowStyle": [{ type: core.Input },],
    "rowStyleClass": [{ type: core.Input },],
    "loading": [{ type: core.Input },],
    "rowFilter": [{ type: core.Input },],
    "imageResolver": [{ type: core.Input },],
    "currentFolderId": [{ type: core.Input },],
    "folderNode": [{ type: core.Input },],
    "node": [{ type: core.Input },],
    "maxItems": [{ type: core.Input },],
    "skipCount": [{ type: core.Input },],
    "enableInfiniteScrolling": [{ type: core.Input },],
    "nodeClick": [{ type: core.Output },],
    "nodeDblClick": [{ type: core.Output },],
    "folderChange": [{ type: core.Output },],
    "preview": [{ type: core.Output },],
    "ready": [{ type: core.Output },],
    "error": [{ type: core.Output },],
    "dataTable": [{ type: core.ViewChild, args: ['dataTable',] },],
    "onShowContextMenu": [{ type: core.HostListener, args: ['contextmenu', ['$event'],] },],
};
var ContentColumnListComponent =               (function () {
    function ContentColumnListComponent(documentList, logService) {
        this.documentList = documentList;
        this.logService = logService;
        this.logService.log('ContentColumnListComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnListComponent instead.');
    }
    ContentColumnListComponent.prototype.registerColumn = function (column) {
        if (this.documentList && column) {
            var columns = this.documentList.data.getColumns();
            columns.push(column);
            return true;
        }
        return false;
    };
    return ContentColumnListComponent;
}());
ContentColumnListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'content-columns',
                template: ''
            },] },
];
ContentColumnListComponent.ctorParameters = function () { return [
    { type: DocumentListComponent, },
    { type: adfCore.LogService, },
]; };
var ContentColumnComponent =               (function () {
    function ContentColumnComponent(list, logService) {
        this.list = list;
        this.logService = logService;
        this.type = 'text';
        this.sortable = false;
        this.title = '';
        this.logService.log('ContentColumnComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnComponent instead.');
    }
    ContentColumnComponent.prototype.ngOnInit = function () {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    };
    ContentColumnComponent.prototype.ngAfterContentInit = function () {
        this.register();
    };
    ContentColumnComponent.prototype.register = function () {
        if (this.list) {
            return this.list.registerColumn(this);
        }
        return false;
    };
    return ContentColumnComponent;
}());
ContentColumnComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'content-column',
                template: ''
            },] },
];
ContentColumnComponent.ctorParameters = function () { return [
    { type: ContentColumnListComponent, },
    { type: adfCore.LogService, },
]; };
ContentColumnComponent.propDecorators = {
    "key": [{ type: core.Input },],
    "type": [{ type: core.Input },],
    "format": [{ type: core.Input },],
    "sortable": [{ type: core.Input },],
    "title": [{ type: core.Input },],
    "template": [{ type: core.ContentChild, args: [core.TemplateRef,] },],
    "srTitle": [{ type: core.Input, args: ['sr-title',] },],
    "cssClass": [{ type: core.Input, args: ['class',] },],
};
var PermissionModel =               (function () {
    function PermissionModel(obj) {
        if (obj) {
            this.type = obj.type || null;
            this.action = obj.action || null;
            this.permission = obj.permission || null;
        }
    }
    return PermissionModel;
}());
var NodeActionsService =               (function () {
    function NodeActionsService(contentDialogService, dialogRef, content, documentListService, apiService, dialog) {
        this.contentDialogService = contentDialogService;
        this.dialogRef = dialogRef;
        this.content = content;
        this.documentListService = documentListService;
        this.apiService = apiService;
        this.dialog = dialog;
        this.error = new core.EventEmitter();
    }
    NodeActionsService.prototype.downloadNode = function (node) {
        new NodeDownloadDirective(this.apiService, this.dialog)
            .downloadNode(node);
    };
    NodeActionsService.prototype.copyContent = function (contentEntry, permission) {
        return this.doFileOperation('copy', 'content', contentEntry, permission);
    };
    NodeActionsService.prototype.copyFolder = function (contentEntry, permission) {
        return this.doFileOperation('copy', 'folder', contentEntry, permission);
    };
    NodeActionsService.prototype.moveContent = function (contentEntry, permission) {
        return this.doFileOperation('move', 'content', contentEntry, permission);
    };
    NodeActionsService.prototype.moveFolder = function (contentEntry, permission) {
        return this.doFileOperation('move', 'folder', contentEntry, permission);
    };
    NodeActionsService.prototype.doFileOperation = function (action, type, contentEntry, permission) {
        var _this = this;
        var observable = new Subject.Subject();
        this.contentDialogService
            .openCopyMoveDialog(action, contentEntry, permission)
            .subscribe(function (selections) {
            var selection = selections[0];
            _this.documentListService[action + "Node"].call(_this.documentListService, contentEntry.id, selection.id)
                .subscribe(observable.next.bind(observable, "OPERATION.SUCCES." + type.toUpperCase() + "." + action.toUpperCase()), observable.error.bind(observable));
        }, function (error) {
            observable.error(error);
            return observable;
        });
        return observable;
    };
    return NodeActionsService;
}());
NodeActionsService.decorators = [
    { type: core.Injectable },
];
NodeActionsService.ctorParameters = function () { return [
    { type: ContentNodeDialogService, },
    { type: material.MatDialog, },
    { type: adfCore.ContentService, },
    { type: DocumentListService, },
    { type: adfCore.AlfrescoApiService, },
    { type: material.MatDialog, },
]; };
NodeActionsService.propDecorators = {
    "error": [{ type: core.Output },],
};
var DocumentActionsService =               (function () {
    function DocumentActionsService(nodeActionsService, contentNodeDialogService, translation, documentListService, contentService) {
        this.nodeActionsService = nodeActionsService;
        this.contentNodeDialogService = contentNodeDialogService;
        this.translation = translation;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.permissionEvent = new Subject.Subject();
        this.error = new Subject.Subject();
        this.success = new Subject.Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    DocumentActionsService.prototype.getHandler = function (key) {
        if (key) {
            var lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    };
    DocumentActionsService.prototype.setHandler = function (key, handler) {
        if (key) {
            var lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    };
    DocumentActionsService.prototype.canExecuteAction = function (obj) {
        return this.documentListService && obj && obj.entry.isFile === true;
    };
    DocumentActionsService.prototype.setupActionHandlers = function () {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
        this.handlers['lock'] = this.lockNode.bind(this);
    };
    DocumentActionsService.prototype.lockNode = function (node, target, permission) {
        return this.contentNodeDialogService.openLockNodeDialog(node.entry);
    };
    DocumentActionsService.prototype.downloadNode = function (obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    };
    DocumentActionsService.prototype.copyNode = function (node, target, permission) {
        var actionObservable = this.nodeActionsService.copyContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'copy', target, permission);
        return actionObservable;
    };
    DocumentActionsService.prototype.moveNode = function (node, target, permission) {
        var actionObservable = this.nodeActionsService.moveContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'move', target, permission);
        return actionObservable;
    };
    DocumentActionsService.prototype.prepareHandlers = function (actionObservable, type, action, target, permission) {
        var _this = this;
        actionObservable.subscribe(function (fileOperationMessage) {
            _this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    };
    DocumentActionsService.prototype.deleteNode = function (node, target, permission) {
        var _this = this;
        var handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasPermission(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe(function () {
                    var message = _this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    _this.success.next(message);
                }, function () {
                    var message = _this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    _this.error.next(message);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({
                    type: 'content',
                    action: 'delete',
                    permission: permission
                }));
                return Observable.Observable.throw(new Error('No permission to delete'));
            }
        }
    };
    return DocumentActionsService;
}());
DocumentActionsService.decorators = [
    { type: core.Injectable },
];
DocumentActionsService.ctorParameters = function () { return [
    { type: NodeActionsService, },
    { type: ContentNodeDialogService, },
    { type: adfCore.TranslationService, },
    { type: DocumentListService, },
    { type: adfCore.ContentService, },
]; };
var FolderActionsService =               (function () {
    function FolderActionsService(nodeActionsService, documentListService, contentService, translation) {
        this.nodeActionsService = nodeActionsService;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.translation = translation;
        this.permissionEvent = new Subject.Subject();
        this.error = new Subject.Subject();
        this.success = new Subject.Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    FolderActionsService.prototype.getHandler = function (key) {
        if (key) {
            var lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    };
    FolderActionsService.prototype.setHandler = function (key, handler) {
        if (key) {
            var lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    };
    FolderActionsService.prototype.canExecuteAction = function (obj) {
        return this.documentListService && obj && obj.entry.isFolder === true;
    };
    FolderActionsService.prototype.setupActionHandlers = function () {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
    };
    FolderActionsService.prototype.downloadNode = function (obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    };
    FolderActionsService.prototype.copyNode = function (obj, target, permission) {
        var actionObservable = this.nodeActionsService.copyFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'copy', target, permission);
        return actionObservable;
    };
    FolderActionsService.prototype.moveNode = function (obj, target, permission) {
        var actionObservable = this.nodeActionsService.moveFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'move', target, permission);
        return actionObservable;
    };
    FolderActionsService.prototype.prepareHandlers = function (actionObservable, type, action, target, permission) {
        var _this = this;
        actionObservable.subscribe(function (fileOperationMessage) {
            if (target && typeof target.reload === 'function') {
                target.reload();
            }
            _this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    };
    FolderActionsService.prototype.deleteNode = function (node, target, permission) {
        var _this = this;
        var handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasPermission(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe(function () {
                    if (target && typeof target.reload === 'function') {
                        target.reload();
                    }
                    var message = _this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    _this.success.next(message);
                }, function () {
                    var message = _this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    _this.error.next(message);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({ type: 'folder', action: 'delete', permission: permission }));
                return Observable.Observable.throw(new Error('No permission to delete'));
            }
        }
    };
    return FolderActionsService;
}());
FolderActionsService.decorators = [
    { type: core.Injectable },
];
FolderActionsService.ctorParameters = function () { return [
    { type: NodeActionsService, },
    { type: DocumentListService, },
    { type: adfCore.ContentService, },
    { type: adfCore.TranslationService, },
]; };
var ContentActionListComponent =               (function () {
    function ContentActionListComponent(documentList) {
        this.documentList = documentList;
    }
    ContentActionListComponent.prototype.registerAction = function (action) {
        if (this.documentList && action) {
            this.documentList.actions.push(action);
            return true;
        }
        return false;
    };
    return ContentActionListComponent;
}());
ContentActionListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'content-actions',
                template: ''
            },] },
];
ContentActionListComponent.ctorParameters = function () { return [
    { type: DocumentListComponent, },
]; };
var ContentActionComponent =               (function () {
    function ContentActionComponent(list, documentActions, folderActions) {
        this.list = list;
        this.documentActions = documentActions;
        this.folderActions = folderActions;
        this.title = 'Action';
        this.target = ContentActionTarget.All;
        this.disabled = false;
        this.execute = new core.EventEmitter();
        this.permissionEvent = new core.EventEmitter();
        this.error = new core.EventEmitter();
        this.success = new core.EventEmitter();
    }
    ContentActionComponent.prototype.ngOnInit = function () {
        if (this.target === ContentActionTarget.All) {
            this.generateAction(ContentActionTarget.Folder);
            this.generateAction(ContentActionTarget.Document);
        }
        else {
            this.generateAction(this.target);
        }
    };
    ContentActionComponent.prototype.register = function (model) {
        if (this.list) {
            return this.list.registerAction(model);
        }
        return false;
    };
    ContentActionComponent.prototype.generateAction = function (target) {
        var _this = this;
        var model = new ContentActionModel({
            title: this.title,
            icon: this.icon,
            permission: this.permission,
            disableWithNoPermission: this.disableWithNoPermission,
            target: target,
            disabled: this.disabled
        });
        if (this.handler) {
            model.handler = this.getSystemHandler(target, this.handler);
        }
        if (this.execute) {
            model.execute = function (value) {
                _this.execute.emit({ value: value });
            };
        }
        this.register(model);
    };
    ContentActionComponent.prototype.getSystemHandler = function (target, name) {
        var _this = this;
        if (target) {
            var ltarget = target.toLowerCase();
            if (ltarget === ContentActionTarget.Document) {
                if (this.documentActions) {
                    this.documentActions.permissionEvent.subscribe(function (permission) {
                        _this.permissionEvent.emit(permission);
                    });
                    this.documentActions.error.subscribe(function (errors) {
                        _this.error.emit(errors);
                    });
                    this.documentActions.success.subscribe(function (message) {
                        _this.success.emit(message);
                    });
                    return this.documentActions.getHandler(name);
                }
                return null;
            }
            if (ltarget === ContentActionTarget.Folder) {
                if (this.folderActions) {
                    this.folderActions.permissionEvent.subscribe(function (permission) {
                        _this.permissionEvent.emit(permission);
                    });
                    this.folderActions.error.subscribe(function (errors) {
                        _this.error.emit(errors);
                    });
                    this.folderActions.success.subscribe(function (message) {
                        _this.success.emit(message);
                    });
                    return this.folderActions.getHandler(name);
                }
                return null;
            }
        }
        return null;
    };
    return ContentActionComponent;
}());
ContentActionComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'content-action',
                template: '',
                providers: [
                    DocumentActionsService,
                    FolderActionsService
                ]
            },] },
];
ContentActionComponent.ctorParameters = function () { return [
    { type: ContentActionListComponent, },
    { type: DocumentActionsService, },
    { type: FolderActionsService, },
]; };
ContentActionComponent.propDecorators = {
    "title": [{ type: core.Input },],
    "icon": [{ type: core.Input },],
    "handler": [{ type: core.Input },],
    "target": [{ type: core.Input },],
    "permission": [{ type: core.Input },],
    "disableWithNoPermission": [{ type: core.Input },],
    "disabled": [{ type: core.Input },],
    "execute": [{ type: core.Output },],
    "permissionEvent": [{ type: core.Output },],
    "error": [{ type: core.Output },],
    "success": [{ type: core.Output },],
};
var EmptyFolderContentDirective =               (function () {
    function EmptyFolderContentDirective(documentList) {
        this.documentList = documentList;
    }
    EmptyFolderContentDirective.prototype.ngAfterContentInit = function () {
        this.documentList.emptyFolderTemplate = this.template;
        this.documentList.dataTable.noContentTemplate = this.template;
    };
    return EmptyFolderContentDirective;
}());
EmptyFolderContentDirective.decorators = [
    { type: core.Directive, args: [{
                selector: 'empty-folder-content'
            },] },
];
EmptyFolderContentDirective.ctorParameters = function () { return [
    { type: DocumentListComponent, },
]; };
EmptyFolderContentDirective.propDecorators = {
    "template": [{ type: core.ContentChild, args: [core.TemplateRef,] },],
};
var NoPermissionContentDirective =               (function () {
    function NoPermissionContentDirective(documentList) {
        this.documentList = documentList;
    }
    NoPermissionContentDirective.prototype.ngAfterContentInit = function () {
        this.documentList.noPermissionTemplate = this.template;
        this.documentList.dataTable.noPermissionTemplate = this.template;
    };
    return NoPermissionContentDirective;
}());
NoPermissionContentDirective.decorators = [
    { type: core.Directive, args: [{
                selector: 'no-permission-content'
            },] },
];
NoPermissionContentDirective.ctorParameters = function () { return [
    { type: DocumentListComponent, },
]; };
NoPermissionContentDirective.propDecorators = {
    "template": [{ type: core.ContentChild, args: [core.TemplateRef,] },],
};
var NodePaging =               (function () {
    function NodePaging() {
    }
    return NodePaging;
}());
var NodePagingList =               (function () {
    function NodePagingList() {
    }
    return NodePagingList;
}());
var NodeMinimalEntry =               (function () {
    function NodeMinimalEntry() {
    }
    return NodeMinimalEntry;
}());
var Pagination =               (function () {
    function Pagination() {
    }
    return Pagination;
}());
var NodeMinimal =               (function () {
    function NodeMinimal() {
        this.properties = {};
    }
    return NodeMinimal;
}());
var UserInfo =               (function () {
    function UserInfo() {
    }
    return UserInfo;
}());
var ContentInfo =               (function () {
    function ContentInfo() {
    }
    return ContentInfo;
}());
var PathInfoEntity =               (function () {
    function PathInfoEntity() {
    }
    return PathInfoEntity;
}());
var PathElementEntity =               (function () {
    function PathElementEntity() {
    }
    return PathElementEntity;
}());
var PermissionStyleModel =               (function () {
    function PermissionStyleModel(css, permission, isFile, isFolder) {
        if (isFile === void 0) { isFile = true; }
        if (isFolder === void 0) { isFolder = true; }
        this.isFolder = true;
        this.isFile = true;
        this.css = css;
        this.permission = permission;
        this.isFile = isFile;
        this.isFolder = isFolder;
    }
    return PermissionStyleModel;
}());
var FileUploadingListComponent =               (function () {
    function FileUploadingListComponent(uploadService, nodesApi, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.translateService = translateService;
        this.FileUploadStatus = adfCore.FileUploadStatus;
        this.files = [];
        this.error = new core.EventEmitter();
    }
    FileUploadingListComponent.prototype.cancelFile = function (file) {
        this.uploadService.cancelUpload(file);
    };
    FileUploadingListComponent.prototype.removeFile = function (file) {
        var _this = this;
        this.deleteNode(file)
            .subscribe(function () {
            if (file.status === adfCore.FileUploadStatus.Error) {
                _this.notifyError(file);
            }
            _this.uploadService.cancelUpload(file);
        });
    };
    FileUploadingListComponent.prototype.cancelAllFiles = function () {
        var _this = this;
        this.getUploadingFiles()
            .forEach(function (file) { return _this.uploadService.cancelUpload(file); });
        var deletedFiles = this.files
            .filter(function (file) { return file.status === adfCore.FileUploadStatus.Complete; })
            .map(function (file) { return _this.deleteNode(file); });
        Observable.Observable.forkJoin.apply(Observable.Observable, __spread(deletedFiles)).subscribe(function (files) {
            var errors = files
                .filter(function (file) { return file.status === adfCore.FileUploadStatus.Error; });
            if (errors.length) {
                _this.notifyError.apply(_this, __spread(errors));
            }
            (_b = _this.uploadService).cancelUpload.apply(_b, __spread(files));
            var _b;
        });
    };
    FileUploadingListComponent.prototype.isUploadCompleted = function () {
        return !this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files
                .some(function (_b) {
                var status = _b.status;
                return status === adfCore.FileUploadStatus.Starting ||
                    status === adfCore.FileUploadStatus.Progress ||
                    status === adfCore.FileUploadStatus.Pending;
            });
    };
    FileUploadingListComponent.prototype.isUploadCancelled = function () {
        return !!this.files.length &&
            this.files
                .every(function (_b) {
                var status = _b.status;
                return status === adfCore.FileUploadStatus.Aborted ||
                    status === adfCore.FileUploadStatus.Cancelled ||
                    status === adfCore.FileUploadStatus.Deleted;
            });
    };
    FileUploadingListComponent.prototype.deleteNode = function (file) {
        var id = file.data.entry.id;
        return this.nodesApi
            .deleteNode(id, { permanent: true })
            .map(function () {
            file.status = adfCore.FileUploadStatus.Deleted;
            return file;
        })
            .catch(function (error) {
            file.status = adfCore.FileUploadStatus.Error;
            return Observable.Observable.of(file);
        });
    };
    FileUploadingListComponent.prototype.notifyError = function () {
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        var messageError = null;
        if (files.length === 1) {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        this.error.emit(messageError);
    };
    FileUploadingListComponent.prototype.getUploadingFiles = function () {
        return this.files.filter(function (item) {
            if (item.status === adfCore.FileUploadStatus.Pending ||
                item.status === adfCore.FileUploadStatus.Progress ||
                item.status === adfCore.FileUploadStatus.Starting) {
                return item;
            }
        });
    };
    return FileUploadingListComponent;
}());
FileUploadingListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-file-uploading-list',
                template: "<div class=\"upload-list\">\n    <ng-template\n        ngFor\n        [ngForOf]=\"files\"\n        [ngForTemplate]=\"template\">\n    </ng-template>\n</div>\n",
                styles: [":host{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}"]
            },] },
];
FileUploadingListComponent.ctorParameters = function () { return [
    { type: adfCore.UploadService, },
    { type: adfCore.NodesApiService, },
    { type: adfCore.TranslationService, },
]; };
FileUploadingListComponent.propDecorators = {
    "template": [{ type: core.ContentChild, args: [core.TemplateRef,] },],
    "files": [{ type: core.Input },],
    "error": [{ type: core.Output },],
};
var FileUploadingDialogComponent =               (function () {
    function FileUploadingDialogComponent(uploadService, changeDetecor) {
        this.uploadService = uploadService;
        this.changeDetecor = changeDetecor;
        this.position = 'right';
        this.error = new core.EventEmitter();
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.isDialogMinimized = false;
        this.isConfirmation = false;
    }
    FileUploadingDialogComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.listSubscription = this.uploadService
            .queueChanged.subscribe(function (fileList) {
            _this.filesUploadingList = fileList;
            if (_this.filesUploadingList.length) {
                _this.isDialogActive = true;
            }
        });
        this.counterSubscription = Observable.Observable
            .merge(this.uploadService.fileUploadComplete, this.uploadService.fileUploadDeleted)
            .subscribe(function (event) {
            _this.totalCompleted = event.totalComplete;
            _this.changeDetecor.detectChanges();
        });
        this.errorSubscription = this.uploadService.fileUploadError
            .subscribe(function (event) {
            _this.totalErrors = event.totalError;
            _this.changeDetecor.detectChanges();
        });
        this.fileUploadSubscription = this.uploadService
            .fileUpload.subscribe(function () {
            _this.changeDetecor.detectChanges();
        });
        this.uploadService.fileDeleted.subscribe(function (objId) {
            if (_this.filesUploadingList) {
                var file = _this.filesUploadingList.find(function (item) {
                    return item.data.entry.id === objId;
                });
                if (file) {
                    file.status = adfCore.FileUploadStatus.Cancelled;
                    _this.changeDetecor.detectChanges();
                }
            }
        });
    };
    FileUploadingDialogComponent.prototype.toggleConfirmation = function () {
        this.isConfirmation = !this.isConfirmation;
        if (this.isDialogMinimized) {
            this.isDialogMinimized = false;
        }
    };
    FileUploadingDialogComponent.prototype.cancelAllUploads = function () {
        this.toggleConfirmation();
        this.uploadList.cancelAllFiles();
    };
    FileUploadingDialogComponent.prototype.toggleMinimized = function () {
        this.isDialogMinimized = !this.isDialogMinimized;
        this.changeDetecor.detectChanges();
    };
    FileUploadingDialogComponent.prototype.close = function () {
        this.isConfirmation = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.isDialogMinimized = false;
        this.uploadService.clearQueue();
        this.changeDetecor.detectChanges();
    };
    FileUploadingDialogComponent.prototype.ngOnDestroy = function () {
        this.uploadService.clearQueue();
        this.listSubscription.unsubscribe();
        this.counterSubscription.unsubscribe();
        this.fileUploadSubscription.unsubscribe();
        this.errorSubscription.unsubscribe();
    };
    return FileUploadingDialogComponent;
}());
FileUploadingDialogComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-file-uploading-dialog, file-uploading-dialog',
                template: "<div *ngIf=\"isDialogActive\"\n     class=\"upload-dialog\"\n     [class.upload-dialog--minimized]=\"isDialogMinimized\"\n     [class.upload-dialog--position-left]=\"position === 'left'\"\n     [class.upload-dialog--position-right]=\"position === 'right'\">\n    <header class=\"upload-dialog__header\">\n        <button\n            mat-button\n            color=\"secondary\"\n            [disabled]=\"isConfirmation\"\n            (click)=\"toggleMinimized()\">\n            <mat-icon\n                mat-list-icon\n                title=\"{{ (isDialogMinimized ? 'ADF_FILE_UPLOAD.BUTTON.MAXIMIZE': 'ADF_FILE_UPLOAD.BUTTON.MINIMIZE') | translate }}\">\n                    {{ isDialogMinimized ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}\n            </mat-icon>\n        </button>\n\n        <span\n            class=\"upload-dialog__title\"\n            *ngIf=\"!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_PROGRESS'\n                | translate: {\n                    completed: totalCompleted,\n                    total: filesUploadingList.length\n                }\n            }}\n        </span>\n\n        <span\n            class=\"upload-dialog__title\"\n            *ngIf=\"uploadList.isUploadCompleted()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_COMPLETED'\n                | translate: {\n                    completed: totalCompleted,\n                    total: filesUploadingList.length\n                }\n            }}\n        </span>\n\n        <span\n            class=\"upload-dialog__title\"\n            *ngIf=\"uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_CANCELED' | translate }}\n        </span>\n    </header>\n\n    <section\n        class=\"upload-dialog__info\"\n        *ngIf=\"totalErrors\">\n        {{\n            (totalErrors > 1\n                 ? 'FILE_UPLOAD.MESSAGES.UPLOAD_ERRORS'\n                 : 'FILE_UPLOAD.MESSAGES.UPLOAD_ERROR')\n                 | translate: { total: totalErrors }\n        }}\n    </section>\n\n    <section\n        class=\"upload-dialog__content\"\n        [class.upload-dialog--padding]=\"isConfirmation\">\n        <adf-file-uploading-list\n            (error)=\"onError($event)\"\n            [class.upload-dialog--hide]=\"isConfirmation\"\n            #uploadList\n            [files]=\"filesUploadingList\">\n                <ng-template let-file=\"$implicit\">\n                     <adf-file-uploading-list-row\n                        [file]=\"file\"\n                        (remove)=\"uploadList.removeFile(file)\"\n                        (cancel)=\"uploadList.cancelFile(file)\">\n                    </adf-file-uploading-list-row>\n                </ng-template>\n        </adf-file-uploading-list>\n\n        <div\n            class=\"upload-dialog__confirmation\"\n            [class.upload-dialog--hide]=\"!isConfirmation\">\n                <p class=\"upload-dialog__confirmation--title\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TITLE' | translate }}\n                </p>\n\n                <p class=\"upload-dialog__confirmation--text\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TEXT' | translate }}\n                </p>\n        </div>\n    </section>\n\n    <footer\n        class=\"upload-dialog__actions\"\n        [class.upload-dialog--hide]=\"isConfirmation\">\n        <button\n            color=\"primary\"\n            mat-button\n            *ngIf=\"!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_ALL' | translate }}\n        </button>\n\n        <button\n            *ngIf=\"uploadList.isUploadCompleted() || uploadList.isUploadCancelled()\"\n            mat-button\n            color=\"primary\"\n            (click)=\"close($event)\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CLOSE' | translate }}\n        </button>\n    </footer>\n\n    <footer\n        class=\"upload-dialog__actions\"\n        [class.upload-dialog--hide]=\"!isConfirmation\">\n        <button\n            color=\"secondary\"\n            mat-button\n            (click)=\"cancelAllUploads()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CANCEL' | translate }}\n        </button>\n\n        <button\n            mat-button\n            color=\"primary\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CONTINUE' | translate }}\n        </button>\n    </footer>\n</div>\n",
                styles: [""]
            },] },
];
FileUploadingDialogComponent.ctorParameters = function () { return [
    { type: adfCore.UploadService, },
    { type: core.ChangeDetectorRef, },
]; };
FileUploadingDialogComponent.propDecorators = {
    "uploadList": [{ type: core.ViewChild, args: ['uploadList',] },],
    "position": [{ type: core.Input },],
    "error": [{ type: core.Output },],
};
var FileUploadingListRowComponent =               (function () {
    function FileUploadingListRowComponent() {
        this.cancel = new core.EventEmitter();
        this.remove = new core.EventEmitter();
        this.FileUploadStatus = adfCore.FileUploadStatus;
    }
    FileUploadingListRowComponent.prototype.onCancel = function (file) {
        this.cancel.emit(file);
    };
    FileUploadingListRowComponent.prototype.onRemove = function (file) {
        this.remove.emit(file);
    };
    return FileUploadingListRowComponent;
}());
FileUploadingListRowComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-file-uploading-list-row',
                template: "<div class=\"adf-file-uploading-row\">\n    <mat-icon\n        mat-list-icon\n        class=\"adf-file-uploading-row__type\">\n        insert_drive_file\n    </mat-icon>\n\n    <span\n        class=\"adf-file-uploading-row__name\"\n        title=\"{{ file.name }}\">\n        {{ file.name }}\n    </span>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Progress || file.status === FileUploadStatus.Starting\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_FILE' | translate }}\">\n        <span class=\"adf-file-uploading-row__status\">\n            {{ file.progress.loaded | adfFileSize }} / {{ file.progress.total | adfFileSize }}\n        </span>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--cancel\">\n            clear\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Complete\"\n        (click)=\"onRemove(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.REMOVE_FILE' | translate }}\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--done\">\n            check_circle\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Pending\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--pending\">\n            schedule\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Error\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--error\"\n        title=\"{{ file.response }}\">\n        <mat-icon mat-list-icon>\n            report_problem\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Cancelled  ||\n            file.status === FileUploadStatus.Aborted ||\n            file.status === FileUploadStatus.Deleted\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--cancelled\">\n        {{ 'ADF_FILE_UPLOAD.STATUS.FILE_CANCELED_STATUS' | translate }}\n    </div>\n<div>",
                styles: [""]
            },] },
];
FileUploadingListRowComponent.ctorParameters = function () { return []; };
FileUploadingListRowComponent.propDecorators = {
    "file": [{ type: core.Input },],
    "cancel": [{ type: core.Output },],
    "remove": [{ type: core.Output },],
};
var UploadBase =               (function () {
    function UploadBase() {
        this.acceptedFilesType = '*';
    }
    UploadBase.prototype.isFileAcceptable = function (file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        var allowedExtensions = this.acceptedFilesType
            .split(',')
            .map(function (ext) { return ext.replace(/^\./, ''); });
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    };
    return UploadBase;
}());
UploadBase.propDecorators = {
    "acceptedFilesType": [{ type: core.Input },],
};
var UploadButtonComponent =               (function (_super) {
    __extends(UploadButtonComponent, _super);
    function UploadButtonComponent(uploadService, contentService, translateService, logService) {
        var _this = _super.call(this) || this;
        _this.uploadService = uploadService;
        _this.contentService = contentService;
        _this.translateService = translateService;
        _this.logService = logService;
        _this.disabled = false;
        _this.uploadFolders = false;
        _this.multipleFiles = false;
        _this.versioning = false;
        _this.tooltip = null;
        _this.rootFolderId = '-root-';
        _this.success = new core.EventEmitter();
        _this.error = new core.EventEmitter();
        _this.createFolder = new core.EventEmitter();
        _this.permissionEvent = new core.EventEmitter();
        _this.hasPermission = false;
        _this.permissionValue = new Subject.Subject();
        return _this;
    }
    UploadButtonComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.permissionValue.subscribe(function (permission) {
            _this.hasPermission = permission;
        });
    };
    UploadButtonComponent.prototype.ngOnChanges = function (changes) {
        var rootFolderId = changes['rootFolderId'];
        if (rootFolderId && rootFolderId.currentValue) {
            this.checkPermission();
        }
    };
    UploadButtonComponent.prototype.isButtonDisabled = function () {
        return this.disabled ? true : undefined;
    };
    UploadButtonComponent.prototype.onFilesAdded = function ($event) {
        var files = adfCore.FileUtils.toFileArray($event.currentTarget.files);
        if (this.hasPermission) {
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        $event.target.value = '';
    };
    UploadButtonComponent.prototype.onDirectoryAdded = function ($event) {
        if (this.hasPermission) {
            var files = adfCore.FileUtils.toFileArray($event.currentTarget.files);
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        $event.target.value = '';
    };
    UploadButtonComponent.prototype.uploadFiles = function (files) {
        var latestFilesAdded = files
            .map(this.createFileModel.bind(this))
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        if (latestFilesAdded.length > 0) {
            (_b = this.uploadService).addToQueue.apply(_b, __spread(latestFilesAdded));
            this.uploadService.uploadFilesInTheQueue(this.success);
        }
        var _b;
    };
    UploadButtonComponent.prototype.createFileModel = function (file) {
        return new adfCore.FileModel(file, {
            newVersion: this.versioning,
            parentId: this.rootFolderId,
            path: (file.webkitRelativePath || '').replace(/\/[^\/]*$/, '')
        });
    };
    UploadButtonComponent.prototype.isFileSizeAcceptable = function (file) {
        var _this = this;
        var acceptableSize = true;
        if (this.isFileSizeAllowed(file)) {
            acceptableSize = false;
            this.translateService.get('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name }).subscribe(function (message) {
                _this.error.emit(message);
            });
        }
        return acceptableSize;
    };
    UploadButtonComponent.prototype.isFileSizeAllowed = function (file) {
        return this.isMaxFileSizeDefined() && this.isFileSizeCorrect(file);
    };
    UploadButtonComponent.prototype.isMaxFileSizeDefined = function () {
        return this.maxFilesSize !== undefined && this.maxFilesSize !== null;
    };
    UploadButtonComponent.prototype.isFileSizeCorrect = function (file) {
        return this.maxFilesSize < 0 || file.size > this.maxFilesSize;
    };
    UploadButtonComponent.prototype.checkPermission = function () {
        var _this = this;
        if (this.rootFolderId) {
            var opts = {
                includeSource: true,
                include: ['allowableOperations']
            };
            this.contentService.getNode(this.rootFolderId, opts).subscribe(function (res) { return _this.permissionValue.next(_this.hasCreatePermission(res.entry)); }, function (error) { return _this.error.emit(error); });
        }
    };
    UploadButtonComponent.prototype.hasCreatePermission = function (node) {
        if (node && node.allowableOperations) {
            return node.allowableOperations.find(function (permission) { return permission === 'create'; }) ? true : false;
        }
        return false;
    };
    return UploadButtonComponent;
}(UploadBase));
UploadButtonComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-upload-button',
                template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"],
                viewProviders: [
                    { provide: adfCore.EXTENDIBLE_COMPONENT, useExisting: core.forwardRef(function () { return UploadButtonComponent; }) }
                ],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
UploadButtonComponent.ctorParameters = function () { return [
    { type: adfCore.UploadService, },
    { type: adfCore.ContentService, },
    { type: adfCore.TranslationService, },
    { type: adfCore.LogService, },
]; };
UploadButtonComponent.propDecorators = {
    "disabled": [{ type: core.Input },],
    "uploadFolders": [{ type: core.Input },],
    "multipleFiles": [{ type: core.Input },],
    "versioning": [{ type: core.Input },],
    "maxFilesSize": [{ type: core.Input },],
    "staticTitle": [{ type: core.Input },],
    "tooltip": [{ type: core.Input },],
    "rootFolderId": [{ type: core.Input },],
    "success": [{ type: core.Output },],
    "error": [{ type: core.Output },],
    "createFolder": [{ type: core.Output },],
    "permissionEvent": [{ type: core.Output },],
};
var UploadVersionButtonComponent =               (function (_super) {
    __extends(UploadVersionButtonComponent, _super);
    function UploadVersionButtonComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UploadVersionButtonComponent.prototype.ngOnChanges = function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (changes['acceptedFilesType']) {
            var message = this.translateService.instant('FILE_UPLOAD.VERSION.MESSAGES.NO_ACCEPTED_FILE_TYPES');
            this.logService.error(message);
        }
        this.acceptedFilesType = '.' + this.node.name.split('.').pop();
    };
    UploadVersionButtonComponent.prototype.createFileModel = function (file) {
        var fileModel = _super.prototype.createFileModel.call(this, file);
        fileModel.options.newVersionBaseName = this.node.name;
        if (!this.isFileAcceptable(fileModel)) {
            var message = this.translateService.instant('FILE_UPLOAD.VERSION.MESSAGES.INCOMPATIBLE_VERSION');
            this.error.emit(message);
        }
        return fileModel;
    };
    return UploadVersionButtonComponent;
}(UploadButtonComponent));
UploadVersionButtonComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-upload-version-button',
                template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"],
                viewProviders: [
                    { provide: adfCore.EXTENDIBLE_COMPONENT, useExisting: core.forwardRef(function () { return UploadVersionButtonComponent; }) }
                ],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
UploadVersionButtonComponent.ctorParameters = function () { return []; };
UploadVersionButtonComponent.propDecorators = {
    "node": [{ type: core.Input },],
};
var UploadDragAreaComponent =               (function (_super) {
    __extends(UploadDragAreaComponent, _super);
    function UploadDragAreaComponent(uploadService, translateService, notificationService) {
        var _this = _super.call(this) || this;
        _this.uploadService = uploadService;
        _this.translateService = translateService;
        _this.notificationService = notificationService;
        _this.disabled = false;
        _this.versioning = false;
        _this.success = new core.EventEmitter();
        _this.error = new core.EventEmitter();
        return _this;
    }
    UploadDragAreaComponent.prototype.onFilesDropped = function (files) {
        var _this = this;
        if (!this.disabled && files.length) {
            var fileModels = files.map(function (file) { return new adfCore.FileModel(file, {
                newVersion: _this.versioning,
                path: '/',
                parentId: _this.parentId
            }); }).filter(this.isFileAcceptable.bind(this));
            this.addNodeInUploadQueue(fileModels);
        }
    };
    UploadDragAreaComponent.prototype.onFilesEntityDropped = function (item) {
        var _this = this;
        if (!this.disabled) {
            item.file(function (file) {
                var fileModel = new adfCore.FileModel(file, {
                    newVersion: _this.versioning,
                    parentId: _this.parentId,
                    path: item.fullPath.replace(item.name, '')
                });
                if (_this.isFileAcceptable(fileModel)) {
                    _this.addNodeInUploadQueue([fileModel]);
                }
            });
        }
    };
    UploadDragAreaComponent.prototype.onFolderEntityDropped = function (folder) {
        var _this = this;
        if (!this.disabled && folder.isDirectory) {
            adfCore.FileUtils.flattern(folder).then(function (entries) {
                var files = entries.map(function (entry) {
                    return new adfCore.FileModel(entry.file, {
                        newVersion: _this.versioning,
                        parentId: _this.parentId,
                        path: entry.relativeFolder
                    });
                }).filter(_this.isFileAcceptable.bind(_this));
                _this.addNodeInUploadQueue(files);
            });
        }
    };
    UploadDragAreaComponent.prototype.addNodeInUploadQueue = function (files) {
        var _this = this;
        if (files.length) {
            (_b = this.uploadService).addToQueue.apply(_b, __spread(files));
            this.uploadService.uploadFilesInTheQueue(this.success);
            this.uploadService.fileUploadError.subscribe(function (error) {
                _this.error.emit(error);
            });
        }
        var _b;
    };
    UploadDragAreaComponent.prototype.showUndoNotificationBar = function (latestFilesAdded) {
        var _this = this;
        var messageTranslate, actionTranslate;
        messageTranslate = this.translateService.get('FILE_UPLOAD.MESSAGES.PROGRESS');
        actionTranslate = this.translateService.get('FILE_UPLOAD.ACTION.UNDO');
        this.notificationService.openSnackMessageAction(messageTranslate.value, actionTranslate.value, 3000).onAction().subscribe(function () {
            (_b = _this.uploadService).cancelUpload.apply(_b, __spread(latestFilesAdded));
            var _b;
        });
    };
    UploadDragAreaComponent.prototype.isDroppable = function () {
        return !this.disabled;
    };
    UploadDragAreaComponent.prototype.onUploadFiles = function (event) {
        var _this = this;
        event.stopPropagation();
        event.preventDefault();
        var isAllowed = this.hasCreatePermission(event.detail.data.obj.entry);
        if (isAllowed) {
            var files = event.detail.files;
            if (files && files.length > 0) {
                var parentId_1 = this.parentId;
                if (event.detail.data && event.detail.data.obj.entry.isFolder) {
                    parentId_1 = event.detail.data.obj.entry.id || this.parentId;
                }
                var fileModels = files.map(function (fileInfo) { return new adfCore.FileModel(fileInfo.file, {
                    newVersion: _this.versioning,
                    path: fileInfo.relativeFolder,
                    parentId: parentId_1
                }); }).filter(this.isFileAcceptable.bind(this));
                this.addNodeInUploadQueue(fileModels);
            }
        }
    };
    UploadDragAreaComponent.prototype.hasCreatePermission = function (node) {
        var isPermitted = false;
        if (node && node['allowableOperations']) {
            var permFound = node['allowableOperations'].find(function (element) { return element === 'create'; });
            isPermitted = permFound ? true : false;
        }
        return isPermitted;
    };
    return UploadDragAreaComponent;
}(UploadBase));
UploadDragAreaComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-upload-drag-area',
                template: "<div [file-draggable]=\"isDroppable()\" id=\"UploadBorder\" class=\"upload-border\"\n     (filesDropped)=\"onFilesDropped($event)\"\n     (filesEntityDropped)=\"onFilesEntityDropped($event)\"\n     (folderEntityDropped)=\"onFolderEntityDropped($event)\"\n     (upload-files)=\"onUploadFiles($event)\"\n     dropzone=\"\" webkitdropzone=\"*\" #droparea>\n    <ng-content></ng-content>\n</div>\n",
                styles: ["adf-upload-drag-area{overflow:hidden}.upload-border{vertical-align:middle;text-align:center;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.file-draggable__input-focus{color:#2196f3;border:1px dashed #2196f3}"],
                host: { 'class': 'adf-upload-drag-area' },
                viewProviders: [
                    { provide: adfCore.EXTENDIBLE_COMPONENT, useExisting: core.forwardRef(function () { return UploadDragAreaComponent; }) }
                ],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
UploadDragAreaComponent.ctorParameters = function () { return [
    { type: adfCore.UploadService, },
    { type: adfCore.TranslationService, },
    { type: adfCore.NotificationService, },
]; };
UploadDragAreaComponent.propDecorators = {
    "disabled": [{ type: core.Input },],
    "versioning": [{ type: core.Input },],
    "parentId": [{ type: core.Input },],
    "success": [{ type: core.Output },],
    "error": [{ type: core.Output },],
};
var FileDraggableDirective =               (function () {
    function FileDraggableDirective(el, ngZone) {
        this.ngZone = ngZone;
        this.enabled = true;
        this.filesDropped = new core.EventEmitter();
        this.filesEntityDropped = new core.EventEmitter();
        this.folderEntityDropped = new core.EventEmitter();
        this.cssClassName = 'file-draggable__input-focus';
        this.element = el.nativeElement;
    }
    FileDraggableDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            _this.element.addEventListener('dragenter', _this.onDragEnter.bind(_this));
            _this.element.addEventListener('dragover', _this.onDragOver.bind(_this));
            _this.element.addEventListener('dragleave', _this.onDragLeave.bind(_this));
            _this.element.addEventListener('drop', _this.onDropFiles.bind(_this));
        });
    };
    FileDraggableDirective.prototype.ngOnDestroy = function () {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDropFiles);
    };
    FileDraggableDirective.prototype.onDropFiles = function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            var items = event.dataTransfer.items;
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    if (typeof items[i].webkitGetAsEntry !== 'undefined') {
                        var item = items[i].webkitGetAsEntry();
                        if (item) {
                            if (item.isFile) {
                                this.filesEntityDropped.emit(item);
                            }
                            else if (item.isDirectory) {
                                this.folderEntityDropped.emit(item);
                            }
                        }
                    }
                    else {
                        var files = adfCore.FileUtils.toFileArray(event.dataTransfer.files);
                        this.filesDropped.emit(files);
                    }
                }
            }
            else {
                var files = adfCore.FileUtils.toFileArray(event.dataTransfer.files);
                this.filesDropped.emit(files);
            }
            this.element.classList.remove(this.cssClassName);
        }
    };
    FileDraggableDirective.prototype.onDragEnter = function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    };
    FileDraggableDirective.prototype.onDragLeave = function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.remove(this.cssClassName);
        }
    };
    FileDraggableDirective.prototype.onDragOver = function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    };
    FileDraggableDirective.prototype.preventDefault = function (event) {
        event.stopPropagation();
        event.preventDefault();
    };
    return FileDraggableDirective;
}());
FileDraggableDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[file-draggable]'
            },] },
];
FileDraggableDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.NgZone, },
]; };
FileDraggableDirective.propDecorators = {
    "enabled": [{ type: core.Input, args: ['file-draggable',] },],
    "filesDropped": [{ type: core.Output },],
    "filesEntityDropped": [{ type: core.Output },],
    "folderEntityDropped": [{ type: core.Output },],
};
var UploadModule =               (function () {
    function UploadModule() {
    }
    return UploadModule;
}());
UploadModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    adfCore.PipeModule
                ],
                declarations: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ],
                exports: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ]
            },] },
];
UploadModule.ctorParameters = function () { return []; };
var DocumentListModule =               (function () {
    function DocumentListModule() {
    }
    return DocumentListModule;
}());
DocumentListModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    adfCore.ToolbarModule,
                    common.CommonModule,
                    adfCore.DataTableModule,
                    flexLayout.FlexLayoutModule,
                    MaterialModule,
                    UploadModule,
                    core$1.TranslateModule,
                    adfCore.PaginationModule
                ],
                declarations: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ],
                providers: [
                    DocumentListService,
                    FolderActionsService,
                    DocumentActionsService,
                    NodeActionsService,
                    CustomResourcesService
                ],
                exports: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ]
            },] },
];
DocumentListModule.ctorParameters = function () { return []; };
var SearchQueryBuilderService =               (function () {
    function SearchQueryBuilderService(appConfig, api) {
        this.api = api;
        this.updated = new Subject.Subject();
        this.executed = new Subject.Subject();
        this.categories = [];
        this.queryFragments = {};
        this.fields = {};
        this.filterQueries = [];
        this.ranges = {};
        this.paging = null;
        this.config = appConfig.get('search');
        if (!this.config) {
            throw new Error('Search configuration not found.');
        }
        if (this.config.query && this.config.query.categories) {
            this.categories = this.config.query.categories.filter(function (f) { return f.enabled; });
        }
        this.filterQueries = this.config.filterQueries || [];
        this.scope = {
            locations: null
        };
    }
    SearchQueryBuilderService.prototype.addFilterQuery = function (query) {
        if (query) {
            var existing = this.filterQueries.find(function (q) { return q.query === query; });
            if (!existing) {
                this.filterQueries.push({ query: query });
            }
        }
    };
    SearchQueryBuilderService.prototype.removeFilterQuery = function (query) {
        if (query) {
            this.filterQueries = this.filterQueries.filter(function (f) { return f.query !== query; });
        }
    };
    SearchQueryBuilderService.prototype.getFacetQuery = function (label) {
        if (label) {
            var queries = this.config.facetQueries || [];
            return queries.find(function (q) { return q.label === label; });
        }
        return null;
    };
    SearchQueryBuilderService.prototype.update = function () {
        var query = this.buildQuery();
        this.updated.next(query);
    };
    SearchQueryBuilderService.prototype.execute = function () {
        return __awaiter(this, void 0, void 0, function () {
            var query, data;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        query = this.buildQuery();
                        return [4          , this.api.searchApi.search(query)];
                    case 1:
                        data = _b.sent();
                        this.executed.next(data);
                        return [2           ];
                }
            });
        });
    };
    SearchQueryBuilderService.prototype.buildQuery = function () {
        var _this = this;
        var query = '';
        var fields = [];
        this.categories.forEach(function (facet) {
            var customQuery = _this.queryFragments[facet.id];
            if (customQuery) {
                if (query.length > 0) {
                    query += ' AND ';
                }
                query += "(" + customQuery + ")";
            }
            var customFields = _this.fields[facet.id];
            if (customFields && customFields.length > 0) {
                try {
                    for (var customFields_1 = __values(customFields), customFields_1_1 = customFields_1.next(); !customFields_1_1.done; customFields_1_1 = customFields_1.next()) {
                        var field = customFields_1_1.value;
                        if (!fields.includes(field)) {
                            fields.push(field);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (customFields_1_1 && !customFields_1_1.done && (_b = customFields_1.return)) _b.call(customFields_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            var e_1, _b;
        });
        if (query) {
            var result = {
                query: {
                    query: query,
                    language: 'afts'
                },
                include: ['path', 'allowableOperations'],
                fields: fields,
                paging: this.paging,
                filterQueries: this.filterQueries,
                facetQueries: this.config.facetQueries,
                facetFields: this.config.facetFields,
                limits: this.config.limits,
                scope: this.scope
            };
            return result;
        }
        return null;
    };
    return SearchQueryBuilderService;
}());
SearchQueryBuilderService.decorators = [
    { type: core.Injectable },
];
SearchQueryBuilderService.ctorParameters = function () { return [
    { type: adfCore.AppConfigService, },
    { type: adfCore.AlfrescoApiService, },
]; };
var SearchComponent =               (function () {
    function SearchComponent(searchService, _elementRef) {
        var _this = this;
        this.searchService = searchService;
        this._elementRef = _elementRef;
        this.displayWith = null;
        this.maxResults = 20;
        this.skipResults = 0;
        this.searchTerm = '';
        this.resultLoaded = new core.EventEmitter();
        this.error = new core.EventEmitter();
        this.showPanel = false;
        this._isOpen = false;
        this.keyPressedStream = new Subject.Subject();
        this._classList = {};
        this.keyPressedStream.asObservable()
            .debounceTime(200)
            .subscribe(function (searchedWord) {
            _this.loadSearchResults(searchedWord);
        });
        searchService.dataLoaded.subscribe(function (data) { return _this.onSearchDataLoaded(data); }, function (error) { return _this.onSearchDataError(error); });
    }
    Object.defineProperty(SearchComponent.prototype, "classList", {
        set: function (classList) {
            var _this = this;
            if (classList && classList.length) {
                classList.split(' ').forEach(function (className) { return _this._classList[className.trim()] = true; });
                this._elementRef.nativeElement.className = '';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchComponent.prototype, "isOpen", {
        get: function () {
            return this._isOpen && this.showPanel;
        },
        set: function (value) {
            this._isOpen = value;
        },
        enumerable: true,
        configurable: true
    });
    SearchComponent.prototype.ngAfterContentInit = function () {
        this.setVisibility();
    };
    SearchComponent.prototype.ngOnChanges = function (changes) {
        if (changes.queryBody &&
            this.hasDifferentQueryBody(changes.queryBody.previousValue, changes.queryBody.currentValue)) {
            this.loadSearchResults();
        }
        if (changes.searchTerm && changes.searchTerm.currentValue) {
            this.loadSearchResults(changes.searchTerm.currentValue);
        }
    };
    SearchComponent.prototype.resetResults = function () {
        this.cleanResults();
        this.setVisibility();
    };
    SearchComponent.prototype.reload = function () {
        this.loadSearchResults(this.searchTerm);
    };
    SearchComponent.prototype.hasDifferentQueryBody = function (previousQueryBody, currentQueryBody) {
        return JSON.stringify(previousQueryBody) !== JSON.stringify(currentQueryBody);
    };
    SearchComponent.prototype.cleanResults = function () {
        if (this.results) {
            this.results = {};
        }
    };
    SearchComponent.prototype.loadSearchResults = function (searchTerm) {
        var _this = this;
        this.resetResults();
        if (searchTerm) {
            if (this.queryBody) {
                this.searchService.searchByQueryBody(this.queryBody).subscribe(function (result) { return _this.onSearchDataLoaded(result); }, function (err) { return _this.onSearchDataError(err); });
            }
            else {
                this.searchService.search(searchTerm, this.maxResults, this.skipResults).subscribe(function (result) { return _this.onSearchDataLoaded(result); }, function (err) { return _this.onSearchDataError(err); });
            }
        }
        else {
            this.cleanResults();
        }
    };
    SearchComponent.prototype.onSearchDataLoaded = function (data) {
        if (data) {
            this.results = data;
            this.resultLoaded.emit(this.results);
            this.isOpen = true;
            this.setVisibility();
        }
    };
    SearchComponent.prototype.onSearchDataError = function (error) {
        if (error && error.status !== 400) {
            this.results = null;
            this.error.emit(error);
        }
    };
    SearchComponent.prototype.hidePanel = function () {
        if (this.isOpen) {
            this._classList['adf-search-show'] = false;
            this._classList['adf-search-hide'] = true;
            this.isOpen = false;
        }
    };
    SearchComponent.prototype.setVisibility = function () {
        this.showPanel = !!this.results && !!this.results.list;
        this._classList['adf-search-show'] = this.showPanel;
        this._classList['adf-search-hide'] = !this.showPanel;
    };
    return SearchComponent;
}());
SearchComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search',
                template: "<div role=\"listbox\" id=\"adf-search-results-content\" [ngClass]=\"_classList\" #panel>\n    <ng-template\n        [ngTemplateOutlet]=\"template\"\n        [ngTemplateOutletContext]=\"{ $implicit: results }\">\n    </ng-template>\n</div>\n\n\n",
                styles: [""],
                encapsulation: core.ViewEncapsulation.None,
                preserveWhitespaces: false,
                exportAs: 'searchAutocomplete',
                host: {
                    'class': 'adf-search'
                }
            },] },
];
SearchComponent.ctorParameters = function () { return [
    { type: adfCore.SearchService, },
    { type: core.ElementRef, },
]; };
SearchComponent.propDecorators = {
    "panel": [{ type: core.ViewChild, args: ['panel',] },],
    "template": [{ type: core.ContentChild, args: [core.TemplateRef,] },],
    "displayWith": [{ type: core.Input },],
    "maxResults": [{ type: core.Input },],
    "skipResults": [{ type: core.Input },],
    "queryBody": [{ type: core.Input },],
    "searchTerm": [{ type: core.Input },],
    "classList": [{ type: core.Input, args: ['class',] },],
    "resultLoaded": [{ type: core.Output },],
    "error": [{ type: core.Output },],
};
var EmptySearchResultComponent =               (function () {
    function EmptySearchResultComponent() {
    }
    return EmptySearchResultComponent;
}());
EmptySearchResultComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-empty-search-result',
                template: "<div class=\"adf-empty-search-result\">\n    <ng-content></ng-content>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None
            },] },
];
EmptySearchResultComponent.ctorParameters = function () { return []; };
var SearchControlComponent =               (function () {
    function SearchControlComponent(authService, thumbnailService) {
        var _this = this;
        this.authService = authService;
        this.thumbnailService = thumbnailService;
        this.expandable = true;
        this.highlight = false;
        this.inputType = 'text';
        this.autocomplete = false;
        this.liveSearchEnabled = true;
        this.liveSearchMaxResults = 5;
        this.submit = new core.EventEmitter();
        this.searchChange = new core.EventEmitter();
        this.optionClicked = new core.EventEmitter();
        this.searchTerm = '';
        this.noSearchResultTemplate = null;
        this.toggleSearch = new Subject.Subject();
        this.focusSubject = new Subject.Subject();
        this.toggleSearch.asObservable().pipe(operators.debounceTime(200)).subscribe(function () {
            if (_this.expandable) {
                _this.subscriptAnimationState = _this.subscriptAnimationState === 'inactive' ? 'active' : 'inactive';
                if (_this.subscriptAnimationState === 'inactive') {
                    _this.searchTerm = '';
                    _this.searchAutocomplete.resetResults();
                    if (document.activeElement.id === _this.searchInput.nativeElement.id) {
                        _this.searchInput.nativeElement.blur();
                    }
                }
            }
        });
    }
    SearchControlComponent.prototype.applySearchFocus = function (animationDoneEvent) {
        if (animationDoneEvent.toState === 'active') {
            this.searchInput.nativeElement.focus();
        }
    };
    SearchControlComponent.prototype.ngOnInit = function () {
        this.subscriptAnimationState = this.expandable ? 'inactive' : 'no-animation';
        this.setupFocusEventHandlers();
    };
    SearchControlComponent.prototype.isNoSearchTemplatePresent = function () {
        return this.emptySearchTemplate ? true : false;
    };
    SearchControlComponent.prototype.ngOnDestroy = function () {
        if (this.focusSubject) {
            this.focusSubject.unsubscribe();
            this.focusSubject = null;
        }
        if (this.toggleSearch) {
            this.toggleSearch.unsubscribe();
            this.toggleSearch = null;
        }
    };
    SearchControlComponent.prototype.isLoggedIn = function () {
        return this.authService.isEcmLoggedIn();
    };
    SearchControlComponent.prototype.searchSubmit = function (event) {
        this.submit.emit(event);
        this.toggleSearchBar();
    };
    SearchControlComponent.prototype.inputChange = function (event) {
        this.searchChange.emit(event);
    };
    SearchControlComponent.prototype.getAutoComplete = function () {
        return this.autocomplete ? 'on' : 'off';
    };
    SearchControlComponent.prototype.getMimeTypeIcon = function (node) {
        var mimeType;
        if (node.entry.content && node.entry.content.mimeType) {
            mimeType = node.entry.content.mimeType;
        }
        if (node.entry.isFolder) {
            mimeType = 'folder';
        }
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    };
    SearchControlComponent.prototype.isSearchBarActive = function () {
        return this.subscriptAnimationState === 'active' && this.liveSearchEnabled;
    };
    SearchControlComponent.prototype.toggleSearchBar = function () {
        if (this.toggleSearch) {
            this.toggleSearch.next();
        }
    };
    SearchControlComponent.prototype.elementClicked = function (item) {
        if (item.entry) {
            this.optionClicked.next(item);
            this.toggleSearchBar();
        }
    };
    SearchControlComponent.prototype.onFocus = function ($event) {
        this.focusSubject.next($event);
    };
    SearchControlComponent.prototype.onBlur = function ($event) {
        this.focusSubject.next($event);
    };
    SearchControlComponent.prototype.activateToolbar = function () {
        if (!this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
    };
    SearchControlComponent.prototype.selectFirstResult = function () {
        if (this.listResultElement && this.listResultElement.length > 0) {
            var firstElement = (this.listResultElement.first);
            firstElement._getHostElement().focus();
        }
    };
    SearchControlComponent.prototype.onRowArrowDown = function ($event) {
        var nextElement = this.getNextElementSibling(($event.target));
        if (nextElement) {
            nextElement.focus();
        }
    };
    SearchControlComponent.prototype.onRowArrowUp = function ($event) {
        var previousElement = this.getPreviousElementSibling(($event.target));
        if (previousElement) {
            previousElement.focus();
        }
        else {
            this.searchInput.nativeElement.focus();
            this.focusSubject.next(new FocusEvent('focus'));
        }
    };
    SearchControlComponent.prototype.setupFocusEventHandlers = function () {
        var _this = this;
        var focusEvents = this.focusSubject.asObservable()
            .debounceTime(50);
        focusEvents.filter(function ($event) {
            return _this.isSearchBarActive() && ($event.type === 'blur' || $event.type === 'focusout');
        }).subscribe(function () {
            _this.toggleSearchBar();
        });
    };
    SearchControlComponent.prototype.getNextElementSibling = function (node) {
        return node.nextElementSibling;
    };
    SearchControlComponent.prototype.getPreviousElementSibling = function (node) {
        return node.previousElementSibling;
    };
    return SearchControlComponent;
}());
SearchControlComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-control',
                template: "<div class=\"adf-search-container\">\n    <div *ngIf=\"isLoggedIn()\" [@transitionMessages]=\"subscriptAnimationState\" (@transitionMessages.done)=\"applySearchFocus($event)\">\n        <a mat-icon-button\n            *ngIf=\"expandable\"\n            id=\"adf-search-button\"\n            class=\"adf-search-button\"\n            (click)=\"toggleSearchBar($event)\"\n            (keyup.enter)=\"toggleSearchBar($event)\">\n            <mat-icon aria-label=\"search button\">search</mat-icon>\n        </a>\n        <mat-form-field class=\"adf-input-form-field-divider\">\n            <input matInput #searchInput\n                [type]=\"inputType\"\n                [autocomplete]=\"getAutoComplete()\"\n                id=\"adf-control-input\"\n                [(ngModel)]=\"searchTerm\"\n                (focus)=\"activateToolbar($event)\"\n                (blur)=\"onBlur($event)\"\n                (keyup.escape)=\"toggleSearchBar()\"\n                (keyup.arrowdown)=\"selectFirstResult()\"\n                (ngModelChange)=\"inputChange($event)\"\n                [searchAutocomplete]=\"auto\"\n                (keyup.enter)=\"searchSubmit($event)\">\n        </mat-form-field>\n    </div>\n</div>\n\n<adf-search #search\n            #auto=\"searchAutocomplete\"\n            class=\"adf-search-result-autocomplete\"\n            [maxResults]=\"liveSearchMaxResults\"\n            [queryBody]=\"customQueryBody\">\n    <ng-template let-data>\n        <mat-list *ngIf=\"isSearchBarActive()\" id=\"autocomplete-search-result-list\">\n            <mat-list-item\n                *ngFor=\"let item of data?.list?.entries; let idx = index\"\n                id=\"result_option_{{idx}}\"\n                [attr.data-automation-id]=\"'autocomplete_for_' + item.entry.name\"\n                [tabindex]=\"0\"\n                (focus)=\"onFocus($event)\"\n                (blur)=\"onBlur($event)\"\n                (keyup.arrowdown)=\"onRowArrowDown($event)\"\n                (keyup.arrowup)=\"onRowArrowUp($event)\"\n                class=\"adf-search-autocomplete-item\"\n                (click)=\"elementClicked(item)\"\n                (keyup.enter)=\"elementClicked(item)\">\n                <mat-icon mat-list-icon>\n                    <img [src]=\"getMimeTypeIcon(item)\" />\n                </mat-icon>\n                <h4 mat-line id=\"result_name_{{idx}}\"\n                    *ngIf=\"highlight; else elseBlock\"\n                    class=\"adf-search-fixed-text\"\n                    [innerHtml]=\"item.entry.name | highlight: searchTerm\">\n                    {{ item?.entry.name }}\n                </h4>\n                <ng-template #elseBlock>\n                    <h4 class=\"adf-search-fixed-text\" mat-line id=\"result_name_{{idx}}\" [innerHtml]=\"item.entry.name\"></h4>\n                </ng-template>\n                <p mat-line class=\"adf-search-fixed-text\"> {{item?.entry.createdByUser.displayName}} </p>\n            </mat-list-item>\n            <mat-list-item id=\"search_no_result\"\n                data-automation-id=\"search_no_result_found\"\n                *ngIf=\"data?.list?.entries.length === 0\">\n                <ng-content\n                    selector=\"adf-empty-search-result\"\n                    *ngIf=\"isNoSearchTemplatePresent() else defaultNoResult\">\n                </ng-content>\n                <ng-template #defaultNoResult>\n                    <p mat-line class=\"adf-search-fixed-text\">{{ 'SEARCH.RESULTS.NONE' | translate:{searchTerm: searchTerm} }}</p>\n                </ng-template>\n            </mat-list-item>\n        </mat-list>\n    </ng-template>\n</adf-search>\n",
                styles: [""],
                animations: [
                    animations.trigger('transitionMessages', [
                        animations.state('active', animations.style({ transform: 'translateX(0%)', 'margin-left': '13px' })),
                        animations.state('inactive', animations.style({ transform: 'translateX(81%)' })),
                        animations.state('no-animation', animations.style({ transform: 'translateX(0%)', width: '100%' })),
                        animations.transition('inactive => active', animations.animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')),
                        animations.transition('active => inactive', animations.animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                    ])
                ],
                encapsulation: core.ViewEncapsulation.None,
                host: { class: 'adf-search-control' }
            },] },
];
SearchControlComponent.ctorParameters = function () { return [
    { type: adfCore.AuthenticationService, },
    { type: adfCore.ThumbnailService, },
]; };
SearchControlComponent.propDecorators = {
    "expandable": [{ type: core.Input },],
    "highlight": [{ type: core.Input },],
    "inputType": [{ type: core.Input },],
    "autocomplete": [{ type: core.Input },],
    "liveSearchEnabled": [{ type: core.Input },],
    "liveSearchMaxResults": [{ type: core.Input },],
    "customQueryBody": [{ type: core.Input },],
    "submit": [{ type: core.Output },],
    "searchChange": [{ type: core.Output },],
    "optionClicked": [{ type: core.Output },],
    "searchAutocomplete": [{ type: core.ViewChild, args: ['search',] },],
    "searchInput": [{ type: core.ViewChild, args: ['searchInput',] },],
    "listResultElement": [{ type: core.ViewChildren, args: [material.MatListItem,] },],
    "emptySearchTemplate": [{ type: core.ContentChild, args: [EmptySearchResultComponent,] },],
};
var SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: forms.NG_VALUE_ACCESSOR,
    useExisting: core.forwardRef(function () { return SearchTriggerDirective; }),
    multi: true
};
var SearchTriggerDirective =               (function () {
    function SearchTriggerDirective(element, ngZone, changeDetectorRef, document) {
        this.element = element;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this._panelOpen = false;
        this.escapeEventStream = new Subject.Subject();
        this.onChange = function () { };
        this.onTouched = function () { };
    }
    SearchTriggerDirective.prototype.ngOnDestroy = function () {
        if (this.escapeEventStream) {
            this.escapeEventStream.unsubscribe();
            this.escapeEventStream = null;
        }
        if (this.closingActionsSubscription) {
            this.closingActionsSubscription.unsubscribe();
        }
    };
    Object.defineProperty(SearchTriggerDirective.prototype, "panelOpen", {
        get: function () {
            return this._panelOpen && this.searchPanel.showPanel;
        },
        enumerable: true,
        configurable: true
    });
    SearchTriggerDirective.prototype.openPanel = function () {
        this.searchPanel.isOpen = this._panelOpen = true;
        this.closingActionsSubscription = this.subscribeToClosingActions();
    };
    SearchTriggerDirective.prototype.closePanel = function () {
        if (this._panelOpen) {
            this.closingActionsSubscription.unsubscribe();
            this._panelOpen = false;
            this.searchPanel.resetResults();
            this.searchPanel.hidePanel();
            this.changeDetectorRef.detectChanges();
        }
    };
    Object.defineProperty(SearchTriggerDirective.prototype, "panelClosingActions", {
        get: function () {
            return merge$1.merge(this.escapeEventStream, this.outsideClickStream);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchTriggerDirective.prototype, "outsideClickStream", {
        get: function () {
            var _this = this;
            if (!this.document) {
                return Observable.Observable.of(null);
            }
            return merge$1.merge(fromEvent.fromEvent(this.document, 'click'), fromEvent.fromEvent(this.document, 'touchend')).filter(function (event) {
                var clickTarget = (event.target);
                return _this._panelOpen &&
                    clickTarget !== _this.element.nativeElement;
            });
        },
        enumerable: true,
        configurable: true
    });
    SearchTriggerDirective.prototype.writeValue = function (value) {
        var _this = this;
        Promise.resolve(null).then(function () { return _this.setTriggerValue(value); });
    };
    SearchTriggerDirective.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    SearchTriggerDirective.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    SearchTriggerDirective.prototype.handleKeydown = function (event) {
        var keyCode = event.keyCode;
        if (keyCode === keycodes.ESCAPE && this.panelOpen) {
            this.escapeEventStream.next();
            event.stopPropagation();
        }
        else if (keyCode === keycodes.ENTER) {
            this.escapeEventStream.next();
            event.preventDefault();
        }
    };
    SearchTriggerDirective.prototype.handleInput = function (event) {
        if (document.activeElement === event.target) {
            var inputValue = ((event.target)).value;
            this.onChange(inputValue);
            if (inputValue) {
                this.searchPanel.keyPressedStream.next(inputValue);
                this.openPanel();
            }
            else {
                this.searchPanel.resetResults();
                this.closePanel();
            }
        }
    };
    SearchTriggerDirective.prototype.isPanelOptionClicked = function (event) {
        var isPanelOption = false;
        if (event) {
            var clickTarget = (event.target);
            isPanelOption = !this.isNoResultOption(event) &&
                !!this.searchPanel.panel &&
                !!this.searchPanel.panel.nativeElement.contains(clickTarget);
        }
        return isPanelOption;
    };
    SearchTriggerDirective.prototype.isNoResultOption = function (event) {
        return this.searchPanel.results.list ? this.searchPanel.results.list.entries.length === 0 : true;
    };
    SearchTriggerDirective.prototype.subscribeToClosingActions = function () {
        var _this = this;
        var firstStable = this.ngZone.onStable.asObservable();
        var optionChanges = this.searchPanel.keyPressedStream.asObservable();
        return merge$1.merge(firstStable, optionChanges)
            .switchMap(function () {
            _this.searchPanel.setVisibility();
            return _this.panelClosingActions;
        })
            .subscribe(function (event) { return _this.setValueAndClose(event); });
    };
    SearchTriggerDirective.prototype.setTriggerValue = function (value) {
        var toDisplay = this.searchPanel && this.searchPanel.displayWith ?
            this.searchPanel.displayWith(value) : value;
        var inputValue = toDisplay != null ? toDisplay : '';
        this.element.nativeElement.value = inputValue;
    };
    SearchTriggerDirective.prototype.setValueAndClose = function (event) {
        if (this.isPanelOptionClicked(event)) {
            this.setTriggerValue(event.target.textContent.trim());
            this.onChange(event.target.textContent.trim());
            this.element.nativeElement.focus();
        }
        this.closePanel();
    };
    return SearchTriggerDirective;
}());
SearchTriggerDirective.decorators = [
    { type: core.Directive, args: [{
                selector: "input[searchAutocomplete], textarea[searchAutocomplete]",
                host: {
                    'role': 'combobox',
                    'autocomplete': 'off',
                    'aria-autocomplete': 'list',
                    '[attr.aria-expanded]': 'panelOpen.toString()',
                    '[attr.aria-owns]': 'autocomplete?.id',
                    '(blur)': 'onTouched()',
                    '(input)': 'handleInput($event)',
                    '(keydown)': 'handleKeydown($event)'
                },
                providers: [SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR]
            },] },
];
SearchTriggerDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.NgZone, },
    { type: core.ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
]; };
SearchTriggerDirective.propDecorators = {
    "searchPanel": [{ type: core.Input, args: ['searchAutocomplete',] },],
};
var SearchFilterComponent =               (function () {
    function SearchFilterComponent(queryBuilder, search) {
        var _this = this;
        this.queryBuilder = queryBuilder;
        this.search = search;
        this.selectedFacetQueries = [];
        this.selectedBuckets = [];
        this.responseFacetQueries = [];
        this.responseFacetFields = [];
        this.queryBuilder.updated.subscribe(function (query) {
            _this.queryBuilder.execute();
        });
    }
    SearchFilterComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (this.queryBuilder) {
            this.queryBuilder.executed.subscribe(function (data) {
                _this.onDataLoaded(data);
                _this.search.dataLoaded.next(data);
            });
        }
    };
    SearchFilterComponent.prototype.onCategoryExpanded = function (category) {
        category.expanded = true;
    };
    SearchFilterComponent.prototype.onCategoryCollapsed = function (category) {
        category.expanded = false;
    };
    SearchFilterComponent.prototype.onFacetFieldExpanded = function (field) {
        field.$expanded = true;
    };
    SearchFilterComponent.prototype.onFacetFieldCollapsed = function (field) {
        field.$expanded = false;
    };
    SearchFilterComponent.prototype.onFacetQueryToggle = function (event, query) {
        var facetQuery = this.queryBuilder.getFacetQuery(query.label);
        if (event.checked) {
            query.$checked = true;
            this.selectedFacetQueries.push(facetQuery.label);
            if (facetQuery) {
                this.queryBuilder.addFilterQuery(facetQuery.query);
            }
        }
        else {
            query.$checked = false;
            this.selectedFacetQueries = this.selectedFacetQueries.filter(function (q) { return q !== query.label; });
            if (facetQuery) {
                this.queryBuilder.removeFilterQuery(facetQuery.query);
            }
        }
        this.queryBuilder.update();
    };
    SearchFilterComponent.prototype.onFacetToggle = function (event, field, bucket) {
        if (event.checked) {
            bucket.$checked = true;
            this.selectedBuckets.push(Object.assign({}, bucket));
            this.queryBuilder.addFilterQuery(bucket.filterQuery);
        }
        else {
            bucket.$checked = false;
            var idx = this.selectedBuckets.findIndex(function (b) { return b.$field === bucket.$field && b.label === bucket.label; });
            if (idx >= 0) {
                this.selectedBuckets.splice(idx, 1);
            }
            this.queryBuilder.removeFilterQuery(bucket.filterQuery);
        }
        this.queryBuilder.update();
    };
    SearchFilterComponent.prototype.unselectFacetQuery = function (label) {
        var facetQuery = this.queryBuilder.getFacetQuery(label);
        this.selectedFacetQueries = this.selectedFacetQueries.filter(function (q) { return q !== label; });
        this.queryBuilder.removeFilterQuery(facetQuery.query);
        this.queryBuilder.update();
    };
    SearchFilterComponent.prototype.unselectFacetBucket = function (bucket) {
        if (bucket) {
            var idx = this.selectedBuckets.findIndex(function (b) { return b.$field === bucket.$field && b.label === bucket.label; });
            if (idx >= 0) {
                this.selectedBuckets.splice(idx, 1);
            }
            this.queryBuilder.removeFilterQuery(bucket.filterQuery);
            this.queryBuilder.update();
        }
    };
    SearchFilterComponent.prototype.onDataLoaded = function (data) {
        var _this = this;
        var context = data.list.context;
        if (context) {
            this.responseFacetQueries = (context.facetQueries || []).map(function (q) {
                q.$checked = _this.selectedFacetQueries.includes(q.label);
                return q;
            });
            var expandedFields_1 = this.responseFacetFields.filter(function (f) { return f.$expanded; }).map(function (f) { return f.label; });
            this.responseFacetFields = (context.facetsFields || []).map(function (field) {
                field.$expanded = expandedFields_1.includes(field.label);
                (field.buckets || []).forEach(function (bucket) {
                    bucket.$field = field.label;
                    bucket.$checked = false;
                    var previousBucket = _this.selectedBuckets.find(function (b) { return b.$field === bucket.$field && b.label === bucket.label; });
                    if (previousBucket) {
                        bucket.$checked = true;
                    }
                });
                return field;
            });
        }
        else {
            this.responseFacetQueries = [];
            this.responseFacetFields = [];
        }
    };
    return SearchFilterComponent;
}());
SearchFilterComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-filter',
                template: "<mat-accordion multi=\"true\" displayMode=\"flat\">\n\n    <mat-expansion-panel\n        *ngFor=\"let category of queryBuilder.categories\"\n        [expanded]=\"category.expanded\"\n        (opened)=\"onCategoryExpanded(category)\"\n        (closed)=\"onCategoryCollapsed(category)\">\n        <mat-expansion-panel-header>\n            <mat-panel-title>\n                {{ category.name | translate }}\n            </mat-panel-title>\n        </mat-expansion-panel-header>\n        <adf-search-widget-container\n            [id]=\"category.id\"\n            [selector]=\"category.component.selector\"\n            [settings]=\"category.component.settings\">\n        </adf-search-widget-container>\n    </mat-expansion-panel>\n\n    <mat-expansion-panel>\n        <mat-expansion-panel-header>\n            <mat-panel-title>Facet Queries</mat-panel-title>\n        </mat-expansion-panel-header>\n        <div class=\"checklist\">\n            <ng-container *ngFor=\"let query of responseFacetQueries\">\n                <mat-checkbox\n                    *ngIf=\"query.count > 0\"\n                    [checked]=\"query.$checked\"\n                    (change)=\"onFacetQueryToggle($event, query)\">\n                    {{ query.label }} ({{ query.count }})\n                </mat-checkbox>\n            </ng-container>\n        </div>\n    </mat-expansion-panel>\n\n    <mat-expansion-panel\n        *ngFor=\"let field of responseFacetFields\"\n        [expanded]=\"field.$expanded\"\n        (opened)=\"onFacetFieldExpanded(field)\"\n        (closed)=\"onFacetFieldCollapsed(field)\">\n        <mat-expansion-panel-header>\n            <mat-panel-title>{{ field.label }}</mat-panel-title>\n        </mat-expansion-panel-header>\n        <div class=\"checklist\">\n            <mat-checkbox\n                *ngFor=\"let bucket of field.buckets\"\n                [checked]=\"bucket.$checked\"\n                (change)=\"onFacetToggle($event, field, bucket)\">\n                {{ bucket.display || bucket.label }} ({{ bucket.count }})\n            </mat-checkbox>\n        </div>\n    </mat-expansion-panel>\n\n</mat-accordion>\n",
                styles: [".checklist{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.checklist .mat-checkbox{margin:5px}"],
                encapsulation: core.ViewEncapsulation.None,
                host: { class: 'adf-search-filter' }
            },] },
];
SearchFilterComponent.ctorParameters = function () { return [
    { type: SearchQueryBuilderService, },
    { type: adfCore.SearchService, },
]; };
var SearchChipListComponent =               (function () {
    function SearchChipListComponent() {
    }
    return SearchChipListComponent;
}());
SearchChipListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-chip-list',
                template: "<mat-chip-list>\n    <ng-container *ngIf=\"searchFilter && searchFilter.selectedFacetQueries\">\n        <mat-chip\n            *ngFor=\"let label of searchFilter.selectedFacetQueries\"\n            [removable]=\"true\"\n            (remove)=\"searchFilter.unselectFacetQuery(label)\">\n            {{ label }}\n            <mat-icon matChipRemove>cancel</mat-icon>\n        </mat-chip>\n    </ng-container>\n    <ng-container *ngIf=\"searchFilter && searchFilter.selectedBuckets\">\n        <mat-chip\n            *ngFor=\"let bucket of searchFilter.selectedBuckets\"\n            [removable]=\"true\"\n            (remove)=\"searchFilter.unselectFacetBucket(bucket)\">\n            {{ bucket.display || bucket.label }}\n            <mat-icon matChipRemove>cancel</mat-icon>\n        </mat-chip>\n    </ng-container>\n</mat-chip-list>\n",
                encapsulation: core.ViewEncapsulation.None,
                host: { class: 'adf-search-chip-list' }
            },] },
];
SearchChipListComponent.ctorParameters = function () { return []; };
SearchChipListComponent.propDecorators = {
    "searchFilter": [{ type: core.Input },],
};
var SearchTextComponent =               (function () {
    function SearchTextComponent() {
        this.value = '';
    }
    SearchTextComponent.prototype.ngOnInit = function () {
        if (this.context && this.settings) {
            var pattern = new RegExp(this.settings["pattern"], 'g');
            var match = pattern.exec(this.context.queryFragments[this.id] || '');
            if (match && match.length > 1) {
                this.value = match[1];
            }
        }
    };
    SearchTextComponent.prototype.onChangedHandler = function (event) {
        this.value = event.target.value;
        if (this.value) {
            this.context.queryFragments[this.id] = this.settings.field + ":'" + this.value + "'";
            this.context.update();
        }
    };
    return SearchTextComponent;
}());
SearchTextComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-text',
                template: "<mat-form-field>\n    <input\n        matInput\n        [placeholder]=\"settings?.placeholder\"\n        [value]=\"value\"\n        (change)=\"onChangedHandler($event)\">\n</mat-form-field>\n",
                encapsulation: core.ViewEncapsulation.None,
                host: { class: 'adf-search-text' }
            },] },
];
SearchTextComponent.ctorParameters = function () { return []; };
SearchTextComponent.propDecorators = {
    "value": [{ type: core.Input },],
};
var SearchRadioComponent =               (function () {
    function SearchRadioComponent() {
    }
    SearchRadioComponent.prototype.ngOnInit = function () {
        this.setValue(this.getSelectedValue());
    };
    SearchRadioComponent.prototype.getSelectedValue = function () {
        var options = this.settings['options'] || [];
        if (options && options.length > 0) {
            var selected = options.find(function (opt) { return opt.default; });
            if (!selected) {
                selected = options[0];
            }
            return selected.value;
        }
        return null;
    };
    SearchRadioComponent.prototype.setValue = function (newValue) {
        this.value = newValue;
        this.context.queryFragments[this.id] = newValue;
        this.context.update();
    };
    SearchRadioComponent.prototype.changeHandler = function (event) {
        this.setValue(event.value);
    };
    return SearchRadioComponent;
}());
SearchRadioComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-radio',
                template: "<mat-radio-group [(ngModel)]=\"value\" (change)=\"changeHandler($event)\">\n    <mat-radio-button\n        *ngFor=\"let option of settings.options\" [value]=\"option.value\">\n        {{ option.name }}\n    </mat-radio-button>\n</mat-radio-group>\n",
                styles: [".adf-search-radio .mat-radio-group{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.adf-search-radio .mat-radio-button{margin:5px}"],
                encapsulation: core.ViewEncapsulation.None,
                host: { class: 'adf-search-radio' }
            },] },
];
SearchRadioComponent.ctorParameters = function () { return []; };
SearchRadioComponent.propDecorators = {
    "value": [{ type: core.Input },],
};
var SearchFieldsComponent =               (function () {
    function SearchFieldsComponent() {
    }
    SearchFieldsComponent.prototype.ngOnInit = function () {
        var defaultOptions = (this.settings["options"] || [])
            .filter(function (opt) { return opt.default; })
            .map(function (opt) {
            opt.checked = true;
            return opt;
        });
        if (defaultOptions.length > 0) {
            this.flush(defaultOptions);
        }
    };
    SearchFieldsComponent.prototype.changeHandler = function (event, option) {
        option.checked = event.checked;
        this.flush(this.settings["options"]);
    };
    SearchFieldsComponent.prototype.flush = function (opts) {
        if (opts === void 0) { opts = []; }
        var checkedValues = opts
            .filter(function (v) { return v.checked; })
            .map(function (v) { return v.fields; })
            .reduce(function (prev, curr) {
            return prev.concat(curr);
        }, []);
        this.context.fields[this.id] = checkedValues;
        this.context.update();
    };
    return SearchFieldsComponent;
}());
SearchFieldsComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-fields',
                template: "<mat-checkbox\n    *ngFor=\"let option of settings.options\"\n    [checked]=\"option.checked\"\n    (change)=\"changeHandler($event, option)\">\n    {{ option.name }}\n</mat-checkbox>\n",
                styles: [".adf-search-fields{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.adf-search-fields .mat-checkbox{margin:5px}"],
                encapsulation: core.ViewEncapsulation.None,
                host: { class: 'adf-search-fields' }
            },] },
];
SearchFieldsComponent.ctorParameters = function () { return []; };
SearchFieldsComponent.propDecorators = {
    "value": [{ type: core.Input },],
};
var SearchScopeLocationsComponent =               (function () {
    function SearchScopeLocationsComponent() {
    }
    SearchScopeLocationsComponent.prototype.ngOnInit = function () {
        var defaultSelection = (this.settings["options"] || []).find(function (opt) { return opt.default; });
        if (defaultSelection) {
            this.flush(defaultSelection.value);
        }
    };
    SearchScopeLocationsComponent.prototype.changeHandler = function (event) {
        this.flush(event.value);
    };
    SearchScopeLocationsComponent.prototype.flush = function (value) {
        this.value = value;
        this.context.scope.locations = value;
        this.context.update();
    };
    return SearchScopeLocationsComponent;
}());
SearchScopeLocationsComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-scope-locations',
                template: "<mat-form-field>\n    <mat-select\n        [(value)]=\"value\"\n        (selectionChange)=\"changeHandler($event)\">\n        <mat-option\n            *ngFor=\"let option of settings.options\"\n            [value]=\"option.value\">\n            {{option.name}}\n        </mat-option>\n    </mat-select>\n</mat-form-field>\n",
                encapsulation: core.ViewEncapsulation.None,
                host: { class: 'adf-search-scope-locations' }
            },] },
];
SearchScopeLocationsComponent.ctorParameters = function () { return []; };
SearchScopeLocationsComponent.propDecorators = {
    "value": [{ type: core.Input },],
};
var SearchWidgetsModule =               (function () {
    function SearchWidgetsModule() {
    }
    return SearchWidgetsModule;
}());
SearchWidgetsModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                    forms.ReactiveFormsModule,
                    material.MatButtonModule,
                    material.MatInputModule,
                    material.MatRadioModule,
                    material.MatCheckboxModule,
                    material.MatSelectModule
                ],
                declarations: [
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchFieldsComponent,
                    SearchScopeLocationsComponent
                ],
                exports: [
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchFieldsComponent,
                    SearchScopeLocationsComponent
                ],
                entryComponents: [
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchFieldsComponent,
                    SearchScopeLocationsComponent
                ]
            },] },
];
SearchWidgetsModule.ctorParameters = function () { return []; };
var SearchWidgetContainerComponent =               (function () {
    function SearchWidgetContainerComponent(compiler, queryBuilder) {
        this.queryBuilder = queryBuilder;
        this.module = compiler.compileModuleAndAllComponentsSync(SearchWidgetsModule);
    }
    SearchWidgetContainerComponent.prototype.ngOnInit = function () {
        var _this = this;
        var factory = this.module.componentFactories.find(function (f) { return f.selector === _this.selector; });
        if (factory) {
            this.content.clear();
            this.componentRef = this.content.createComponent(factory, 0);
            this.setupWidget(this.componentRef);
        }
    };
    SearchWidgetContainerComponent.prototype.setupWidget = function (ref) {
        if (ref && ref.instance) {
            ref.instance.id = this.id;
            ref.instance.settings = Object.assign({}, this.settings);
            ref.instance.context = this.queryBuilder;
        }
    };
    SearchWidgetContainerComponent.prototype.ngOnDestroy = function () {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    };
    return SearchWidgetContainerComponent;
}());
SearchWidgetContainerComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-search-widget-container',
                template: '<div #content></div>'
            },] },
];
SearchWidgetContainerComponent.ctorParameters = function () { return [
    { type: core.Compiler, },
    { type: SearchQueryBuilderService, },
]; };
SearchWidgetContainerComponent.propDecorators = {
    "content": [{ type: core.ViewChild, args: ['content', { read: core.ViewContainerRef },] },],
    "id": [{ type: core.Input },],
    "selector": [{ type: core.Input },],
    "settings": [{ type: core.Input },],
    "config": [{ type: core.Input },],
};
var ALFRESCO_SEARCH_DIRECTIVES = [
    SearchComponent,
    SearchControlComponent,
    SearchTriggerDirective,
    EmptySearchResultComponent,
    SearchFilterComponent,
    SearchChipListComponent
];
var SearchModule =               (function () {
    function SearchModule() {
    }
    return SearchModule;
}());
SearchModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                    forms.ReactiveFormsModule,
                    MaterialModule,
                    adfCore.PipeModule,
                    core$1.TranslateModule
                ],
                declarations: __spread(ALFRESCO_SEARCH_DIRECTIVES, [
                    SearchWidgetContainerComponent
                ]),
                exports: __spread(ALFRESCO_SEARCH_DIRECTIVES, [
                    SearchWidgetContainerComponent
                ]),
                entryComponents: [
                    SearchWidgetContainerComponent
                ]
            },] },
];
SearchModule.ctorParameters = function () { return []; };
var Relations = {
    Members: 'members',
    Containers: 'containers',
};
var DropdownSitesComponent =               (function () {
    function DropdownSitesComponent(sitesService, logService) {
        this.sitesService = sitesService;
        this.logService = logService;
        this.hideMyFiles = false;
        this.siteList = null;
        this.value = null;
        this.placeholder = 'DROPDOWN.PLACEHOLDER_LABEL';
        this.change = new core.EventEmitter();
        this.selected = null;
        this.MY_FILES_VALUE = '-my-';
    }
    DropdownSitesComponent.prototype.ngOnInit = function () {
        if (!this.siteList) {
            this.setDefaultSiteList();
        }
    };
    DropdownSitesComponent.prototype.selectedSite = function (event) {
        this.change.emit(event.value);
    };
    DropdownSitesComponent.prototype.setDefaultSiteList = function () {
        var _this = this;
        var extendedOptions = null;
        if (this.relations) {
            extendedOptions = { relations: [this.relations] };
        }
        this.sitesService.getSites(extendedOptions).subscribe(function (result) {
            _this.siteList = _this.relations === Relations.Members ? _this.filteredResultsByMember(result) : result;
            if (!_this.hideMyFiles) {
                var myItem = { entry: { id: '-my-', guid: '-my-', title: 'DROPDOWN.MY_FILES_OPTION' } };
                _this.siteList.list.entries.unshift(myItem);
                if (!_this.value) {
                    _this.value = '-my-';
                }
            }
            _this.selected = _this.siteList.list.entries.find(function (site) { return site.entry.id === _this.value; });
        }, function (error) {
            _this.logService.error(error);
        });
    };
    DropdownSitesComponent.prototype.filteredResultsByMember = function (sites) {
        var _this = this;
        var loggedUserName = this.sitesService.getEcmCurrentLoggedUserName();
        sites.list.entries = sites.list.entries.filter(function (site) { return _this.isCurrentUserMember(site, loggedUserName); });
        return sites;
    };
    DropdownSitesComponent.prototype.isCurrentUserMember = function (site, loggedUserName) {
        return site.entry.visibility === 'PUBLIC' ||
            !!site.relations.members.list.entries.find(function (member) {
                return member.entry.id.toLowerCase() === loggedUserName.toLowerCase();
            });
    };
    return DropdownSitesComponent;
}());
DropdownSitesComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-sites-dropdown',
                styles: [".adf-sites-dropdown.full-width .mat-input-container{width:100%}"],
                template: "<div id=\"site-dropdown-container\" class=\"adf-site-dropdown-container\">\n    <mat-form-field>\n        <mat-select\n            data-automation-id=\"site-my-files-option\"\n            class=\"adf-site-dropdown-list-element\"\n            id=\"site-dropdown\"\n            placeholder=\"{{placeholder | translate}}\"\n            floatPlaceholder=\"never\"\n            data-automation-id=\"site-my-files-select\"\n            [(value)]=\"selected\"\n            (selectionChange)=\"selectedSite($event)\">\n            <mat-option *ngFor=\"let site of siteList?.list.entries\" [value]=\"site\">\n                {{ site.entry.title | translate}}\n            </mat-option>\n        </mat-select>\n    </mat-form-field>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                host: { 'class': 'adf-sites-dropdown' }
            },] },
];
DropdownSitesComponent.ctorParameters = function () { return [
    { type: adfCore.SitesService, },
    { type: adfCore.LogService, },
]; };
DropdownSitesComponent.propDecorators = {
    "hideMyFiles": [{ type: core.Input },],
    "siteList": [{ type: core.Input },],
    "value": [{ type: core.Input },],
    "placeholder": [{ type: core.Input },],
    "relations": [{ type: core.Input },],
    "change": [{ type: core.Output },],
};
var SitesDropdownModule =               (function () {
    function SitesDropdownModule() {
    }
    return SitesDropdownModule;
}());
SitesDropdownModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    forms.FormsModule,
                    forms.ReactiveFormsModule
                ],
                exports: [
                    DropdownSitesComponent
                ],
                declarations: [
                    DropdownSitesComponent
                ]
            },] },
];
SitesDropdownModule.ctorParameters = function () { return []; };
var BreadcrumbComponent =               (function () {
    function BreadcrumbComponent() {
        this.folderNode = null;
        this.root = null;
        this.rootId = null;
        this.route = [];
        this.navigate = new core.EventEmitter();
    }
    Object.defineProperty(BreadcrumbComponent.prototype, "hasRoot", {
        get: function () {
            return !!this.root;
        },
        enumerable: true,
        configurable: true
    });
    BreadcrumbComponent.prototype.ngOnInit = function () {
        this.transform = this.transform ? this.transform : null;
    };
    BreadcrumbComponent.prototype.ngOnChanges = function (changes) {
        if (changes["folderNode"]) {
            var node = null;
            node = this.transform ? this.transform(changes["folderNode"].currentValue) : changes["folderNode"].currentValue;
            this.route = this.parseRoute(node);
        }
        if (changes["transform"]) {
            var node = this.transform ? this.transform(this.folderNode) : this.folderNode;
            this.route = this.parseRoute(node);
        }
    };
    BreadcrumbComponent.prototype.parseRoute = function (node) {
        if (node && node.path) {
            var route = ((node.path.elements || []).slice());
            route.push(({
                id: node.id,
                name: node.name
            }));
            var rootPos = this.getElementPosition(route, this.rootId);
            if (rootPos > 0) {
                route.splice(0, rootPos);
            }
            if (rootPos === -1 && this.rootId) {
                route[0].id = this.rootId;
            }
            if (this.root) {
                route[0].name = this.root;
            }
            return route;
        }
        return [];
    };
    BreadcrumbComponent.prototype.getElementPosition = function (route, nodeId) {
        var result = -1;
        if (route && route.length > 0 && nodeId) {
            result = route.findIndex(function (el) { return el.id === nodeId; });
        }
        return result;
    };
    BreadcrumbComponent.prototype.onRoutePathClick = function (route, event) {
        if (event) {
            event.preventDefault();
        }
        if (route) {
            this.navigate.emit(route);
            if (this.target) {
                this.target.navigateTo(route.id);
            }
        }
    };
    return BreadcrumbComponent;
}());
BreadcrumbComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-breadcrumb',
                template: "<div *ngIf=\"folderNode\" data-automation-id=\"breadcrumb\" class=\"adf-breadcrumb-container\">\n    <li *ngFor=\"let item of route; let last = last\"\n        [class.active]=\"last\"\n        [ngSwitch]=\"last\"\n        title=\"{{ item.name | translate }}\"\n        class=\"adf-breadcrumb-item\">\n\n        <a *ngSwitchDefault href=\"#\" [attr.data-automation-id]=\"'breadcrumb_' + item.name\"\n           class=\"adf-breadcrumb-item-anchor\"\n           (click)=\"onRoutePathClick(item, $event)\">\n            {{ item.name | translate }}\n        </a>\n\n        <div *ngSwitchCase=\"true\" class=\"adf-breadcrumb-item-current\">\n            {{ item.name | translate }}\n        </div>\n\n        <mat-icon class=\"adf-breadcrumb-item-chevron\" *ngIf=\"!last\">\n            chevron_right\n        </mat-icon>\n    </li>\n</div>\n<div *ngIf=\"!folderNode && hasRoot\">\n    <li class=\"adf-breadcrumb-item\">\n        <div class=\"adf-breadcrumb-item-current\">\n            {{ root | translate }}\n        </div>\n    </li>\n</div>\n",
                styles: [""],
                encapsulation: core.ViewEncapsulation.None,
                host: {
                    'class': 'adf-breadcrumb'
                }
            },] },
];
BreadcrumbComponent.ctorParameters = function () { return []; };
BreadcrumbComponent.propDecorators = {
    "folderNode": [{ type: core.Input },],
    "root": [{ type: core.Input },],
    "rootId": [{ type: core.Input },],
    "target": [{ type: core.Input },],
    "transform": [{ type: core.Input },],
    "navigate": [{ type: core.Output },],
};
var DropdownBreadcrumbComponent =               (function (_super) {
    __extends(DropdownBreadcrumbComponent, _super);
    function DropdownBreadcrumbComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DropdownBreadcrumbComponent.prototype.ngOnChanges = function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        this.recalculateNodes();
    };
    DropdownBreadcrumbComponent.prototype.recalculateNodes = function () {
        this.currentNode = this.route[this.route.length - 1];
        this.previousNodes = this.route.slice(0, this.route.length - 1).reverse();
    };
    DropdownBreadcrumbComponent.prototype.open = function () {
        if (this.selectbox) {
            this.selectbox.open();
        }
    };
    DropdownBreadcrumbComponent.prototype.hasPreviousNodes = function () {
        return this.previousNodes.length > 0;
    };
    return DropdownBreadcrumbComponent;
}(BreadcrumbComponent));
DropdownBreadcrumbComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-dropdown-breadcrumb',
                template: "<ng-container *ngIf=\"route.length > 0\">\n\n    <button\n        tabindex=\"0\"\n        class=\"adf-dropdown-breadcumb-trigger\"\n        (click)=\"open()\"\n        data-automation-id=\"dropdown-breadcrumb-trigger\">\n        <mat-icon [class.isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n    </button>\n    <mat-icon class=\"adf-dropdown-breadcrumb-item-chevron\">chevron_right</mat-icon>\n\n    <mat-select\n        #select\n        *ngIf=\"hasPreviousNodes()\"\n        class=\"adf-dropdown-breadcrumb-path\"\n        tabindex=\"0\"\n        data-automation-id=\"dropdown-breadcrumb-path\" >\n\n        <mat-option\n            *ngFor=\"let node of previousNodes;\"\n            (click)=\"onRoutePathClick(node, $event)\"\n            class=\"adf-dropdown-breadcrumb-path-option\"\n            tabindex=\"0\"\n            data-automation-class=\"dropdown-breadcrumb-path-option\">\n            {{ node.name }}\n        </mat-option>\n    </mat-select>\n\n    <span\n        class=\"adf-current-folder\"\n        [class.isRoot]=\"!hasPreviousNodes()\"\n        data-automation-id=\"current-folder\">{{ currentNode.name }}</span>\n</ng-container>\n",
                styles: [""],
                encapsulation: core.ViewEncapsulation.None,
                host: {
                    'class': 'adf-dropdown-breadcrumb'
                }
            },] },
];
DropdownBreadcrumbComponent.ctorParameters = function () { return []; };
DropdownBreadcrumbComponent.propDecorators = {
    "selectbox": [{ type: core.ViewChild, args: ['select',] },],
};
var BreadcrumbModule =               (function () {
    function BreadcrumbModule() {
    }
    return BreadcrumbModule;
}());
BreadcrumbModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule
                ],
                exports: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ],
                declarations: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ]
            },] },
];
BreadcrumbModule.ctorParameters = function () { return []; };
var ConfirmDialogComponent =               (function () {
    function ConfirmDialogComponent(data) {
        data = data || {};
        this.title = data.title || 'ADF_CONFIRM_DIALOG.CONFIRM';
        this.message = data.message || 'ADF_CONFIRM_DIALOG.MESSAGE';
        this.yesLabel = data.yesLabel || 'ADF_CONFIRM_DIALOG.YES_LABEL';
        this.noLabel = data.noLabel || 'ADF_CONFIRM_DIALOG.NO_LABEL';
    }
    return ConfirmDialogComponent;
}());
ConfirmDialogComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-confirm-dialog',
                template: "\n        <h1 mat-dialog-title>{{ title | translate }}</h1>\n        <mat-dialog-content>\n            <p>{{ message | translate }}</p>\n        </mat-dialog-content>\n        <mat-dialog-actions>\n            <span class=\"spacer\"></span>\n            <button mat-button [mat-dialog-close]=\"true\">{{ yesLabel | translate }}</button>\n            <button mat-button color=\"primary\" [mat-dialog-close]=\"false\" cdkFocusInitial>{{ noLabel | translate }}</button>\n        </mat-dialog-actions>\n    ",
                styles: ["\n        .spacer { flex: 1 1 auto; }\n\n        .adf-confirm-dialog .mat-dialog-actions .mat-button-wrapper {\n            text-transform: uppercase;\n        }\n    "],
                host: { 'class': 'adf-confirm-dialog' },
                encapsulation: core.ViewEncapsulation.None
            },] },
];
ConfirmDialogComponent.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] },] },
]; };
var VersionListComponent =               (function () {
    function VersionListComponent(alfrescoApi, contentService, dialog, el) {
        this.alfrescoApi = alfrescoApi;
        this.contentService = contentService;
        this.dialog = dialog;
        this.el = el;
        this.versions = [];
        this.isLoading = true;
        this.showComments = true;
        this.allowDownload = true;
        this.versionsApi = this.alfrescoApi.versionsApi;
    }
    VersionListComponent.prototype.ngOnChanges = function () {
        this.loadVersionHistory();
    };
    VersionListComponent.prototype.canUpdate = function () {
        return this.contentService.hasPermission(this.node, 'update');
    };
    VersionListComponent.prototype.restore = function (versionId) {
        var _this = this;
        if (this.canUpdate()) {
            this.versionsApi
                .revertVersion(this.node.id, versionId, { majorVersion: true, comment: '' })
                .then(function () { return _this.onVersionRestored(); });
        }
    };
    VersionListComponent.prototype.loadVersionHistory = function () {
        var _this = this;
        this.isLoading = true;
        this.versionsApi.listVersionHistory(this.node.id).then(function (data) {
            _this.versions = data.list.entries;
            _this.isLoading = false;
        });
    };
    VersionListComponent.prototype.downloadVersion = function (versionId) {
        if (this.allowDownload) {
            var versionDownloadUrl = this.getVersionContentUrl(this.node.id, versionId, true);
            this.downloadContent(versionDownloadUrl);
        }
    };
    VersionListComponent.prototype.deleteVersion = function (versionId) {
        var _this = this;
        if (this.canUpdate()) {
            var dialogRef = this.dialog.open(ConfirmDialogComponent, {
                data: {
                    title: 'ADF_VERSION_LIST.CONFIRM_DELETE.TITLE',
                    message: 'ADF_VERSION_LIST.CONFIRM_DELETE.MESSAGE',
                    yesLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.YES_LABEL',
                    noLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.NO_LABEL'
                },
                minWidth: '250px'
            });
            dialogRef.afterClosed().subscribe(function (result) {
                if (result === true) {
                    _this.alfrescoApi.versionsApi
                        .deleteVersion(_this.node.id, versionId)
                        .then(function () { return _this.onVersionDeleted(); });
                }
            });
        }
    };
    VersionListComponent.prototype.onVersionDeleted = function () {
        this.loadVersionHistory();
        var event = new CustomEvent('version-deleted', { bubbles: true });
        this.el.nativeElement.dispatchEvent(event);
    };
    VersionListComponent.prototype.onVersionRestored = function () {
        this.loadVersionHistory();
        var event = new CustomEvent('version-restored', { bubbles: true });
        this.el.nativeElement.dispatchEvent(event);
    };
    VersionListComponent.prototype.getVersionContentUrl = function (nodeId, versionId, attachment) {
        var nodeDownloadUrl = this.alfrescoApi.contentApi.getContentUrl(nodeId, attachment);
        return nodeDownloadUrl.replace('/content', '/versions/' + versionId + '/content');
    };
    VersionListComponent.prototype.downloadContent = function (url) {
        if (url) {
            var link = document.createElement('a');
            link.style.display = 'none';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };
    return VersionListComponent;
}());
VersionListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-version-list',
                template: "<mat-list class=\"adf-version-list\" *ngIf=\"!isLoading; else loading_template\">\n    <mat-list-item *ngFor=\"let version of versions\">\n        <mat-icon mat-list-icon>insert_drive_file</mat-icon>\n        <h4 mat-line class=\"adf-version-list-item-name\">{{version.entry.name}}</h4>\n        <p mat-line>\n            <span class=\"adf-version-list-item-version\">{{version.entry.id}}</span> -\n            <span class=\"adf-version-list-item-date\">{{version.entry.modifiedAt | date}}</span>\n        </p>\n        <p mat-line class=\"adf-version-list-item-comment\" *ngIf=\"showComments\">{{version.entry.versionComment}}</p>\n\n        <mat-menu #versionMenu=\"matMenu\" yPosition=\"below\" xPosition=\"before\">\n            <button *ngIf=\"canUpdate()\"\n                mat-menu-item\n                (click)=\"restore(version.entry.id)\">\n                {{ 'ADF_VERSION_LIST.ACTIONS.RESTORE' | translate }}\n            </button>\n            <button *ngIf=\"allowDownload\"\n                mat-menu-item\n                (click)=\"downloadVersion(version.entry.id)\">\n                {{ 'ADF_VERSION_LIST.ACTIONS.DOWNLOAD' | translate }}\n            </button>\n            <button *ngIf=\"canUpdate()\"\n                (click)=\"deleteVersion(version.entry.id)\"\n                mat-menu-item>\n                {{ 'ADF_VERSION_LIST.ACTIONS.DELETE' | translate }}\n            </button>\n        </mat-menu>\n\n        <button mat-icon-button [matMenuTriggerFor]=\"versionMenu\">\n            <mat-icon>more_vert</mat-icon>\n        </button>\n    </mat-list-item>\n</mat-list>\n\n<ng-template #loading_template>\n    <mat-progress-bar data-automation-id=\"version-history-loading-bar\" mode=\"indeterminate\" color=\"accent\"></mat-progress-bar>\n</ng-template>\n",
                styles: [".adf-version-list .mat-list-item{border-bottom:1px solid #d8d8d8}.adf-version-list-item-version{font-weight:700}.adf-version-list-item-date{opacity:.6}.adf-version-list-item-comment{opacity:.5}"],
                encapsulation: core.ViewEncapsulation.None,
                host: {
                    'class': 'adf-version-list'
                }
            },] },
];
VersionListComponent.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
    { type: adfCore.ContentService, },
    { type: material.MatDialog, },
    { type: core.ElementRef, },
]; };
VersionListComponent.propDecorators = {
    "id": [{ type: core.Input },],
    "node": [{ type: core.Input },],
    "showComments": [{ type: core.Input },],
    "allowDownload": [{ type: core.Input },],
};
var VersionManagerComponent =               (function () {
    function VersionManagerComponent(config, contentService) {
        this.contentService = contentService;
        this.showComments = true;
        this.allowDownload = true;
        this.uploadSuccess = new core.EventEmitter();
        this.uploadError = new core.EventEmitter();
        this.showComments = config.get('adf-version-manager.allowComments', true);
        this.allowDownload = config.get('adf-version-manager.allowDownload', true);
    }
    VersionManagerComponent.prototype.onUploadSuccess = function (event) {
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(event);
    };
    VersionManagerComponent.prototype.canUpdate = function () {
        return this.contentService.hasPermission(this.node, 'update');
    };
    return VersionManagerComponent;
}());
VersionManagerComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-version-manager',
                template: "<div class=\"adf-new-version-uploader-container\" fxLayout=\"row\" fxLayoutAlign=\"end center\">\n    <adf-version-upload\n        [node]=\"node\"\n        (success)=\"onUploadSuccess($event)\"\n        (error)=\"uploadError.emit($event)\">\n    </adf-version-upload>\n</div>\n<div class=\"adf-version-list-container\">\n    <adf-version-list\n        #versionList\n        [node]=\"node\"\n        [allowDownload]=\"allowDownload\"\n        [showComments]=\"showComments\">\n    </adf-version-list>\n</div>\n",
                styles: [".adf-button.upload-new-version{-webkit-box-shadow:none;box-shadow:none}.adf-new-version-uploader-container{border-bottom:1px solid #d8d8d8;padding:16px 0}"],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
VersionManagerComponent.ctorParameters = function () { return [
    { type: adfCore.AppConfigService, },
    { type: adfCore.ContentService, },
]; };
VersionManagerComponent.propDecorators = {
    "node": [{ type: core.Input },],
    "showComments": [{ type: core.Input },],
    "allowDownload": [{ type: core.Input },],
    "uploadSuccess": [{ type: core.Output },],
    "uploadError": [{ type: core.Output },],
    "versionListComponent": [{ type: core.ViewChild, args: ['versionList',] },],
};
var VersionUploadComponent =               (function () {
    function VersionUploadComponent(contentService) {
        this.contentService = contentService;
        this.success = new core.EventEmitter();
        this.error = new core.EventEmitter();
    }
    VersionUploadComponent.prototype.canUpload = function () {
        return this.contentService.hasPermission(this.node, 'update');
    };
    return VersionUploadComponent;
}());
VersionUploadComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-version-upload',
                template: "<adf-upload-version-button\n    data-automation-id=\"adf-new-version-file-upload\"\n    class=\"adf-new-version-file-upload\"\n    staticTitle=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TITLE' | translate }}\"\n    [node]=\"node\"\n    [disabled]=\"!canUpload()\"\n    [rootFolderId]=\"node.parentId\"\n    tooltip=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TOOLTIP' | translate }}\"\n    [versioning]=\"true\"\n    (success)=\"success.emit($event)\"\n    (error)=\"error.emit($event)\">\n</adf-upload-version-button>\n",
                encapsulation: core.ViewEncapsulation.None,
                host: { 'class': 'adf-version-upload' }
            },] },
];
VersionUploadComponent.ctorParameters = function () { return [
    { type: adfCore.ContentService, },
]; };
VersionUploadComponent.propDecorators = {
    "node": [{ type: core.Input },],
    "success": [{ type: core.Output },],
    "error": [{ type: core.Output },],
};
var VersionManagerModule =               (function () {
    function VersionManagerModule() {
    }
    return VersionManagerModule;
}());
VersionManagerModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    UploadModule
                ],
                exports: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ],
                declarations: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ],
                providers: []
            },] },
];
VersionManagerModule.ctorParameters = function () { return []; };
var NameLocationCellComponent =               (function () {
    function NameLocationCellComponent() {
        this.name = '';
        this.path = '';
    }
    NameLocationCellComponent.prototype.ngOnInit = function () {
        if (this.row) {
            this.name = this.row.getValue('name');
            var fullPath = this.row.getValue('path');
            if (fullPath) {
                this.path = fullPath.name || '';
            }
        }
    };
    return NameLocationCellComponent;
}());
NameLocationCellComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-name-location-cell',
                template: "\n        <div class=\"adf-name-location-cell-name\">{{ name }}</div>\n        <div class=\"adf-name-location-cell-location\" [title]=\"path\">{{ path }}</div>\n    ",
                styles: [""],
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-name-location-cell' }
            },] },
];
NameLocationCellComponent.ctorParameters = function () { return []; };
NameLocationCellComponent.propDecorators = {
    "row": [{ type: core.Input },],
};
var ContentNodeSelectorService =               (function () {
    function ContentNodeSelectorService(searchService) {
        this.searchService = searchService;
    }
    ContentNodeSelectorService.prototype.search = function (searchTerm, rootNodeId, skipCount, maxItems, extraNodeIds) {
        if (rootNodeId === void 0) { rootNodeId = null; }
        if (skipCount === void 0) { skipCount = 0; }
        if (maxItems === void 0) { maxItems = 25; }
        var extraParentFiltering = '';
        if (extraNodeIds && extraNodeIds.length) {
            extraNodeIds
                .filter(function (id) { return id !== rootNodeId; })
                .forEach(function (extraId) {
                extraParentFiltering += " OR ANCESTOR:'workspace://SpacesStore/" + extraId + "'";
            });
        }
        var parentFiltering = rootNodeId ? [{ query: "ANCESTOR:'workspace://SpacesStore/" + rootNodeId + "'" + extraParentFiltering }] : [];
        var defaultSearchNode = {
            query: {
                query: searchTerm + "* OR name:" + searchTerm + "*"
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxItems,
                skipCount: skipCount
            },
            filterQueries: __spread([
                { query: "TYPE:'cm:folder'" },
                { query: 'NOT cm:creator:System' }
            ], parentFiltering),
            scope: {
                locations: ['nodes']
            }
        };
        return this.searchService.searchByQueryBody(defaultSearchNode);
    };
    return ContentNodeSelectorService;
}());
ContentNodeSelectorService.decorators = [
    { type: core.Injectable },
];
ContentNodeSelectorService.ctorParameters = function () { return [
    { type: adfCore.SearchService, },
]; };
var defaultValidation = function () { return true; };
var ContentNodeSelectorPanelComponent =               (function () {
    function ContentNodeSelectorPanelComponent(contentNodeSelectorService, apiService, preferences) {
        var _this = this;
        this.contentNodeSelectorService = contentNodeSelectorService;
        this.apiService = apiService;
        this.preferences = preferences;
        this.currentFolderId = null;
        this.dropdownHideMyFiles = false;
        this.dropdownSiteList = null;
        this.rowFilter = null;
        this.imageResolver = null;
        this.isSelectionValid = defaultValidation;
        this.select = new core.EventEmitter();
        this.nodes = null;
        this.searchTerm = '';
        this.showingSearchResults = false;
        this.loadingSearchResults = false;
        this.inDialog = false;
        this._chosenNode = null;
        this.folderIdToShow = null;
        this.paginationStrategy = PaginationStrategy.Infinite;
        this.skipCount = 0;
        this.infiniteScroll = false;
        this.debounceSearch = 200;
        this.searchInput = new forms.FormControl();
        this.searchInput.valueChanges
            .pipe(operators.debounceTime(this.debounceSearch))
            .subscribe(function (searchValue) {
            _this.search(searchValue);
        });
        this.pageSize = this.preferences.paginationSize;
        var defaultPagination = ({
            maxItems: this.pageSize,
            skipCount: 0,
            totalItems: 0,
            hasMoreItems: false
        });
        this.pagination = new BehaviorSubject.BehaviorSubject(defaultPagination);
    }
    Object.defineProperty(ContentNodeSelectorPanelComponent.prototype, "chosenNode", {
        get: function () {
            return this._chosenNode;
        },
        set: function (value) {
            this._chosenNode = value;
            var valuesArray = null;
            if (value) {
                valuesArray = [value];
            }
            this.select.next(valuesArray);
        },
        enumerable: true,
        configurable: true
    });
    ContentNodeSelectorPanelComponent.prototype.ngOnInit = function () {
        this.folderIdToShow = this.currentFolderId;
        this.breadcrumbTransform = this.breadcrumbTransform ? this.breadcrumbTransform : null;
        this.isSelectionValid = this.isSelectionValid ? this.isSelectionValid : defaultValidation;
    };
    ContentNodeSelectorPanelComponent.prototype.siteChanged = function (chosenSite) {
        this.siteId = chosenSite.entry.guid;
        this.updateResults();
    };
    ContentNodeSelectorPanelComponent.prototype.search = function (searchTerm) {
        this.searchTerm = searchTerm;
        this.updateResults();
    };
    Object.defineProperty(ContentNodeSelectorPanelComponent.prototype, "breadcrumbFolderNode", {
        get: function () {
            var folderNode;
            if (this.showingSearchResults && this.chosenNode) {
                folderNode = this.chosenNode;
            }
            else {
                folderNode = this.documentList.folderNode;
            }
            return folderNode;
        },
        enumerable: true,
        configurable: true
    });
    ContentNodeSelectorPanelComponent.prototype.clear = function () {
        this.clearSearch();
        this.folderIdToShow = this.siteId || this.currentFolderId;
    };
    ContentNodeSelectorPanelComponent.prototype.clearSearch = function () {
        this.searchTerm = '';
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.showingSearchResults = false;
    };
    ContentNodeSelectorPanelComponent.prototype.updateResults = function () {
        if (this.searchTerm.length === 0) {
            this.clear();
        }
        else {
            this.startNewSearch();
        }
    };
    ContentNodeSelectorPanelComponent.prototype.startNewSearch = function () {
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.folderIdToShow = null;
        this.querySearch();
    };
    ContentNodeSelectorPanelComponent.prototype.updatePagination = function (pagination) {
        this.infiniteScroll = true;
        this.skipCount = pagination.skipCount;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    };
    ContentNodeSelectorPanelComponent.prototype.querySearch = function () {
        var _this = this;
        this.loadingSearchResults = true;
        if (this.dropdownSiteList) {
            this.documentList.getCorrespondingNodeIds(this.siteId)
                .subscribe(function (nodeIds) {
                _this.contentNodeSelectorService.search(_this.searchTerm, _this.siteId, _this.skipCount, _this.pageSize, nodeIds)
                    .subscribe(_this.showSearchResults.bind(_this));
            }, function () {
                _this.showSearchResults({ list: { entries: [] } });
            });
        }
        else {
            this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.skipCount, this.pageSize)
                .subscribe(this.showSearchResults.bind(this));
        }
    };
    ContentNodeSelectorPanelComponent.prototype.showSearchResults = function (nodePaging) {
        this.showingSearchResults = true;
        this.loadingSearchResults = false;
        if (!this.nodes) {
            this.nodes = nodePaging;
        }
        else {
            this.documentList.data.loadPage(nodePaging, true);
        }
        this.pagination.next(nodePaging.list.pagination);
        this.highlight();
    };
    ContentNodeSelectorPanelComponent.prototype.highlight = function () {
        var _this = this;
        setTimeout(function () {
            _this.highlighter.highlight(_this.searchTerm);
        }, 0);
    };
    ContentNodeSelectorPanelComponent.prototype.onFolderChange = function () {
        this.showingSearchResults = false;
        this.infiniteScroll = false;
        this.clearSearch();
    };
    ContentNodeSelectorPanelComponent.prototype.onFolderLoaded = function (nodePaging) {
        if (!this.showingSearchResults) {
            this.attemptNodeSelection(this.documentList.folderNode);
        }
    };
    ContentNodeSelectorPanelComponent.prototype.showBreadcrumbs = function () {
        return !this.showingSearchResults || this.chosenNode;
    };
    ContentNodeSelectorPanelComponent.prototype.getNextPageOfSearch = function (event) {
        this.infiniteScroll = true;
        this.skipCount = event.skipCount;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    };
    ContentNodeSelectorPanelComponent.prototype.attemptNodeSelection = function (entry) {
        if (this.isSelectionValid(entry)) {
            this.chosenNode = entry;
        }
        else {
            this.resetChosenNode();
        }
    };
    ContentNodeSelectorPanelComponent.prototype.resetChosenNode = function () {
        this.chosenNode = null;
    };
    ContentNodeSelectorPanelComponent.prototype.onNodeSelect = function (event) {
        this.attemptNodeSelection(event.detail.node.entry);
    };
    ContentNodeSelectorPanelComponent.prototype.onNodeDoubleClick = function (e) {
        var _this = this;
        var node = e.detail.node.entry;
        if (node && node.guid) {
            var options = {
                maxItems: this.pageSize,
                skipCount: this.skipCount,
                include: ['path', 'properties', 'allowableOperations']
            };
            this.apiService.nodesApi.getNode(node.guid, options)
                .then(function (documentLibrary) {
                _this.documentList.performCustomSourceNavigation(documentLibrary);
            });
        }
    };
    return ContentNodeSelectorPanelComponent;
}());
ContentNodeSelectorPanelComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-content-node-selector-panel',
                styles: [""],
                template: "<div class=\"adf-content-node-selector-content\" (node-select)=\"onNodeSelect($event)\">\n    <mat-form-field floatPlaceholder=\"never\" class=\"adf-content-node-selector-content-input\">\n        <input matInput\n            id=\"searchInput\"\n            [formControl]=\"searchInput\"\n            type=\"text\"\n            placeholder=\"{{'NODE_SELECTOR.SEARCH' | translate}}\"\n            [value]=\"searchTerm\"\n            data-automation-id=\"content-node-selector-search-input\">\n\n        <mat-icon *ngIf=\"searchTerm.length > 0\"\n            matSuffix (click)=\"clear()\"\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-clear\">clear\n        </mat-icon>\n\n        <mat-icon *ngIf=\"searchTerm.length === 0\"\n            matSuffix\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-icon\">search\n        </mat-icon>\n\n    </mat-form-field>\n\n    <adf-sites-dropdown\n        class=\"full-width\"\n        (change)=\"siteChanged($event)\"\n        [placeholder]=\"'NODE_SELECTOR.SELECT_LOCATION'\"\n        [hideMyFiles]=\"dropdownHideMyFiles\"\n        [siteList]=\"dropdownSiteList\"\n        data-automation-id=\"content-node-selector-sites-combo\">\n    </adf-sites-dropdown>\n\n    <adf-toolbar>\n        <adf-toolbar-title>\n            <ng-container *ngIf=\"!showBreadcrumbs()\">\n                <span class=\"search-results-label\">{{ 'NODE_SELECTOR.SEARCH_RESULTS' | translate }}</span>\n            </ng-container>\n            <adf-dropdown-breadcrumb *ngIf=\"showBreadcrumbs()\"\n                class=\"adf-content-node-selector-content-breadcrumb\"\n                (navigate)=\"clearSearch()\"\n                [target]=\"documentList\"\n                [transform]=\"breadcrumbTransform\"\n                [folderNode]=\"breadcrumbFolderNode\"\n                data-automation-id=\"content-node-selector-content-breadcrumb\">\n            </adf-dropdown-breadcrumb>\n        </adf-toolbar-title>\n    </adf-toolbar>\n\n    <div\n        class=\"adf-content-node-selector-content-list\"\n        [class.adf-content-node-selector-content-list-searchLayout]=\"showingSearchResults\"\n        data-automation-id=\"content-node-selector-content-list\">\n        <adf-document-list\n            #documentList\n            adf-highlight\n            adf-highlight-selector=\"adf-name-location-cell .adf-name-location-cell-name\"\n            [showHeader]=\"false\"\n            [node]=\"nodes\"\n            [maxItems]=\"pageSize\"\n            [rowFilter]=\"rowFilter\"\n            [imageResolver]=\"imageResolver\"\n            [currentFolderId]=\"folderIdToShow\"\n            selectionMode=\"single\"\n            [contextMenuActions]=\"false\"\n            [contentActions]=\"false\"\n            [allowDropFiles]=\"false\"\n            (folderChange)=\"onFolderChange()\"\n            (ready)=\"onFolderLoaded($event)\"\n            (node-dblclick)=\"onNodeDoubleClick($event)\"\n            data-automation-id=\"content-node-selector-document-list\">\n            <empty-folder-content>\n                <ng-template>\n                    <div>{{ 'NODE_SELECTOR.NO_RESULTS' | translate }}</div>\n                </ng-template>\n            </empty-folder-content>\n\n            <data-columns>\n                <data-column key=\"$thumbnail\" type=\"image\"></data-column>\n                <data-column key=\"name\" type=\"text\" class=\"full-width ellipsis-cell\">\n                    <ng-template let-context>\n                        <adf-name-location-cell [row]=\"context.row\"></adf-name-location-cell>\n                    </ng-template>\n                </data-column>\n                <data-column key=\"modifiedAt\" type=\"date\" format=\"timeAgo\" class=\"adf-content-selector-modified-cell\"></data-column>\n                <data-column key=\"modifiedByUser.displayName\" type=\"text\" class=\"adf-content-selector-modifier-cell\"></data-column>\n                <data-column key=\"visibility\" type=\"text\"></data-column>\n            </data-columns>\n\n        </adf-document-list>\n\n        <adf-infinite-pagination\n            [target]=\"documentList\"\n            [loading]=\"loadingSearchResults\"\n            (loadMore)=\"getNextPageOfSearch($event)\"\n            data-automation-id=\"content-node-selector-search-pagination\">\n            {{ 'ADF-DOCUMENT-LIST.LAYOUT.LOAD_MORE' | translate }}\n        </adf-infinite-pagination>\n    </div>\n</div>\n",
                encapsulation: core.ViewEncapsulation.None,
                host: { 'class': 'adf-content-node-selector-panel' }
            },] },
];
ContentNodeSelectorPanelComponent.ctorParameters = function () { return [
    { type: ContentNodeSelectorService, },
    { type: adfCore.AlfrescoApiService, },
    { type: adfCore.UserPreferencesService, },
]; };
ContentNodeSelectorPanelComponent.propDecorators = {
    "currentFolderId": [{ type: core.Input },],
    "dropdownHideMyFiles": [{ type: core.Input },],
    "dropdownSiteList": [{ type: core.Input },],
    "rowFilter": [{ type: core.Input },],
    "imageResolver": [{ type: core.Input },],
    "pageSize": [{ type: core.Input },],
    "isSelectionValid": [{ type: core.Input },],
    "breadcrumbTransform": [{ type: core.Input },],
    "select": [{ type: core.Output },],
    "documentList": [{ type: core.ViewChild, args: ['documentList',] },],
    "highlighter": [{ type: core.ViewChild, args: [adfCore.HighlightDirective,] },],
};
var ContentNodeSelectorModule =               (function () {
    function ContentNodeSelectorModule() {
    }
    return ContentNodeSelectorModule;
}());
ContentNodeSelectorModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    forms.FormsModule,
                    forms.ReactiveFormsModule,
                    adfCore.DirectiveModule,
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    adfCore.ToolbarModule,
                    DocumentListModule,
                    adfCore.DataColumnModule,
                    adfCore.DataTableModule,
                    adfCore.PaginationModule
                ],
                exports: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ],
                entryComponents: [
                    ContentNodeSelectorPanelComponent, ContentNodeSelectorComponent
                ],
                declarations: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ],
                providers: [
                    ContentNodeSelectorService,
                    ContentNodeDialogService
                ]
            },] },
];
ContentNodeSelectorModule.ctorParameters = function () { return []; };
var I18N_ERRORS_PATH = 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS';
function forbidSpecialCharacters(_b) {
    var value = _b.value;
    var specialCharacters = /([\*\"\<\>\\\/\?\:\|])/;
    var isValid = !specialCharacters.test(value);
    return (isValid) ? null : {
        message: I18N_ERRORS_PATH + ".SPECIAL_CHARACTERS"
    };
}
function forbidEndingDot(_b) {
    var value = _b.value;
    var isValid = ((value || '').trim().split('').pop() !== '.');
    return isValid ? null : {
        message: I18N_ERRORS_PATH + ".ENDING_DOT"
    };
}
function forbidOnlySpaces(_b) {
    var value = _b.value;
    var isValid = !!((value || '')).trim();
    return isValid ? null : {
        message: I18N_ERRORS_PATH + ".ONLY_SPACES"
    };
}
var FolderDialogComponent =               (function () {
    function FolderDialogComponent(formBuilder, dialog, nodesApi, translation, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.nodesApi = nodesApi;
        this.translation = translation;
        this.data = data;
        this.folder = null;
        this.error = new core.EventEmitter();
    }
    Object.defineProperty(FolderDialogComponent.prototype, "editing", {
        get: function () {
            return !!this.data.folder;
        },
        enumerable: true,
        configurable: true
    });
    FolderDialogComponent.prototype.ngOnInit = function () {
        var folder = this.data.folder;
        var name = '';
        var description = '';
        if (folder) {
            var properties = folder.properties;
            name = folder.name || '';
            description = properties ? properties['cm:description'] : '';
        }
        var validators = {
            name: [
                forms.Validators.required,
                forbidSpecialCharacters,
                forbidEndingDot,
                forbidOnlySpaces
            ]
        };
        this.form = this.formBuilder.group({
            name: [name, validators.name],
            description: [description]
        });
    };
    Object.defineProperty(FolderDialogComponent.prototype, "name", {
        get: function () {
            var name = this.form.value.name;
            return (name || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderDialogComponent.prototype, "description", {
        get: function () {
            var description = this.form.value.description;
            return (description || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderDialogComponent.prototype, "properties", {
        get: function () {
            var _b = this, title = _b.name, description = _b.description;
            return {
                'cm:title': title,
                'cm:description': description
            };
        },
        enumerable: true,
        configurable: true
    });
    FolderDialogComponent.prototype.create = function () {
        var _b = this, name = _b.name, properties = _b.properties, nodesApi = _b.nodesApi, parentNodeId = _b.data.parentNodeId;
        return nodesApi.createFolder(parentNodeId, { name: name, properties: properties });
    };
    FolderDialogComponent.prototype.edit = function () {
        var _b = this, name = _b.name, properties = _b.properties, nodesApi = _b.nodesApi, nodeId = _b.data.folder.id;
        return nodesApi.updateNode(nodeId, { name: name, properties: properties });
    };
    FolderDialogComponent.prototype.submit = function () {
        var _this = this;
        var _b = this, form = _b.form, dialog = _b.dialog, editing = _b.editing;
        if (!form.valid) {
            return;
        }
        (editing ? this.edit() : this.create())
            .subscribe(function (folder) { return dialog.close(folder); }, function (error) { return _this.handleError(error); });
    };
    FolderDialogComponent.prototype.handleError = function (error) {
        var errorMessage = 'CORE.MESSAGES.ERRORS.GENERIC';
        try {
            var statusCode = JSON.parse(error.message).error.statusCode;
            if (statusCode === 409) {
                errorMessage = 'CORE.MESSAGES.ERRORS.EXISTENT_FOLDER';
            }
        }
        catch (err) {
        }
        this.error.emit(this.translation.instant(errorMessage));
        return error;
    };
    return FolderDialogComponent;
}());
FolderDialogComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-folder-dialog',
                styles: [".adf-fill-remaining-space{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.adf-full-width{width:100%}"],
                template: "<h2 mat-dialog-title>\n    {{\n    (editing\n    ? 'CORE.FOLDER_DIALOG.EDIT_FOLDER_TITLE'\n    : 'CORE.FOLDER_DIALOG.CREATE_FOLDER_TITLE'\n    ) | translate\n    }}\n</h2>\n\n<mat-dialog-content>\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-input-container class=\"adf-full-width\">\n            <input\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.LABEL' | translate }}\"\n                matInput\n                required\n                [formControl]=\"form.controls['name']\"\n            />\n\n            <mat-hint *ngIf=\"form.controls['name'].dirty\">\n                <span *ngIf=\"form.controls['name'].errors?.required\">\n                    {{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS.REQUIRED' | translate }}\n                </span>\n\n                <span *ngIf=\"!form.controls['name'].errors?.required && form.controls['name'].errors?.message\">\n                    {{ form.controls['name'].errors?.message | translate }}\n                </span>\n            </mat-hint>\n        </mat-input-container>\n\n        <br />\n        <br />\n\n        <mat-input-container class=\"adf-full-width\">\n            <textarea\n                matInput\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_DESCRIPTION.LABEL' | translate }}\"\n                rows=\"4\"\n                [formControl]=\"form.controls['description']\"></textarea>\n        </mat-input-container>\n    </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button\n        mat-button\n        mat-dialog-close>\n        {{ 'CORE.FOLDER_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\"\n            mat-button\n            (click)=\"submit()\"\n            [disabled]=\"!form.valid\">\n        {{\n        (editing\n        ? 'CORE.FOLDER_DIALOG.UPDATE_BUTTON.LABEL'\n        : 'CORE.FOLDER_DIALOG.CREATE_BUTTON.LABEL'\n        ) | translate\n        }}\n    </button>\n</mat-dialog-actions>\n"
            },] },
];
FolderDialogComponent.ctorParameters = function () { return [
    { type: forms.FormBuilder, },
    { type: material.MatDialogRef, },
    { type: adfCore.NodesApiService, },
    { type: adfCore.TranslationService, },
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_DIALOG_DATA,] },] },
]; };
FolderDialogComponent.propDecorators = {
    "error": [{ type: core.Output },],
};
var DialogModule =               (function () {
    function DialogModule() {
    }
    return DialogModule;
}());
DialogModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    forms.FormsModule,
                    adfCore.FormModule,
                    forms.ReactiveFormsModule,
                    moment$1.MatMomentDatetimeModule,
                    core$2.MatDatetimepickerModule
                ],
                declarations: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ShareDialogComponent,
                    ConfirmDialogComponent
                ],
                exports: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ShareDialogComponent,
                    ConfirmDialogComponent
                ],
                entryComponents: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ShareDialogComponent,
                    ConfirmDialogComponent
                ]
            },] },
];
DialogModule.ctorParameters = function () { return []; };
var DEFAULT_FOLDER_PARENT_ID = '-my-';
var FolderCreateDirective =               (function () {
    function FolderCreateDirective(dialogRef, content) {
        this.dialogRef = dialogRef;
        this.content = content;
        this.parentNodeId = DEFAULT_FOLDER_PARENT_ID;
        this.error = new core.EventEmitter();
    }
    FolderCreateDirective.prototype.onClick = function (event) {
        event.preventDefault();
        this.openDialog();
    };
    Object.defineProperty(FolderCreateDirective.prototype, "dialogConfig", {
        get: function () {
            var width = FolderCreateDirective.DIALOG_WIDTH;
            var parentNodeId = this.parentNodeId;
            return {
                data: { parentNodeId: parentNodeId },
                width: width + "px"
            };
        },
        enumerable: true,
        configurable: true
    });
    FolderCreateDirective.prototype.openDialog = function () {
        var _this = this;
        var _b = this, dialogRef = _b.dialogRef, dialogConfig = _b.dialogConfig, content = _b.content;
        var dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe(function (error) {
            _this.error.emit(error);
        });
        dialogInstance.afterClosed().subscribe(function (node) {
            if (node) {
                content.folderCreate.next(node);
            }
        });
    };
    return FolderCreateDirective;
}());
FolderCreateDirective.DIALOG_WIDTH = 400;
FolderCreateDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[adf-create-folder]'
            },] },
];
FolderCreateDirective.ctorParameters = function () { return [
    { type: material.MatDialog, },
    { type: adfCore.ContentService, },
]; };
FolderCreateDirective.propDecorators = {
    "parentNodeId": [{ type: core.Input, args: ['adf-create-folder',] },],
    "error": [{ type: core.Output },],
    "onClick": [{ type: core.HostListener, args: ['click', ['$event'],] },],
};
var FolderEditDirective =               (function () {
    function FolderEditDirective(dialogRef, elementRef, content) {
        this.dialogRef = dialogRef;
        this.elementRef = elementRef;
        this.content = content;
        this.error = new core.EventEmitter();
    }
    FolderEditDirective.prototype.onClick = function (event) {
        event.preventDefault();
        if (this.folder) {
            this.openDialog();
        }
    };
    Object.defineProperty(FolderEditDirective.prototype, "dialogConfig", {
        get: function () {
            var width = FolderEditDirective.DIALOG_WIDTH;
            var folder = this.folder;
            return {
                data: { folder: folder },
                width: width + "px"
            };
        },
        enumerable: true,
        configurable: true
    });
    FolderEditDirective.prototype.openDialog = function () {
        var _this = this;
        var _b = this, dialogRef = _b.dialogRef, dialogConfig = _b.dialogConfig, content = _b.content;
        var dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe(function (error) {
            _this.error.emit(error);
        });
        dialogInstance.afterClosed().subscribe(function (node) {
            if (node) {
                content.folderEdit.next(node);
            }
        });
    };
    return FolderEditDirective;
}());
FolderEditDirective.DIALOG_WIDTH = 400;
FolderEditDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[adf-edit-folder]'
            },] },
];
FolderEditDirective.ctorParameters = function () { return [
    { type: material.MatDialog, },
    { type: core.ElementRef, },
    { type: adfCore.ContentService, },
]; };
FolderEditDirective.propDecorators = {
    "folder": [{ type: core.Input, args: ['adf-edit-folder',] },],
    "error": [{ type: core.Output },],
    "onClick": [{ type: core.HostListener, args: ['click', ['$event'],] },],
};
var FolderDirectiveModule =               (function () {
    function FolderDirectiveModule() {
    }
    return FolderDirectiveModule;
}());
FolderDirectiveModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule
                ],
                declarations: [
                    FolderCreateDirective,
                    FolderEditDirective
                ],
                exports: [
                    FolderCreateDirective,
                    FolderEditDirective
                ]
            },] },
];
FolderDirectiveModule.ctorParameters = function () { return []; };
var ContentMetadataCardComponent =               (function () {
    function ContentMetadataCardComponent() {
        this.displayEmpty = false;
        this.readOnly = false;
        this.multi = false;
        this.editable = false;
        this.expanded = false;
    }
    ContentMetadataCardComponent.prototype.toggleEdit = function () {
        this.editable = !this.editable;
    };
    ContentMetadataCardComponent.prototype.toggleExpanded = function () {
        this.expanded = !this.expanded;
    };
    return ContentMetadataCardComponent;
}());
ContentMetadataCardComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-content-metadata-card',
                template: "<mat-card *ngIf=\"node\">\n    <mat-card-content>\n        <adf-content-metadata\n            [node]=\"node\"\n            [displayEmpty]=\"displayEmpty\"\n            [editable]=\"editable\"\n            [expanded]=\"expanded\"\n            [multi]=\"multi\"\n            [preset]=\"preset\">\n        </adf-content-metadata>\n    </mat-card-content>\n    <mat-card-footer class=\"adf-content-metadata-card-footer\" fxLayout=\"row\" fxLayoutAlign=\"space-between stretch\">\n        <div>\n            <button *ngIf=\"!readOnly\"\n                mat-icon-button\n                (click)=\"toggleEdit()\"\n                [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                data-automation-id=\"mata-data-card-toggle-edit\">\n                <mat-icon>mode_edit</mat-icon>\n            </button>\n        </div>\n        <button mat-button (click)=\"toggleExpanded()\" data-automation-id=\"mata-data-card-toggle-expand\">\n            <ng-container *ngIf=\"!expanded\">\n                <span data-automation-id=\"mata-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.MORE_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_down</mat-icon>\n            </ng-container>\n            <ng-container *ngIf=\"expanded\">\n                <span data-automation-id=\"mata-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.LESS_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_up</mat-icon>\n            </ng-container>\n        </button>\n    </mat-card-footer>\n</mat-card>\n",
                styles: [""],
                encapsulation: core.ViewEncapsulation.None,
                host: { 'class': 'adf-content-metadata-card' }
            },] },
];
ContentMetadataCardComponent.ctorParameters = function () { return []; };
ContentMetadataCardComponent.propDecorators = {
    "node": [{ type: core.Input },],
    "displayEmpty": [{ type: core.Input },],
    "preset": [{ type: core.Input },],
    "readOnly": [{ type: core.Input },],
    "multi": [{ type: core.Input },],
};
var BasicPropertiesService =               (function () {
    function BasicPropertiesService(fileSizePipe) {
        this.fileSizePipe = fileSizePipe;
    }
    BasicPropertiesService.prototype.getProperties = function (node) {
        var sizeInBytes = node.content ? node.content.sizeInBytes : '', mimeTypeName = node.content ? node.content.mimeTypeName : '', author = node.properties ? node.properties['cm:author'] : '', description = node.properties ? node.properties['cm:description'] : '', title = node.properties ? node.properties['cm:title'] : '';
        return [
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.NAME',
                value: node.name,
                key: 'name',
                editable: true
            }),
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.TITLE',
                value: title,
                key: 'properties.cm:title',
                editable: true
            }),
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.CREATOR',
                value: node.createdByUser.displayName,
                key: 'createdByUser.displayName',
                editable: false
            }),
            new adfCore.CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.CREATED_DATE',
                value: node.createdAt,
                key: 'createdAt',
                editable: false
            }),
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.SIZE',
                value: sizeInBytes,
                key: 'content.sizeInBytes',
                pipes: [{ pipe: this.fileSizePipe }],
                editable: false
            }),
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIER',
                value: node.modifiedByUser.displayName,
                key: 'modifiedByUser.displayName',
                editable: false
            }),
            new adfCore.CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIED_DATE',
                value: node.modifiedAt,
                key: 'modifiedAt',
                editable: false
            }),
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MIMETYPE',
                value: mimeTypeName,
                key: 'content.mimeTypeName',
                editable: false
            }),
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.AUTHOR',
                value: author,
                key: 'properties.cm:author',
                editable: true
            }),
            new adfCore.CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.DESCRIPTION',
                value: description,
                key: 'properties.cm:description',
                multiline: true,
                editable: true
            })
        ];
    };
    return BasicPropertiesService;
}());
BasicPropertiesService.decorators = [
    { type: core.Injectable },
];
BasicPropertiesService.ctorParameters = function () { return [
    { type: adfCore.FileSizePipe, },
]; };
var D_TEXT = 'd:text';
var D_MLTEXT = 'd:mltext';
var D_DATE = 'd:date';
var D_DATETIME = 'd:datetime';
var D_INT = 'd:int';
var D_LONG = 'd:long';
var D_FLOAT = 'd:float';
var D_DOUBLE = 'd:double';
var D_BOOLEAN = 'd:boolean';
var PropertyGroupTranslatorService =               (function () {
    function PropertyGroupTranslatorService(logService) {
        this.logService = logService;
    }
    PropertyGroupTranslatorService.prototype.translateToCardViewGroups = function (propertyGroups, propertyValues) {
        var _this = this;
        return propertyGroups.map(function (propertyGroup) {
            var translatedPropertyGroup = Object.assign({}, propertyGroup);
            translatedPropertyGroup.properties = _this.translateArray(propertyGroup.properties, propertyValues);
            return translatedPropertyGroup;
        });
    };
    PropertyGroupTranslatorService.prototype.translateArray = function (properties, propertyValues) {
        var _this = this;
        return properties.map(function (property) {
            return _this.translate(property, propertyValues[property.name]);
        });
    };
    PropertyGroupTranslatorService.prototype.translate = function (property, propertyValue) {
        this.checkECMTypeValidity(property.dataType);
        var prefix = 'properties.';
        var propertyDefinition = {
            label: property.title,
            value: propertyValue,
            key: "" + prefix + property.name,
            default: property.defaultValue,
            editable: true
        };
        var cardViewItemProperty;
        switch (property.dataType) {
            case D_MLTEXT:
                cardViewItemProperty = new adfCore.CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: true
                }));
                break;
            case D_INT:
            case D_LONG:
                cardViewItemProperty = new adfCore.CardViewIntItemModel(propertyDefinition);
                break;
            case D_FLOAT:
            case D_DOUBLE:
                cardViewItemProperty = new adfCore.CardViewFloatItemModel(propertyDefinition);
                break;
            case D_DATE:
                cardViewItemProperty = new adfCore.CardViewDateItemModel(propertyDefinition);
                break;
            case D_DATETIME:
                cardViewItemProperty = new adfCore.CardViewDatetimeItemModel(propertyDefinition);
                break;
            case D_BOOLEAN:
                cardViewItemProperty = new adfCore.CardViewBoolItemModel(propertyDefinition);
                break;
            case D_TEXT:
            default:
                cardViewItemProperty = new adfCore.CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: false
                }));
        }
        return cardViewItemProperty;
    };
    PropertyGroupTranslatorService.prototype.checkECMTypeValidity = function (ecmPropertyType) {
        if (PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES.indexOf(ecmPropertyType) === -1) {
            this.logService.error("Unknown type for mapping: " + ecmPropertyType);
        }
    };
    return PropertyGroupTranslatorService;
}());
PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES = [D_TEXT, D_MLTEXT, D_DATE, D_DATETIME, D_INT, D_LONG, D_FLOAT, D_DOUBLE, D_BOOLEAN];
PropertyGroupTranslatorService.decorators = [
    { type: core.Injectable },
];
PropertyGroupTranslatorService.ctorParameters = function () { return [
    { type: adfCore.LogService, },
]; };
var emptyGroup = {
    properties: {}
};
function convertObjectToArray(object) {
    return Object.keys(object).map(function (key) { return object[key]; });
}
function getGroup(propertyGroups, groupName) {
    return propertyGroups[groupName];
}
function getProperty(propertyGroups, groupName, propertyName) {
    var groupDefinition = getGroup(propertyGroups, groupName) || emptyGroup;
    var propertyDefinitions;
    if (propertyName === '*') {
        propertyDefinitions = convertObjectToArray(groupDefinition.properties);
    }
    else {
        propertyDefinitions = groupDefinition.properties[propertyName];
    }
    return propertyDefinitions;
}
var AspectOrientedConfigService =               (function () {
    function AspectOrientedConfigService(config) {
        this.config = config;
    }
    AspectOrientedConfigService.prototype.isGroupAllowed = function (groupName) {
        var groupNames = Object.keys(this.config);
        return groupNames.indexOf(groupName) !== -1;
    };
    AspectOrientedConfigService.prototype.reorganiseByConfig = function (propertyGroups) {
        var _this = this;
        var aspects = this.config, aspectNames = Object.keys(aspects);
        return aspectNames
            .reduce(function (groupAccumulator, aspectName) {
            var newGroup = _this.getOrganisedPropertyGroup(propertyGroups, aspectName);
            return groupAccumulator.concat(newGroup);
        }, [])
            .filter(function (organisedPropertyGroup) { return organisedPropertyGroup.properties.length > 0; });
    };
    AspectOrientedConfigService.prototype.getOrganisedPropertyGroup = function (propertyGroups, aspectName) {
        var group = getGroup(propertyGroups, aspectName);
        var newGroup = [];
        if (group) {
            var aspectProperties = this.config[aspectName];
            var properties = void 0;
            if (aspectProperties === '*') {
                properties = getProperty(propertyGroups, aspectName, aspectProperties);
            }
            else {
                properties = ((aspectProperties))
                    .map(function (propertyName) { return getProperty(propertyGroups, aspectName, propertyName); })
                    .filter(function (props) { return props !== undefined; });
            }
            newGroup = [{ title: group.title, properties: properties }];
        }
        return newGroup;
    };
    return AspectOrientedConfigService;
}());
AspectOrientedConfigService.decorators = [
    { type: core.Injectable },
];
AspectOrientedConfigService.ctorParameters = function () { return [
    null,
]; };
var IndifferentConfigService =               (function () {
    function IndifferentConfigService(config) {
    }
    IndifferentConfigService.prototype.isGroupAllowed = function (groupName) {
        return true;
    };
    IndifferentConfigService.prototype.reorganiseByConfig = function (propertyGroups) {
        return Object.keys(propertyGroups)
            .map(function (groupName) {
            var propertyGroup = propertyGroups[groupName], properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map(function (propertyName) { return properties[propertyName]; })
            });
        });
    };
    return IndifferentConfigService;
}());
IndifferentConfigService.decorators = [
    { type: core.Injectable },
];
IndifferentConfigService.ctorParameters = function () { return [
    null,
]; };
var LayoutOrientedConfigService =               (function () {
    function LayoutOrientedConfigService(config) {
        this.config = config;
    }
    LayoutOrientedConfigService.prototype.isGroupAllowed = function (groupName) {
        return this.getMatchingGroups(groupName).length > 0;
    };
    LayoutOrientedConfigService.prototype.reorganiseByConfig = function (propertyGroups) {
        var _this = this;
        var layoutBlocks = this.config;
        return layoutBlocks.map(function (layoutBlock) {
            var flattenedItems = _this.flattenItems(layoutBlock.items), properties = flattenedItems.reduce(function (props, explodedItem) {
                var property = getProperty(propertyGroups, explodedItem.groupName, explodedItem.propertyName) || [];
                return props.concat(property);
            }, []);
            return {
                title: layoutBlock.title,
                properties: properties
            };
        });
    };
    LayoutOrientedConfigService.prototype.flattenItems = function (items) {
        return items.reduce(function (accumulator, item) {
            var properties = Array.isArray(item.properties) ? item.properties : [item.properties];
            var flattenedProperties = properties.map(function (propertyName) {
                return {
                    groupName: item.aspect || item.type,
                    propertyName: propertyName
                };
            });
            return accumulator.concat(flattenedProperties);
        }, []);
    };
    LayoutOrientedConfigService.prototype.getMatchingGroups = function (groupName) {
        return this.config
            .map(function (layoutBlock) { return layoutBlock.items; })
            .reduce(function (accumulator, items) { return accumulator.concat(items); }, [])
            .filter(function (item) { return item.aspect === groupName || item.type === groupName; });
    };
    return LayoutOrientedConfigService;
}());
LayoutOrientedConfigService.decorators = [
    { type: core.Injectable },
];
LayoutOrientedConfigService.ctorParameters = function () { return [
    null,
]; };
var ContentMetadataConfigFactory =               (function () {
    function ContentMetadataConfigFactory(appConfigService, logService) {
        this.appConfigService = appConfigService;
        this.logService = logService;
    }
    ContentMetadataConfigFactory.prototype.get = function (presetName) {
        if (presetName === void 0) { presetName = 'default'; }
        var presetConfig;
        try {
            presetConfig = this.appConfigService.config['content-metadata'].presets[presetName];
        }
        catch (_a) {
            if (presetName !== ContentMetadataConfigFactory.DEFAULT_PRESET_NAME) {
                this.logService.error("No content-metadata preset for: " + presetName);
            }
            presetConfig = ContentMetadataConfigFactory.INDIFFERENT_PRESET;
        }
        return this.createConfig(presetConfig);
    };
    ContentMetadataConfigFactory.prototype.createConfig = function (presetConfig) {
        var config;
        if (this.isLayoutOrientedPreset(presetConfig)) {
            config = new LayoutOrientedConfigService((presetConfig));
        }
        else if (this.isAspectOrientedPreset(presetConfig)) {
            config = new AspectOrientedConfigService((presetConfig));
        }
        else {
            config = new IndifferentConfigService((presetConfig));
        }
        Object.freeze(config);
        return config;
    };
    ContentMetadataConfigFactory.prototype.isAspectOrientedPreset = function (presetConfig) {
        return this.isObject(presetConfig);
    };
    ContentMetadataConfigFactory.prototype.isLayoutOrientedPreset = function (presetConfig) {
        return Array.isArray(presetConfig);
    };
    ContentMetadataConfigFactory.prototype.isObject = function (x) {
        return x != null && typeof x === 'object';
    };
    return ContentMetadataConfigFactory;
}());
ContentMetadataConfigFactory.INDIFFERENT_PRESET = '*';
ContentMetadataConfigFactory.DEFAULT_PRESET_NAME = 'default';
ContentMetadataConfigFactory.decorators = [
    { type: core.Injectable },
];
ContentMetadataConfigFactory.ctorParameters = function () { return [
    { type: adfCore.AppConfigService, },
    { type: adfCore.LogService, },
]; };
var PropertyDescriptorsService =               (function () {
    function PropertyDescriptorsService(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    PropertyDescriptorsService.prototype.load = function (groupNames) {
        var _this = this;
        var groupFetchStreams = groupNames
            .map(function (groupName) { return groupName.replace(':', '_'); })
            .map(function (groupName) { return defer.defer(function () { return _this.alfrescoApiService.classesApi.getClass(groupName); }); });
        return forkJoin.forkJoin(groupFetchStreams)
            .map(this.convertToObject);
    };
    PropertyDescriptorsService.prototype.convertToObject = function (propertyGroupsArray) {
        return propertyGroupsArray.reduce(function (propertyGroups, propertyGroup) {
            return Object.assign({}, propertyGroups, (_b = {}, _b[propertyGroup.name] = propertyGroup, _b));
            var _b;
        }, {});
    };
    return PropertyDescriptorsService;
}());
PropertyDescriptorsService.decorators = [
    { type: core.Injectable },
];
PropertyDescriptorsService.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
]; };
var ContentMetadataService =               (function () {
    function ContentMetadataService(basicPropertiesService, contentMetadataConfigFactory, propertyGroupTranslatorService, propertyDescriptorsService) {
        this.basicPropertiesService = basicPropertiesService;
        this.contentMetadataConfigFactory = contentMetadataConfigFactory;
        this.propertyGroupTranslatorService = propertyGroupTranslatorService;
        this.propertyDescriptorsService = propertyDescriptorsService;
    }
    ContentMetadataService.prototype.getBasicProperties = function (node) {
        return Observable.Observable.of(this.basicPropertiesService.getProperties(node));
    };
    ContentMetadataService.prototype.getGroupedProperties = function (node, presetName) {
        var _this = this;
        if (presetName === void 0) { presetName = 'default'; }
        var groupedProperties = Observable.Observable.of([]);
        if (node.aspectNames) {
            var config_1 = this.contentMetadataConfigFactory.get(presetName), groupNames = node.aspectNames
                .concat(node.nodeType)
                .filter(function (groupName) { return config_1.isGroupAllowed(groupName); });
            if (groupNames.length > 0) {
                groupedProperties = this.propertyDescriptorsService.load(groupNames)
                    .map(function (groups) { return config_1.reorganiseByConfig(groups); })
                    .map(function (groups) { return _this.propertyGroupTranslatorService.translateToCardViewGroups(groups, node.properties); });
            }
        }
        return groupedProperties;
    };
    return ContentMetadataService;
}());
ContentMetadataService.decorators = [
    { type: core.Injectable },
];
ContentMetadataService.ctorParameters = function () { return [
    { type: BasicPropertiesService, },
    { type: ContentMetadataConfigFactory, },
    { type: PropertyGroupTranslatorService, },
    { type: PropertyDescriptorsService, },
]; };
var ContentMetadataComponent =               (function () {
    function ContentMetadataComponent(contentMetadataService, cardViewUpdateService, nodesApi, logService, apiService) {
        this.contentMetadataService = contentMetadataService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.nodesApi = nodesApi;
        this.logService = logService;
        this.apiService = apiService;
        this.editable = false;
        this.displayEmpty = false;
        this.expanded = false;
        this.multi = false;
        this.nodeHasBeenUpdated = false;
    }
    ContentMetadataComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.cardViewUpdateService.itemUpdated$
            .switchMap(this.saveNode.bind(this))
            .subscribe(function (node) {
            _this.nodeHasBeenUpdated = true;
            _this.node = node;
            _this.apiService.nodeUpdated.next(node);
        }, function (error) { return _this.logService.error(error); });
    };
    ContentMetadataComponent.prototype.ngOnChanges = function (changes) {
        var nodeChange = changes['node'];
        if (nodeChange || this.nodeHasBeenUpdated) {
            var node = nodeChange && nodeChange.currentValue || this.node;
            this.nodeHasBeenUpdated = false;
            this.basicProperties$ = this.contentMetadataService.getBasicProperties(node);
            this.groupedProperties$ = this.contentMetadataService.getGroupedProperties(node, this.preset);
        }
    };
    ContentMetadataComponent.prototype.saveNode = function (_b) {
        var nodeBody = _b.changed;
        return this.nodesApi.updateNode(this.node.id, nodeBody);
    };
    return ContentMetadataComponent;
}());
ContentMetadataComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-content-metadata',
                template: "<div class=\"adf-metadata-properties\">\n    <mat-accordion displayMode=\"flat\" [multi]=\"multi\">\n        <mat-expansion-panel [expanded]=\"!expanded\" [hideToggle]=\"!expanded\">\n            <mat-expansion-panel-header>\n                <mat-panel-title>\n                    {{ 'CORE.METADATA.BASIC.HEADER' | translate }}\n                </mat-panel-title>\n            </mat-expansion-panel-header>\n\n            <adf-card-view\n                [properties]=\"basicProperties$ | async\"\n                [editable]=\"editable\"\n                [displayEmpty]=\"displayEmpty\">\n            </adf-card-view>\n        </mat-expansion-panel>\n\n        <ng-container *ngIf=\"expanded\">\n            <ng-container *ngIf=\"groupedProperties$ | async; else loading; let groupedProperties\">\n                <div *ngFor=\"let group of groupedProperties\" class=\"adf-metadata-grouped-properties-container\">\n                    <mat-expansion-panel>\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                {{ group.title | translate }}\n                            </mat-panel-title>\n                        </mat-expansion-panel-header>\n\n                        <adf-card-view\n                            [properties]=\"group.properties\"\n                            [editable]=\"editable\"\n                            [displayEmpty]=\"displayEmpty\">\n                        </adf-card-view>\n                    </mat-expansion-panel>\n                </div>\n            </ng-container>\n            <ng-template #loading>\n                <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n            </ng-template>\n        </ng-container>\n    </mat-accordion>\n</div>",
                styles: [""],
                host: { 'class': 'adf-content-metadata' },
                encapsulation: core.ViewEncapsulation.None
            },] },
];
ContentMetadataComponent.ctorParameters = function () { return [
    { type: ContentMetadataService, },
    { type: adfCore.CardViewUpdateService, },
    { type: adfCore.NodesApiService, },
    { type: adfCore.LogService, },
    { type: adfCore.AlfrescoApiService, },
]; };
ContentMetadataComponent.propDecorators = {
    "node": [{ type: core.Input },],
    "editable": [{ type: core.Input },],
    "displayEmpty": [{ type: core.Input },],
    "expanded": [{ type: core.Input },],
    "multi": [{ type: core.Input },],
    "preset": [{ type: core.Input },],
};
var ContentMetadataModule =               (function () {
    function ContentMetadataModule() {
    }
    return ContentMetadataModule;
}());
ContentMetadataModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    flexLayout.FlexLayoutModule,
                    adfCore.CardViewModule
                ],
                exports: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ],
                declarations: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ]
            },] },
];
ContentMetadataModule.ctorParameters = function () { return []; };
var PermissionDisplayModel =               (function () {
    function PermissionDisplayModel(obj) {
        this.isInherited = false;
        if (obj) {
            this.authorityId = obj.authorityId;
            this.name = obj.name;
            this.accessStatus = obj.accessStatus;
            this.isInherited = obj.isInherited !== null && obj.isInherited !== undefined ? obj.isInherited : false;
            this.icon = obj.icon ? obj.icon : 'lock_open';
        }
    }
    return PermissionDisplayModel;
}());
var NodePermissionService =               (function () {
    function NodePermissionService(apiService, searchApiService, nodeService) {
        this.apiService = apiService;
        this.searchApiService = searchApiService;
        this.nodeService = nodeService;
    }
    NodePermissionService.prototype.getNodeRoles = function (node) {
        var _this = this;
        var retrieveSiteQueryBody = this.buildRetrieveSiteQueryBody(node.path.elements);
        return this.searchApiService.searchByQueryBody(retrieveSiteQueryBody)
            .switchMap(function (siteNodeList) {
            if (siteNodeList.list.entries.length > 0) {
                var siteName = siteNodeList.list.entries[0].entry.name;
                return _this.getGroupMembersBySiteName(siteName);
            }
            else {
                return Observable.Observable.of(node.permissions.settable);
            }
        });
    };
    NodePermissionService.prototype.updatePermissionRoles = function (node, updatedPermissionRole) {
        var permissionBody = { permissions: { locallySet: [] } };
        var index = node.permissions.locallySet.map(function (permission) { return permission.authorityId; }).indexOf(updatedPermissionRole.authorityId);
        permissionBody.permissions.locallySet = permissionBody.permissions.locallySet.concat(node.permissions.locallySet);
        if (index !== -1) {
            permissionBody.permissions.locallySet[index] = updatedPermissionRole;
        }
        else {
            permissionBody.permissions.locallySet.push(updatedPermissionRole);
        }
        return this.nodeService.updateNode(node.id, permissionBody);
    };
    NodePermissionService.prototype.getGroupMembersBySiteName = function (siteName) {
        var _this = this;
        var groupName = 'GROUP_site_' + siteName;
        return this.getGroupMemeberByGroupName(groupName)
            .map(function (res) {
            var displayResult = [];
            res.list.entries.forEach(function (member) {
                displayResult.push(_this.formattedRoleName(member.entry.displayName, 'site_' + siteName));
            });
            return displayResult;
        });
    };
    NodePermissionService.prototype.getGroupMemeberByGroupName = function (groupName, opts) {
        return Observable.Observable.fromPromise(this.apiService.groupsApi.getGroupMembers(groupName, opts));
    };
    NodePermissionService.prototype.formattedRoleName = function (displayName, siteName) {
        return displayName.replace(siteName + '_', '');
    };
    NodePermissionService.prototype.buildRetrieveSiteQueryBody = function (nodePath) {
        var pathNames = nodePath.map(function (node) { return 'name: "' + node.name + '"'; });
        var buildedPathNames = pathNames.join(' OR ');
        return {
            'query': {
                'query': buildedPathNames
            },
            'paging': {
                'maxItems': 100,
                'skipCount': 0
            },
            'include': ['aspectNames', 'properties'],
            'filterQueries': [
                {
                    'query': "TYPE:'st:site'"
                }
            ]
        };
    };
    return NodePermissionService;
}());
NodePermissionService.decorators = [
    { type: core.Injectable },
];
NodePermissionService.ctorParameters = function () { return [
    { type: adfCore.AlfrescoApiService, },
    { type: adfCore.SearchService, },
    { type: adfCore.NodesApiService, },
]; };
var PermissionListComponent =               (function () {
    function PermissionListComponent(nodeService, nodePermissionService) {
        this.nodeService = nodeService;
        this.nodePermissionService = nodePermissionService;
        this.nodeId = '';
        this.update = new core.EventEmitter();
    }
    PermissionListComponent.prototype.ngOnInit = function () {
        this.fetchNodePermissions();
    };
    PermissionListComponent.prototype.reload = function () {
        this.fetchNodePermissions();
    };
    PermissionListComponent.prototype.fetchNodePermissions = function () {
        var _this = this;
        this.nodeService.getNode(this.nodeId).subscribe(function (node) {
            _this.actualNode = node;
            _this.permissionList = _this.getPermissionList(node);
            _this.nodePermissionService.getNodeRoles(node).subscribe(function (settableList) {
                _this.settableRoles = settableList;
            });
        });
    };
    PermissionListComponent.prototype.getPermissionList = function (node) {
        var allPermissions = [];
        if (node.permissions.locallySet) {
            node.permissions.locallySet.map(function (element) {
                var permission = new PermissionDisplayModel(element);
                allPermissions.push(permission);
            });
        }
        if (node.permissions.inherited) {
            node.permissions.inherited.map(function (element) {
                var permissionInherited = new PermissionDisplayModel(element);
                permissionInherited.isInherited = true;
                allPermissions.push(permissionInherited);
            });
        }
        return allPermissions;
    };
    PermissionListComponent.prototype.saveNewRole = function (event, permissionRow) {
        var _this = this;
        var updatedPermissionRole = this.buildUpdatedPermission(event.value, permissionRow);
        this.nodePermissionService.updatePermissionRoles(this.actualNode, updatedPermissionRole)
            .subscribe(function (node) {
            _this.update.emit(updatedPermissionRole);
        });
    };
    PermissionListComponent.prototype.buildUpdatedPermission = function (newRole, permissionRow) {
        var permissionRole = {};
        permissionRole.accessStatus = permissionRow.accessStatus;
        permissionRole.name = newRole;
        permissionRole.authorityId = permissionRow.authorityId;
        return permissionRole;
    };
    return PermissionListComponent;
}());
PermissionListComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'adf-permission-list',
                template: "<div id=\"adf-permission-display-container\" class=\"adf-display-permission-container\">\n    <adf-datatable [rows]=\"permissionList\" class=\"adf-datatable-permission\">\n        <data-columns>\n            <data-column key=\"icon\" type=\"icon\" [sortable]=\"false\">\n            </data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.AUTHORITY_ID' | translate}}\" key=\"authorityId\"></data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.ROLE' | translate}}\" key=\"name\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-form-field *ngIf=\"!entry.row.getValue('isInherited') else show_only_label\">\n                        <mat-select id=\"adf-select-role-permission\"\n                                    value=\"{{entry.data.getValue(entry.row, entry.col)}}\"\n                                    (selectionChange)=\"saveNewRole($event, entry.row.obj)\">\n                          <mat-option *ngFor=\"let role of settableRoles\" [value]=\"role\">\n                            {{ role }}\n                          </mat-option>\n                        </mat-select>\n                      </mat-form-field>\n                      <ng-template #show_only_label>\n                          <span>{{entry.data.getValue(entry.row, entry.col)}}</span>\n                      </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}\" key=\"isInherited\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-chip-list>\n                        <mat-chip *ngIf=\"!!entry.data.getValue(entry.row, entry.col) else locally_set_chip\"\n                                id=\"adf-permission-inherited-label\"\n                                color=\"primary\" selected=\"true\">{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}</mat-chip>\n                    </mat-chip-list>\n                    <ng-template #locally_set_chip>\n                            <mat-chip-list>\n                                    <mat-chip id=\"adf-permission-locallyset-label\"\n                                              color=\"accent\" selected=\"true\">\n                                              {{'PERMISSION_MANAGER.PERMISSION_DISPLAY.LOCALLY_SET' | translate}}\n                                    </mat-chip>\n                            </mat-chip-list>\n                    </ng-template>\n                </ng-template>\n            </data-column>\n        </data-columns>\n    </adf-datatable>\n</div>\n\n",
                styles: [""],
                encapsulation: core.ViewEncapsulation.None
            },] },
];
PermissionListComponent.ctorParameters = function () { return [
    { type: adfCore.NodesApiService, },
    { type: NodePermissionService, },
]; };
PermissionListComponent.propDecorators = {
    "nodeId": [{ type: core.Input },],
    "update": [{ type: core.Output },],
};
var InheritPermissionDirective =               (function () {
    function InheritPermissionDirective(nodeService) {
        this.nodeService = nodeService;
        this.updated = new core.EventEmitter();
    }
    InheritPermissionDirective.prototype.onInheritPermissionClicked = function () {
        var _this = this;
        this.nodeService.getNode(this.nodeId).subscribe(function (node) {
            var nodeBody = { permissions: { isInheritanceEnabled: !node.permissions.isInheritanceEnabled } };
            _this.nodeService.updateNode(_this.nodeId, nodeBody, { include: ['permissions'] }).subscribe(function (nodeUpdated) {
                _this.updated.emit(nodeUpdated);
            });
        });
    };
    return InheritPermissionDirective;
}());
InheritPermissionDirective.decorators = [
    { type: core.Directive, args: [{
                selector: 'button[adf-inherit-permission], mat-button-toggle[adf-inherit-permission]',
                host: {
                    'role': 'button',
                    '(click)': 'onInheritPermissionClicked()'
                }
            },] },
];
InheritPermissionDirective.ctorParameters = function () { return [
    { type: adfCore.NodesApiService, },
]; };
InheritPermissionDirective.propDecorators = {
    "nodeId": [{ type: core.Input },],
    "updated": [{ type: core.Output },],
};
var PermissionManagerModule =               (function () {
    function PermissionManagerModule() {
    }
    return PermissionManagerModule;
}());
PermissionManagerModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                    forms.ReactiveFormsModule,
                    MaterialModule,
                    core$1.TranslateModule,
                    adfCore.DataTableModule,
                    adfCore.DataColumnModule
                ],
                declarations: [
                    PermissionListComponent,
                    InheritPermissionDirective
                ],
                providers: [
                    NodePermissionService
                ],
                exports: [
                    PermissionListComponent,
                    InheritPermissionDirective
                ]
            },] },
];
PermissionManagerModule.ctorParameters = function () { return []; };
var 0$1 = {
    name: 'adf-content-services',
    source: 'assets/adf-content-services'
};
var ContentModule =               (function () {
    function ContentModule() {
    }
    return ContentModule;
}());
ContentModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    adfCore.CoreModule,
                    SocialModule,
                    TagModule,
                    common.CommonModule,
                    WebScriptModule,
                    forms.FormsModule,
                    forms.ReactiveFormsModule,
                    DialogModule,
                    SearchModule,
                    DocumentListModule,
                    UploadModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentMetadataModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ],
                providers: [
                    {
                        provide: adfCore.TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: 0$1
                    },
                    RatingService,
                    ContentMetadataService,
                    PropertyDescriptorsService,
                    ContentMetadataConfigFactory,
                    BasicPropertiesService,
                    PropertyGroupTranslatorService,
                    SearchQueryBuilderService
                ],
                exports: [
                    adfCore.CoreModule,
                    SocialModule,
                    TagModule,
                    WebScriptModule,
                    DocumentListModule,
                    UploadModule,
                    SearchModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ]
            },] },
];
ContentModule.ctorParameters = function () { return []; };

exports.NodeDownloadDirective = NodeDownloadDirective;
exports.NodeSharedDirective = NodeSharedDirective;
exports.ContentDirectiveModule = ContentDirectiveModule;
exports.RatingComponent = RatingComponent;
exports.LikeComponent = LikeComponent;
exports.RatingService = RatingService;
exports.SocialModule = SocialModule;
exports.TagActionsComponent = TagActionsComponent;
exports.TagListComponent = TagListComponent;
exports.TagNodeListComponent = TagNodeListComponent;
exports.TagService = TagService;
exports.TagModule = TagModule;
exports.WebscriptComponent = WebscriptComponent;
exports.WebScriptModule = WebScriptModule;
exports.PaginationStrategy = PaginationStrategy;
exports.DocumentListComponent = DocumentListComponent;
exports.NodeEntityEvent = NodeEntityEvent;
exports.NodeEntryEvent = NodeEntryEvent;
exports.ContentColumnComponent = ContentColumnComponent;
exports.ContentColumnListComponent = ContentColumnListComponent;
exports.ContentActionComponent = ContentActionComponent;
exports.ContentActionListComponent = ContentActionListComponent;
exports.EmptyFolderContentDirective = EmptyFolderContentDirective;
exports.NoPermissionContentDirective = NoPermissionContentDirective;
exports.ShareDataTableAdapter = ShareDataTableAdapter;
exports.ShareDataRow = ShareDataRow;
exports.FolderActionsService = FolderActionsService;
exports.DocumentActionsService = DocumentActionsService;
exports.DocumentListService = DocumentListService;
exports.NodeActionsService = NodeActionsService;
exports.CustomResourcesService = CustomResourcesService;
exports.ContentActionModel = ContentActionModel;
exports.ContentActionTarget = ContentActionTarget;
exports.DocumentActionModel = DocumentActionModel;
exports.FolderActionModel = FolderActionModel;
exports.NodePaging = NodePaging;
exports.NodePagingList = NodePagingList;
exports.NodeMinimalEntry = NodeMinimalEntry;
exports.Pagination = Pagination;
exports.NodeMinimal = NodeMinimal;
exports.UserInfo = UserInfo;
exports.ContentInfo = ContentInfo;
exports.PathInfoEntity = PathInfoEntity;
exports.PathElementEntity = PathElementEntity;
exports.PermissionModel = PermissionModel;
exports.PermissionStyleModel = PermissionStyleModel;
exports.DocumentListModule = DocumentListModule;
exports.UploadButtonComponent = UploadButtonComponent;
exports.UploadVersionButtonComponent = UploadVersionButtonComponent;
exports.FileUploadingDialogComponent = FileUploadingDialogComponent;
exports.UploadDragAreaComponent = UploadDragAreaComponent;
exports.FileUploadingListComponent = FileUploadingListComponent;
exports.FileUploadingListRowComponent = FileUploadingListRowComponent;
exports.FileDraggableDirective = FileDraggableDirective;
exports.UploadBase = UploadBase;
exports.UploadModule = UploadModule;
exports.SearchQueryBuilderService = SearchQueryBuilderService;
exports.SearchComponent = SearchComponent;
exports.SearchControlComponent = SearchControlComponent;
exports.SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR;
exports.SearchTriggerDirective = SearchTriggerDirective;
exports.EmptySearchResultComponent = EmptySearchResultComponent;
exports.SearchFilterComponent = SearchFilterComponent;
exports.SearchChipListComponent = SearchChipListComponent;
exports.ALFRESCO_SEARCH_DIRECTIVES = ALFRESCO_SEARCH_DIRECTIVES;
exports.SearchModule = SearchModule;
exports.Relations = Relations;
exports.DropdownSitesComponent = DropdownSitesComponent;
exports.SitesDropdownModule = SitesDropdownModule;
exports.BreadcrumbComponent = BreadcrumbComponent;
exports.DropdownBreadcrumbComponent = DropdownBreadcrumbComponent;
exports.BreadcrumbModule = BreadcrumbModule;
exports.VersionListComponent = VersionListComponent;
exports.VersionManagerComponent = VersionManagerComponent;
exports.VersionUploadComponent = VersionUploadComponent;
exports.VersionManagerModule = VersionManagerModule;
exports.NameLocationCellComponent = NameLocationCellComponent;
exports.ContentNodeSelectorPanelComponent = ContentNodeSelectorPanelComponent;
exports.ContentNodeSelectorComponent = ContentNodeSelectorComponent;
exports.ContentNodeSelectorService = ContentNodeSelectorService;
exports.ContentNodeDialogService = ContentNodeDialogService;
exports.ContentNodeSelectorModule = ContentNodeSelectorModule;
exports.DownloadZipDialogComponent = DownloadZipDialogComponent;
exports.FolderDialogComponent = FolderDialogComponent;
exports.NodeLockDialogComponent = NodeLockDialogComponent;
exports.ShareDialogComponent = ShareDialogComponent;
exports.ConfirmDialogComponent = ConfirmDialogComponent;
exports.DialogModule = DialogModule;
exports.FolderCreateDirective = FolderCreateDirective;
exports.FolderEditDirective = FolderEditDirective;
exports.FolderDirectiveModule = FolderDirectiveModule;
exports.ContentMetadataCardComponent = ContentMetadataCardComponent;
exports.BasicPropertiesService = BasicPropertiesService;
exports.ContentMetadataService = ContentMetadataService;
exports.PropertyDescriptorsService = PropertyDescriptorsService;
exports.PropertyGroupTranslatorService = PropertyGroupTranslatorService;
exports.ContentMetadataConfigFactory = ContentMetadataConfigFactory;
exports.IndifferentConfigService = IndifferentConfigService;
exports.LayoutOrientedConfigService = LayoutOrientedConfigService;
exports.AspectOrientedConfigService = AspectOrientedConfigService;
exports.ContentMetadataModule = ContentMetadataModule;
exports.PermissionListComponent = PermissionListComponent;
exports.InheritPermissionDirective = InheritPermissionDirective;
exports.NodePermissionService = NodePermissionService;
exports.PermissionDisplayModel = PermissionDisplayModel;
exports.PermissionManagerModule = PermissionManagerModule;
exports.ContentModule = ContentModule;
exports.e = ContentMetadataComponent;
exports.c = NodeLockDirective;
exports.b = MaterialModule;
exports.a = modules;
exports.i = InheritPermissionDirective;
exports.g = PermissionListComponent;
exports.f = PermissionManagerModule;
exports.h = NodePermissionService;
exports.d = SearchWidgetContainerComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=adf-content-services.umd.js.map
